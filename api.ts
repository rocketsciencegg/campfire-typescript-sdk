/* tslint:disable */
/* eslint-disable */
/**
 * Campfire Developer APIs
 * ## Introduction Campfire\'s developer APIs offer granular access to Campfire\'s core accounting, revenue recognition, and financial data features.  These APIs are designed to be used by developers to build custom integrations, automate workflows, and perform any other programmatic operations. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * * `NONE` - None * `OPERATING` - Operating * `INVESTING` - Investing * `FINANCING` - Financing
 */

export const AccountCashflowClassificationEnum = {
    None: 'NONE',
    Operating: 'OPERATING',
    Investing: 'INVESTING',
    Financing: 'FINANCING'
} as const;

export type AccountCashflowClassificationEnum = typeof AccountCashflowClassificationEnum[keyof typeof AccountCashflowClassificationEnum];


/**
 * * `BANK` - Bank * `ACCOUNTS_RECEIVABLE` - Accounts Receivable * `OTHER_CURRENT_ASSET` - Other Current Asset * `FIXED_ASSET` - Fixed Asset * `OTHER_ASSET` - Other Asset * `ACCOUNTS_PAYABLE` - Accounts Payable * `UNAPPLIED_CREDITS` - Unapplied Credits * `CREDIT_CARD` - Credit Card * `ACCRUED_REVENUE` - Accrued Revenue * `DEFERRED_REVENUE` - Deferred Revenue * `OTHER_CURRENT_LIABILITY` - Other Current Liability * `LONG_TERM_LIABILITY` - Long Term Liability * `UNBILLED_RECEIVABLE` - Unbilled Receivable * `EQUITY` - Equity * `RETAINED_EARNINGS` - Retained Earnings * `INCOME` - Income * `COST_OF_GOODS_SOLD` - Cost of Goods Sold * `EXPENSE` - Expense * `DEFERRED_EXPENSE` - Deferred Expense * `OTHER_INCOME` - Other Income * `OTHER_EXPENSE` - Other Expense * `REALIZED_GAIN_LOSS` - Realized Gain Loss * `UNREALIZED_GAIN_LOSS` - Unrealized Gain Loss * `PREPAID` - Prepaid * `COST_ALLOCATION` - Cost Allocation * `UNCATEGORIZED` - Uncategorized
 */

export const AccountSubtypeEnum = {
    Bank: 'BANK',
    AccountsReceivable: 'ACCOUNTS_RECEIVABLE',
    OtherCurrentAsset: 'OTHER_CURRENT_ASSET',
    FixedAsset: 'FIXED_ASSET',
    OtherAsset: 'OTHER_ASSET',
    AccountsPayable: 'ACCOUNTS_PAYABLE',
    UnappliedCredits: 'UNAPPLIED_CREDITS',
    CreditCard: 'CREDIT_CARD',
    AccruedRevenue: 'ACCRUED_REVENUE',
    DeferredRevenue: 'DEFERRED_REVENUE',
    OtherCurrentLiability: 'OTHER_CURRENT_LIABILITY',
    LongTermLiability: 'LONG_TERM_LIABILITY',
    UnbilledReceivable: 'UNBILLED_RECEIVABLE',
    Equity: 'EQUITY',
    RetainedEarnings: 'RETAINED_EARNINGS',
    Income: 'INCOME',
    CostOfGoodsSold: 'COST_OF_GOODS_SOLD',
    Expense: 'EXPENSE',
    DeferredExpense: 'DEFERRED_EXPENSE',
    OtherIncome: 'OTHER_INCOME',
    OtherExpense: 'OTHER_EXPENSE',
    RealizedGainLoss: 'REALIZED_GAIN_LOSS',
    UnrealizedGainLoss: 'UNREALIZED_GAIN_LOSS',
    Prepaid: 'PREPAID',
    CostAllocation: 'COST_ALLOCATION',
    Uncategorized: 'UNCATEGORIZED'
} as const;

export type AccountSubtypeEnum = typeof AccountSubtypeEnum[keyof typeof AccountSubtypeEnum];


/**
 * * `ASSET` - Asset * `LIABILITY` - Liability * `EQUITY` - Equity * `REVENUE` - Revenue * `COGS` - Cost of Goods Sold * `OPERATING_EXPENSES` - Operating Expenses * `OTHER_INCOME` - Other Income * `OTHER_EXPENSE` - Other Expense * `UNCATEGORIZED` - Uncategorized * `COST_ALLOCATION` - Cost Allocation
 */

export const AccountTypeEnum = {
    Asset: 'ASSET',
    Liability: 'LIABILITY',
    Equity: 'EQUITY',
    Revenue: 'REVENUE',
    Cogs: 'COGS',
    OperatingExpenses: 'OPERATING_EXPENSES',
    OtherIncome: 'OTHER_INCOME',
    OtherExpense: 'OTHER_EXPENSE',
    Uncategorized: 'UNCATEGORIZED',
    CostAllocation: 'COST_ALLOCATION'
} as const;

export type AccountTypeEnum = typeof AccountTypeEnum[keyof typeof AccountTypeEnum];


export interface AccountingBill {
    'id': number;
    'lines': Array<AccountingBillLine>;
    'payments': Array<AccountingBillPayment>;
    'payment_journal_entries': Array<number>;
    'status': string;
    'past_due_days': number | null;
    'entity_name': string;
    'entity_currency': string;
    'vendor_name': string;
    /**
     * Return AP account name with number in \'number - name\' format, similar to name_and_number.
     */
    'ap_account_name': string | null;
    'attachments': Array<any>;
    'total_amount': number;
    'amount_due': number;
    'amount_paid': number;
    'item_date'?: string | null;
    'migrated_journal_id'?: number | null;
    'voided_date': string;
    'voided_journal_entry_order': string;
    'amortizations': string;
    'last_modified_at': string;
    'ramp_use_sandbox': string;
    'zip_metadata': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'payment_term_name': string;
    'search_vector': string | null;
    'search_text': string | null;
    'mailing_address'?: string | null;
    'terms'?: TermsEnum | null;
    'bill_number': string;
    'bill_date': string;
    'due_date': string;
    'paid_date'?: string | null;
    'message_on_bill'?: string | null;
    'source_id'?: string | null;
    'source'?: string | null;
    'external_ramp_id'?: string | null;
    'payment_status'?: AccountingBillPaymentStatusEnum | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'created_at': string;
    'tax_behavior'?: TaxBehaviorEnum | null;
    'bill_type'?: BillTypeEnum;
    'customer': number;
    'entity': number;
    'vendor': number | null;
    /**
     * Payment term for this bill
     */
    'payment_term'?: number | null;
    'journal_entry'?: number | null;
    'source_file'?: number | null;
    'tax_rate'?: number | null;
    /**
     * Accounts Payable account for this bill
     */
    'ap_account'?: number | null;
    'voided_journal_entry'?: number | null;
}


export interface AccountingBillLine {
    'id': number;
    'bill'?: number;
    'account_number': string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'account_name': string;
    'department_name': string;
    'bill_customer_name': string;
    'tags': Array<TransactionTag>;
    'amortization_schedule': Array<AmortizationSchedule>;
    'tax_rate_name': string;
    'tax_rate_value': number;
    'description'?: string | null;
    'amount'?: number;
    'tax'?: number;
    'tax_description'?: string | null;
    'source'?: string | null;
    'source_id'?: string | null;
    'currency'?: string;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'account': number;
    'tax_rate'?: number | null;
    'bill_customer'?: number | null;
    'department'?: number | null;
}
export interface AccountingBillPayment {
    'id': number;
    'payment_transaction_bank_description': string;
    'payment_journal_entry_order': string;
    'voided_journal_entry_order': string;
    'currency'?: string;
    'amount'?: number;
    'payment_date'?: string | null;
    'source'?: string | null;
    'source_id'?: string | null;
    'created_at': string;
    'voided_date'?: string | null;
    'last_modified_at': string;
    'customer': number;
    'bill': number;
    'payment_journal_entry': number;
    'payment_transaction'?: number | null;
    'voided_journal_entry'?: number | null;
}
/**
 * * `partial` - Partially Paid * `open` - Open * `paid` - Paid * `payment_not_found` - Payment Not Found * `payment_pending` - Payment Pending * `voided` - Voided
 */

export const AccountingBillPaymentStatusEnum = {
    Partial: 'partial',
    Open: 'open',
    Paid: 'paid',
    PaymentNotFound: 'payment_not_found',
    PaymentPending: 'payment_pending',
    Voided: 'voided'
} as const;

export type AccountingBillPaymentStatusEnum = typeof AccountingBillPaymentStatusEnum[keyof typeof AccountingBillPaymentStatusEnum];


export interface AccountingCreditMemo {
    'id': number;
    'lines': Array<AccountingCreditMemoLine>;
    'payments': Array<AccountingCreditMemoPayment>;
    /**
     * Calculate amount remaining from database fields
     */
    'amount_remaining': number;
    'entity_name': string;
    'entity_currency': string;
    'client_name': string;
    'client_email': string;
    'contract_name': string;
    'credit_account_number': string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'credit_account_name': string;
    'attachments': Array<any>;
    'credit_memo_number'?: string;
    'migrated_journal_id'?: number | null;
    'voided_date': string;
    'voided_journal_entry_order': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'search_vector': string | null;
    'search_text': string | null;
    'ref_number'?: string | null;
    'credit_memo_date': string;
    'applied_date'?: string | null;
    'message_on_credit_memo'?: string | null;
    'application_status'?: ApplicationStatusEnum | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'created_at': string;
    'last_sent_at'?: string | null;
    /**
     * ID of the negation transaction in Anrok for this credit memo
     */
    'anrok_transaction_id'?: string | null;
    /**
     * Sum of all line item amounts
     */
    'total_amount'?: number;
    /**
     * Sum of all non-voided payment amounts
     */
    'amount_used'?: number;
    'customer': number;
    'entity': number;
    'client'?: number | null;
    'credit_account'?: number | null;
    'journal_entry'?: number | null;
    'contract'?: number | null;
    'voided_journal_entry'?: number | null;
    'anrok_connection'?: number | null;
}


export interface AccountingCreditMemoLine {
    'id': number;
    'credit_memo'?: number;
    'account_number': string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'account_name': string;
    'product_name': string;
    'department_name': string;
    'tags': Array<TransactionTag>;
    'description'?: string | null;
    'amount'?: number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'product'?: number | null;
    'account': number;
    'department'?: number | null;
}
export interface AccountingCreditMemoPayment {
    'id': number;
    'payment_journal_entry_order': string;
    'invoice': string;
    'currency'?: string;
    'amount'?: number;
    'payment_date'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'voided_date'?: string | null;
    'customer': number;
    'credit_memo': number;
    'payment_journal_entry': number;
    'payment_transaction'?: number | null;
    'voided_journal_entry'?: number | null;
}
export interface AccountingDebitMemo {
    'id': number;
    'lines': Array<AccountingDebitMemoLine>;
    'payments': Array<AccountingDebitMemoPayment>;
    /**
     * Calculate amount remaining from database fields
     */
    'amount_remaining': number;
    'entity_name': string;
    'entity_currency': string;
    'vendor_name': string;
    'debit_account_number': string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'debit_account_name': string;
    'attachments': Array<any>;
    'debit_memo_number'?: string;
    'migrated_journal_id'?: number | null;
    'voided_date': string;
    'voided_journal_entry_order': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'search_vector': string | null;
    'search_text': string | null;
    'ref_number'?: string | null;
    'debit_memo_date': string;
    'applied_date'?: string | null;
    'message_on_debit_memo'?: string | null;
    'source_id'?: string | null;
    'source'?: string | null;
    'application_status'?: ApplicationStatusEnum | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'created_at': string;
    /**
     * Sum of all line item amounts
     */
    'total_amount'?: number;
    /**
     * Sum of all non-voided payment amounts
     */
    'amount_used'?: number;
    'customer': number;
    'entity': number;
    'vendor'?: number | null;
    'debit_account'?: number | null;
    'journal_entry'?: number | null;
    'voided_journal_entry'?: number | null;
}


export interface AccountingDebitMemoLine {
    'id': number;
    'debit_memo'?: number;
    'account_number': string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'account_name': string;
    'department_name': string;
    'tags': Array<TransactionTag>;
    'description'?: string | null;
    'amount'?: number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'account': number;
    'department'?: number | null;
}
export interface AccountingDebitMemoPayment {
    'id': number;
    'payment_journal_entry_order': string;
    'bill': string;
    'currency'?: string;
    'amount'?: number;
    'payment_date'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'voided_date'?: string | null;
    'customer': number;
    'debit_memo': number;
    'payment_journal_entry': number;
    'payment_transaction'?: number | null;
    'voided_journal_entry'?: number | null;
}
export interface AccountingInvoice {
    'id': number;
    'lines': Array<AccountingInvoiceLine>;
    'emails': Array<{ [key: string]: any; }>;
    'payments': Array<AccountingInvoicePayment>;
    'payment_journal_entries': Array<number>;
    'journal_entry_intercompany': string;
    'client_name': string;
    'client_email': string;
    'client_invoice_message': string;
    'client_use_stripe_auto_bill': boolean;
    'status': string;
    'past_due_days': number | null;
    'entity_name': string;
    'entity_currency': string;
    'entity_invoice_message': string;
    'total_amount': number;
    'amount_paid': number;
    'amount_due': number;
    'contract_name': string;
    'attachments': Array<any>;
    'invoice_number'?: string;
    'stripe_connection_name': string;
    'stripe_connection_entity': number;
    'stripe_connection_billing_portal_enabled': boolean;
    'avalara_connection_name': string;
    'avalara_connection_company': string;
    'tax_rate_name': string;
    'tax_rate_value': number;
    'payment_term_name': string;
    'revenue_transactions'?: Array<number>;
    'item_date'?: string | null;
    'migrated_journal_id'?: number | null;
    'voided_journal_entry_order': number | null;
    'department'?: number | null;
    'department_name'?: string | null;
    'tags'?: Array<number>;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'search_vector': string | null;
    'search_text': string | null;
    'auto_send_invoice'?: boolean | null;
    'auto_send_invoice_at'?: string | null;
    'auto_sent_at': string | null;
    /**
     * Dictionary tracking when reminders were sent for each day overdue (e.g., {\'5\': \'2024-01-15\', \'10\': \'2024-01-20\'})
     */
    'reminder_sent_dates'?: any;
    /**
     * Dictionary tracking when pre-due reminders were sent for each day before due date (e.g., {\'3\': \'2024-01-10\', \'7\': \'2024-01-06\'})
     */
    'pre_due_reminder_sent_dates'?: any;
    'billing_address'?: string | null;
    'billing_addressee'?: string | null;
    'shipping_address'?: string | null;
    'shipping_addressee'?: string | null;
    'terms'?: TermsEnum | null;
    'ref_number'?: string | null;
    'purchase_order_number'?: string | null;
    'invoice_date': string;
    'due_date': string;
    'shipping_date'?: string | null;
    'paid_date'?: string | null;
    'uncollectible_date'?: string | null;
    'sent_date': string | null;
    'period_start'?: string | null;
    'period_end'?: string | null;
    'location_of_sale'?: string | null;
    'message_on_invoice'?: string | null;
    'payment_status'?: PaymentStatusF21Enum | null;
    /**
     * ID of the transaction in Anrok (set when transaction is created)
     */
    'anrok_transaction_id'?: string | null;
    'warning_message'?: string | null;
    'created_at': string;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'last_sent_at': string | null;
    'integration_id'?: string | null;
    'integration_context'?: any | null;
    'vat_number'?: string | null;
    /**
     * Discount amount for the invoice
     */
    'discount'?: number | null;
    /**
     * Discount amount applied based on payment term early payment discount
     */
    'payment_term_applied_discount'?: number | null;
    'use_stripe_auto_bill'?: boolean | null;
    'stripe_payment_link_id'?: string | null;
    'stripe_payment_intent_id'?: string | null;
    'stripe_invoice_id'?: string | null;
    'stripe_pdf_url'?: string | null;
    'stripe_payment_link'?: string | null;
    'source'?: string | null;
    'source_id'?: string | null;
    'voided_date'?: string | null;
    'customer': number;
    'entity': number;
    'client'?: number | null;
    'payment_term'?: number | null;
    'bad_debt_journal_entry'?: number | null;
    'journal_entry'?: number | null;
    'voided_journal_entry'?: number | null;
    'entity_transfer_journal_entry'?: number | null;
    'contract'?: number | null;
    'avalara_connection'?: number | null;
    'sphere_connection'?: number | null;
    'anrok_connection'?: number | null;
    'tax_rate'?: number | null;
    'stripe_connection'?: number | null;
    'source_file'?: number | null;
}


export interface AccountingInvoiceLine {
    'id': number;
    'invoice'?: number;
    'product_name': string;
    'product_bundle_name': string;
    'stripe_product_id': string;
    'product_is_taxable': boolean;
    'anrok_item_id': string;
    'sphere_item_id': string;
    'service_date'?: string | null;
    'description'?: string | null;
    'quantity'?: number;
    'rate'?: number;
    'currency'?: string;
    'amount'?: number;
    'tax'?: number;
    'tax_description'?: string | null;
    /**
     * Avalara entity/use code for line-level tax exemptions
     */
    'entity_use_code'?: string | null;
    /**
     * Discount amount in currency
     */
    'discount'?: number;
    /**
     * Discount percentage (0-100)
     */
    'discount_percentage'?: number;
    /**
     * Discount amount calculated from percentage
     */
    'discount_amount'?: number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'product'?: number | null;
    'product_bundle'?: number | null;
}
/**
 * Lightweight serializer for the invoice list endpoint.  Excludes heavy nested fields (emails, payments, attachments, payment_journal_entries) that are only needed on the detail view. Keeps lines for the duplicate invoice action.
 */
export interface AccountingInvoiceList {
    'id': number;
    'lines': Array<AccountingInvoiceLine>;
    'journal_entry_intercompany': string;
    'client_name': string;
    'client_email': string;
    'client_invoice_message': string;
    'client_use_stripe_auto_bill': boolean;
    'status': string;
    'past_due_days': number | null;
    'entity_name': string;
    'entity_currency': string;
    'entity_invoice_message': string;
    'total_amount': number;
    'amount_paid': number;
    'amount_due': number;
    'contract_name': string;
    'invoice_number'?: string;
    'stripe_connection_name': string;
    'stripe_connection_entity': number;
    'stripe_connection_billing_portal_enabled': boolean;
    'avalara_connection_name': string;
    'avalara_connection_company': string;
    'tax_rate_name': string;
    'tax_rate_value': number;
    'payment_term_name': string;
    'revenue_transactions'?: Array<number>;
    'item_date'?: string | null;
    'voided_journal_entry_order': number | null;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'search_vector': string | null;
    'search_text': string | null;
    'auto_send_invoice'?: boolean | null;
    'auto_send_invoice_at'?: string | null;
    'auto_sent_at': string | null;
    /**
     * Dictionary tracking when reminders were sent for each day overdue (e.g., {\'5\': \'2024-01-15\', \'10\': \'2024-01-20\'})
     */
    'reminder_sent_dates'?: any;
    /**
     * Dictionary tracking when pre-due reminders were sent for each day before due date (e.g., {\'3\': \'2024-01-10\', \'7\': \'2024-01-06\'})
     */
    'pre_due_reminder_sent_dates'?: any;
    'billing_address'?: string | null;
    'billing_addressee'?: string | null;
    'shipping_address'?: string | null;
    'shipping_addressee'?: string | null;
    'terms'?: TermsEnum | null;
    'ref_number'?: string | null;
    'purchase_order_number'?: string | null;
    'invoice_date': string;
    'due_date': string;
    'shipping_date'?: string | null;
    'paid_date'?: string | null;
    'uncollectible_date'?: string | null;
    'sent_date': string | null;
    'period_start'?: string | null;
    'period_end'?: string | null;
    'location_of_sale'?: string | null;
    'message_on_invoice'?: string | null;
    'payment_status'?: PaymentStatusF21Enum | null;
    /**
     * ID of the transaction in Anrok (set when transaction is created)
     */
    'anrok_transaction_id'?: string | null;
    'warning_message'?: string | null;
    'created_at': string;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'last_sent_at': string | null;
    'integration_id'?: string | null;
    'integration_context'?: any | null;
    'vat_number'?: string | null;
    /**
     * Discount amount for the invoice
     */
    'discount'?: number | null;
    /**
     * Discount amount applied based on payment term early payment discount
     */
    'payment_term_applied_discount'?: number | null;
    'use_stripe_auto_bill'?: boolean | null;
    'stripe_payment_link_id'?: string | null;
    'stripe_payment_intent_id'?: string | null;
    'stripe_invoice_id'?: string | null;
    'stripe_pdf_url'?: string | null;
    'stripe_payment_link'?: string | null;
    'source'?: string | null;
    'source_id'?: string | null;
    'voided_date'?: string | null;
    'customer': number;
    'entity': number;
    'client'?: number | null;
    'payment_term'?: number | null;
    'bad_debt_journal_entry'?: number | null;
    'journal_entry'?: number | null;
    'voided_journal_entry'?: number | null;
    'entity_transfer_journal_entry'?: number | null;
    'contract'?: number | null;
    'avalara_connection'?: number | null;
    'sphere_connection'?: number | null;
    'anrok_connection'?: number | null;
    'tax_rate'?: number | null;
    'stripe_connection'?: number | null;
    'source_file'?: number | null;
}


export interface AccountingInvoicePayment {
    'id': number;
    'credit_memo': string;
    'payment_transaction_bank_description': string;
    'payment_journal_entry_order': string;
    'payment_intercompany_journal': string;
    'voided_journal_entry_order': string;
    'currency'?: string;
    'amount'?: number;
    'payment_date'?: string | null;
    'created_at': string;
    'voided_date'?: string | null;
    'source'?: AccountingInvoicePaymentSourceEnum | null;
    /**
     * Type of payment: credit memo application, bank transaction, or manual transaction  * `CREDIT_MEMO` - Credit Memo * `BANK_TRANSACTION` - Bank Transaction * `MANUAL_TRANSACTION` - Manual Transaction
     */
    'payment_type': PaymentTypeEnum | null;
    'last_modified_at': string;
    'customer': number;
    'invoice': number;
    'payment_journal_entry'?: number | null;
    'payment_transaction'?: number | null;
    'fx_gain_loss_realized_transaction'?: number | null;
    'payment_term_discount_transaction'?: number | null;
    'voided_journal_entry'?: number | null;
    'payment_transactions'?: Array<number>;
}


/**
 * * `STRIPE` - Stripe * `MANUAL` - Manual
 */

export const AccountingInvoicePaymentSourceEnum = {
    Stripe: 'STRIPE',
    Manual: 'MANUAL'
} as const;

export type AccountingInvoicePaymentSourceEnum = typeof AccountingInvoicePaymentSourceEnum[keyof typeof AccountingInvoicePaymentSourceEnum];


export interface AmortizationSchedule {
    'id': number;
    'accounting_amortization'?: number;
    'journal_entry_order': string;
    'date': string;
    'amount': number;
    'posted'?: boolean;
    'amortization': number;
    'customer': number;
    'transaction'?: number | null;
    'bill_line'?: number | null;
    'journal_entry'?: number | null;
}
/**
 * * `open` - Open * `partially_used` - Partially Used * `used` - Used * `voided` - Voided
 */

export const ApplicationStatusEnum = {
    Open: 'open',
    PartiallyUsed: 'partially_used',
    Used: 'used',
    Voided: 'voided'
} as const;

export type ApplicationStatusEnum = typeof ApplicationStatusEnum[keyof typeof ApplicationStatusEnum];


export interface AsyncTask {
    'id': number;
    'created_by_name': string;
    'name': string;
    'created_at': string;
    'status'?: AsyncTaskStatusEnum;
    'error_message'?: string | null;
    /**
     * Exception class name
     */
    'error_type'?: string | null;
    /**
     * Number of retry attempts
     */
    'retries'?: number;
    'completed_at'?: string | null;
    /**
     * When task execution started
     */
    'started_at'?: string | null;
    /**
     * Celery task UUID from self.request.id
     */
    'celery_task_id'?: string | null;
    /**
     * Root task ID in workflow chain
     */
    'root_task_id'?: string | null;
    /**
     * Parent task ID if chained
     */
    'parent_task_id'?: string | null;
    /**
     * APM distributed trace ID
     */
    'trace_id'?: string | null;
    /**
     * APM span ID
     */
    'span_id'?: string | null;
    /**
     * Task positional arguments
     */
    'task_args'?: any;
    /**
     * Task keyword arguments
     */
    'task_kwargs'?: any;
    /**
     * Task execution result
     */
    'result'?: any | null;
    'content'?: any | null;
    'customer': number | null;
    'created_by': number | null;
}


/**
 * * `PENDING` - Pending * `PROCESSING` - Processing * `COMPLETED` - Completed * `FAILED` - Failed
 */

export const AsyncTaskStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type AsyncTaskStatusEnum = typeof AsyncTaskStatusEnum[keyof typeof AsyncTaskStatusEnum];


export interface BankAccount {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'entity_name': string;
    'department_name': string;
    'chart_of_accounts_account_name': string;
    'account_type': string;
    'account_subtype': string;
    'account_cashflow_classification': string;
    'type_name': string;
    'subtype_name': string;
    'cashflow_classification_name': string;
    'account_id': string;
    'currency'?: string;
    'external_account_id'?: string | null;
    'name'?: string | null;
    'nickname'?: string | null;
    'status'?: string | null;
    'type'?: BankAccountTypeEnum | null;
    'available_balance'?: number | null;
    'current_balance'?: number | null;
    'institution_id'?: string | null;
    'source'?: string | null;
    /**
     * ABA routing number (9 digits) for US bank accounts
     */
    'aba_routing_number'?: string | null;
    /**
     * SWIFT BIC code (8 or 11 characters) for international accounts
     */
    'swift_bic'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'entity': number;
    'chart_of_accounts_account'?: number | null;
    'department'?: number | null;
    'tags': Array<number>;
}


/**
 * * `CHECKING` - Checking * `SAVING` - Savings * `CREDIT_CARD` - Credit Card * `DEBIT_CARD` - Debit Card * `INVESTMENT` - Investment * `LOAN` - Loan
 */

export const BankAccountTypeEnum = {
    Checking: 'CHECKING',
    Saving: 'SAVING',
    CreditCard: 'CREDIT_CARD',
    DebitCard: 'DEBIT_CARD',
    Investment: 'INVESTMENT',
    Loan: 'LOAN'
} as const;

export type BankAccountTypeEnum = typeof BankAccountTypeEnum[keyof typeof BankAccountTypeEnum];


export interface BankTransaction {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'account_name': string;
    'date_month': string | null;
    'date_year': string | null;
    'journal': number | null;
    'journal_order': string | null;
    'intercompany_journal': number | null;
    'reconciliation_report': number;
    'reconciliation_report_ending_date': string;
    'last_modified_at': string;
    'transaction_id'?: string;
    'external_transaction_id'?: string | null;
    'currency'?: string;
    'amount'?: number | null;
    'amount_native'?: number | null;
    'posted_at'?: string | null;
    'status'?: string | null;
    'note'?: string | null;
    'bank_description'?: string | null;
    'external_memo'?: string | null;
    'merchant_id'?: string | null;
    'merchant_name'?: string | null;
    'merchant_nickname'?: string | null;
    'kind'?: string | null;
    'excluded'?: boolean;
    'assigned'?: boolean;
    'metadata'?: any | null;
    'created_at': string;
    'customer': number;
    'account': number;
}
/**
 * * `BILL` - Bill * `PAYROLL` - Payroll * `REIMBURSEMENT` - Reimbursement
 */

export const BillTypeEnum = {
    Bill: 'BILL',
    Payroll: 'PAYROLL',
    Reimbursement: 'REIMBURSEMENT'
} as const;

export type BillTypeEnum = typeof BillTypeEnum[keyof typeof BillTypeEnum];


/**
 * * `monthly` - Monthly * `quarterly` - Quarterly * `biannual` - Bi Annualy * `annual` - Annual
 */

export const BillingFrequencyEnum = {
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    Biannual: 'biannual',
    Annual: 'annual'
} as const;

export type BillingFrequencyEnum = typeof BillingFrequencyEnum[keyof typeof BillingFrequencyEnum];


/**
 * * `standard` - Standard (Account-based) * `department_row` - Department (Row)
 */

export const BreakdownTypeEnum = {
    Standard: 'standard',
    DepartmentRow: 'department_row'
} as const;

export type BreakdownTypeEnum = typeof BreakdownTypeEnum[keyof typeof BreakdownTypeEnum];


export interface Budget {
    'id': number;
    'entity_name': string;
    'prior_start_date': string;
    'prior_end_date': string;
    'department_name': string;
    'tags': Array<TransactionTag>;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'name': string;
    'description'?: string | null;
    'cadence'?: string | null;
    'start_date': string;
    'end_date'?: string | null;
    'periods'?: number;
    'breakdown_type'?: BreakdownTypeEnum;
    'currency'?: string;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'entity'?: number | null;
    'department'?: number | null;
}


export interface BudgetAccount {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'account_name': string;
    'account_lineage': string;
    'department_name': string;
    'period'?: number;
    'amount'?: number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'budget': number;
    'account': number;
    'department': number | null;
}
export interface BulkApplyInvoicePayment {
    'transaction_id': number;
    'invoice_ids'?: Array<number> | null;
    'filters'?: BulkApplyInvoicePaymentFilters | null;
}
export interface BulkApplyInvoicePaymentFilters {
    'entity'?: number | null;
    'client'?: number | null;
    'status'?: string | null;
    'max_date'?: string | null;
    'search_query'?: string | null;
}
export interface BulkBill {
    'bill_number': string;
}
export interface BulkBillSearch {
    'bills': Array<BulkBill>;
}
export interface BulkContract {
    'deal_name'?: string | null;
}
export interface BulkContractSearch {
    'contracts': Array<BulkContract>;
}
/**
 * Serializer for bulk invoice creation. Accepts a list of invoice data.
 */
export interface BulkCreateInvoices {
    /**
     * List of invoice data dictionaries matching AccountingInvoiceSerializer structure
     */
    'invoices': Array<{ [key: string]: any; }>;
}
export interface BulkCreditMemo {
    'credit_memo_number': string;
}
export interface BulkCreditMemoSearch {
    'credit_memos': Array<BulkCreditMemo>;
}
export interface BulkDebitMemo {
    'debit_memo_number': string;
}
export interface BulkDebitMemoSearch {
    'debit_memos': Array<BulkDebitMemo>;
}
export interface BulkDepartment {
    'name': string;
    'parent_id'?: number | null;
}
export interface BulkDepartmentSearch {
    'departments': Array<BulkDepartment>;
    /**
     * If true, create departments that don\'t exist
     */
    'upsert'?: boolean;
}
export interface BulkInvoice {
    'invoice_number': string;
}
export interface BulkInvoiceSearch {
    'invoices': Array<BulkInvoice>;
}
export interface BulkTag {
    'name': string;
}
export interface BulkTagSearch {
    'tags': Array<BulkTag>;
    /**
     * If true, create tags that don\'t exist
     */
    'upsert'?: boolean;
}
export interface BulkVendor {
    'name': string;
    'external_id'?: string | null;
    'vendor_type'?: BulkVendorVendorTypeEnum;
    'email'?: string | null;
}


export interface BulkVendorSearch {
    'vendors': Array<BulkVendor>;
    /**
     * If true, create vendors that don\'t exist
     */
    'upsert'?: boolean;
}
/**
 * * `vendor` - vendor * `customer` - customer * `employee` - employee
 */

export const BulkVendorVendorTypeEnum = {
    Vendor: 'vendor',
    Customer: 'customer',
    Employee: 'employee'
} as const;

export type BulkVendorVendorTypeEnum = typeof BulkVendorVendorTypeEnum[keyof typeof BulkVendorVendorTypeEnum];


export interface CaApiGetBalanceSheetRetrieve200Response {
    'balance_sheet'?: Array<CaApiGetBalanceSheetRetrieve200ResponseBalanceSheetInner>;
    'start_date'?: string;
    'end_date'?: string;
    'cadence'?: string;
    'headers'?: object;
}
export interface CaApiGetBalanceSheetRetrieve200ResponseBalanceSheetInner {
    'account_id'?: number;
    'account_name'?: string;
    'account_number'?: string;
    'hierarchy'?: Array<string>;
    'YYYY-MM-DD'?: CaApiGetBalanceSheetRetrieve200ResponseBalanceSheetInnerYYYYMMDD;
}
export interface CaApiGetBalanceSheetRetrieve200ResponseBalanceSheetInnerYYYYMMDD {
    'ending_balance'?: number;
}
export interface CaApiGetCashFlowRetrieve200Response {
    'cash_flow'?: Array<CaApiGetCashFlowRetrieve200ResponseCashFlowInner>;
    'start_date'?: string;
    'end_date'?: string;
    'cadence'?: string;
}
export interface CaApiGetCashFlowRetrieve200ResponseCashFlowInner {
    'account_id'?: number;
    'account_name'?: string;
    'account_number'?: string;
    'hierarchy'?: Array<string>;
    'transaction_activity'?: CaApiGetCashFlowRetrieve200ResponseCashFlowInnerTransactionActivity;
}
export interface CaApiGetCashFlowRetrieve200ResponseCashFlowInnerTransactionActivity {
    'YYYY-MM-DD'?: number;
}
export interface CaApiGetIncomeStatementRetrieve200Response {
    'income_statement'?: Array<CaApiGetIncomeStatementRetrieve200ResponseIncomeStatementInner>;
    'start_date'?: string;
    'end_date'?: string;
    'cadence'?: string;
    'headers'?: object;
}
export interface CaApiGetIncomeStatementRetrieve200ResponseIncomeStatementInner {
    'account_id'?: number;
    'account_name'?: string;
    'account_number'?: string;
    'hierarchy'?: Array<string>;
    'YYYY-MM-DD_Group'?: number;
}
export interface CaApiV1CustomFieldsReorderCreateRequest {
    /**
     * Array of field IDs in desired order
     */
    'field_order'?: Array<number>;
}
export interface CalculatePaymentInput {
    'transactions'?: Array<TransactionPaymentInput>;
    'credit_memos'?: Array<CreditMemoPaymentInput>;
    'empty_transactions'?: Array<EmptyTransactionInput>;
}
export interface CalculatePaymentOutput {
    'total_due': number;
    'applied_payments': number;
    'applied_credits': number;
    'term_discounts': number;
    'remaining_due': number;
}
export interface ChartAccount {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'reconciliation_ending_date': string;
    'reconciliation_ending_balance': number;
    'balance_ytd': number;
    'name_and_number': string;
    'parent_name_and_number': string;
    'sort_key': string;
    'has_associated_data': boolean;
    'last_modified_at': string;
    'account_id': string;
    'number': string | null;
    'currency'?: string;
    'name'?: string | null;
    'nickname'?: string | null;
    'description'?: string | null;
    'status'?: Status372Enum;
    'account_type'?: AccountTypeEnum;
    'account_subtype'?: AccountSubtypeEnum;
    'account_cashflow_classification'?: AccountCashflowClassificationEnum;
    'include_in_eliminations'?: boolean;
    'include_in_revaluations'?: boolean;
    'protected'?: boolean;
    /**
     * Allow manual journal entries to post to this AR/AP account, bypassing subledger validation
     */
    'skip_subledger_validation'?: boolean;
    'created_at': string;
    'last_recompute_balance_at'?: string | null;
    'lock_recompute_balance_key'?: string | null;
    'customer': number;
    'parent'?: number | null;
    'parent_bank_account'?: number | null;
}


export interface ChartAccountSettings {
    'id': number;
    'uncategorized_name_and_number': string;
    'accounts_payable_name_and_number': string;
    'accounts_receivable_name_and_number': string;
    'deferred_revenue_name_and_number': string;
    'accrued_revenue_name_and_number': string;
    'unrealized_gain_loss_name_and_number': string;
    'realized_gain_loss_name_and_number': string;
    'rounding_account_name_and_number': string;
    'unapplied_credits_name_and_number': string;
    'unapplied_debits_name_and_number': string;
    'unbilled_revenue_name_and_number': string;
    'default_clearing_name_and_number': string;
    'discount_account_name_and_number': string;
    'refund_account_name_and_number': string;
    'processing_fees_name_and_number': string;
    'deferred_processing_fees_name_and_number': string;
    'tax_account_name_and_number': string;
    'payout_account_name_and_number': string;
    'cta_account_name_and_number': string;
    'fixed_asset_disposal_name_and_number': string;
    /**
     * When enabled, fixed assets placed in service after the threshold day will begin depreciation the following month (full-month depreciation only)
     */
    'enable_mid_month_convention'?: boolean;
    /**
     * Day of month threshold (0-31). Assets placed in service AFTER this day will start depreciation the following month
     */
    'mid_month_threshold'?: number;
    /**
     * When enabled, prepaid amortizations will use whole-month accounting (no proration of first/last months)
     */
    'use_whole_month_accounting_for_prepaids'?: boolean;
    /**
     * When enabled, invoice payments will be split by line items
     */
    'split_invoice_payments_by_line'?: boolean | null;
    'customer': number;
    'uncategorized'?: number | null;
    'accounts_payable'?: number | null;
    'accounts_receivable'?: number | null;
    'deferred_revenue'?: number | null;
    'accrued_revenue'?: number | null;
    'unrealized_gain_loss'?: number | null;
    'realized_gain_loss'?: number | null;
    'rounding_account'?: number | null;
    'unapplied_credits'?: number | null;
    'unapplied_debits'?: number | null;
    'unbilled_revenue'?: number | null;
    'default_clearing'?: number | null;
    'discount_account'?: number | null;
    'refund_account'?: number | null;
    'processing_fees'?: number | null;
    'deferred_processing_fees'?: number | null;
    'tax_account'?: number | null;
    'payout_account'?: number | null;
    'cta_account'?: number | null;
    'fixed_asset_disposal'?: number | null;
}
export interface ChartEntity {
    'id': number;
    'parent_name': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'last_modified_at': string;
    'name'?: string | null;
    'description'?: string | null;
    'currency'?: string;
    'invoice_name'?: string | null;
    'invoice_email'?: string | null;
    'address_1'?: string | null;
    'address_2'?: string | null;
    'city'?: string | null;
    'state'?: string | null;
    'zip_code'?: string | null;
    'country'?: string | null;
    'invoice_message'?: string | null;
    'invoice_email_body'?: string | null;
    'invoice_email_subject'?: string | null;
    'invoice_prefix'?: string | null;
    'invoice_address'?: string | null;
    /**
     * Comma-separated list of email addresses to CC when sending invoices from this entity
     */
    'invoice_cc_emails'?: string | null;
    /**
     * When enabled, the Service Date field will be hidden on invoices for this entity
     */
    'disable_service_date'?: boolean;
    /**
     * Customization for invoice PDF display (columns, labels). See InvoiceDisplaySettingsSchema for format.
     */
    'invoice_display_settings'?: any;
    /**
     * List of PDF attachments for invoice emails. Format: [{\'file_id\': 123, \'display_name\': \'Terms\', \'url\': \'https://...\', \'include_as_attachment\': true}]
     */
    'invoice_email_attachments'?: any;
    'logo_url'?: string | null;
    'active'?: boolean;
    'fiscal_year_month'?: number;
    'fiscal_year_day'?: number;
    'created_at': string | null;
    /**
     * Override customer-level mid-month convention setting for this entity. Leave blank to inherit from customer.
     */
    'enable_mid_month_convention'?: boolean | null;
    /**
     * Override customer-level threshold. Leave blank to inherit from customer.
     */
    'mid_month_threshold'?: number | null;
    /**
     * Override customer-level whole-month accounting setting for this entity. Leave blank to inherit from customer.
     */
    'use_whole_month_accounting_for_prepaids'?: boolean | null;
    /**
     * Pre-computed lineage array from root to this entity
     */
    'lineage_array'?: Array<string> | null;
    'customer': number;
    'parent'?: number | null;
}
/**
 * Minimal entity serializer for intercompany operations.  Only exposes id, name, and currency - the minimum needed for entity selection in intercompany journal entries. This prevents data leakage of sensitive entity details (addresses, emails, etc.) to users who may not have full access to all entities.
 */
export interface ChartEntityMinimal {
    'id': number;
    'name': string | null;
    'currency': string;
}
export interface ChartTransaction {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'entity_name': string;
    'entity_currency': string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'account_name': string;
    'account_number': string;
    'vendor_name': string;
    'vendor_id': string;
    'department_name': string;
    'parent_department_name': string;
    'parent_department': number;
    'tags': Array<TransactionTag>;
    'journal': number;
    'journal_order': string;
    'journal_memo': string;
    'journal_type': string;
    'intercompany_journal': number;
    'created_automatically': boolean;
    'journal_attachments': Array<any>;
    'journal_type_name': string | null;
    'invoice': string | null;
    'bill': string | null;
    'date_month': string | null;
    'date_year': string | null;
    'balance_after_transaction': number;
    'bank_account': string;
    'bank_account_name': string;
    'account'?: number | null;
    'last_modified_by_name': string;
    'account_type': string;
    'account_subtype': string;
    'parent_account_name': string;
    'files': string;
    'invoice_id': number;
    'invoice_number': string;
    'bill_id': number;
    'bill_number': string;
    'file_names': string;
    'has_matches': boolean;
    'has_ai': boolean;
    'has_rules': boolean;
    'has_merges': boolean;
    'has_fixed_asset_rule_matches': boolean;
    'suggested_account': number | null;
    'suggested_account_name': string | null;
    'suggested_account_number': string | null;
    'amount': number;
    'amount_native': number;
    'amount_book': number;
    'amortization_schedule': Array<AmortizationSchedule>;
    'created_fixed_assets': string;
    'reconciliation_report': string;
    'opposing_account_name': string;
    'opposing_account_number': string;
    'tax_rate'?: number | null;
    'apply_both_sides'?: boolean;
    'transaction_match_id'?: number | null;
    'transaction_id': string;
    'debit_amount'?: number | null;
    'credit_amount'?: number | null;
    'debit_amount_book'?: number | null;
    'credit_amount_book'?: number | null;
    'debit_amount_native'?: number | null;
    'credit_amount_native'?: number | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'posted_at'?: string | null;
    'merchant_name'?: string | null;
    'bank_description'?: string | null;
    'note'?: string | null;
    'receipt_url'?: string | null;
    'balance_before_transaction': number | null;
    'created_at': string;
    'external_id'?: string | null;
    'needs_review'?: boolean;
    'last_modified_at': string;
    'draft_matches'?: any | null;
    'last_lam_prediction_attempt'?: string | null;
    'customer': number;
    'entity': number;
    'parent_bank_transaction'?: number | null;
    'vendor'?: number | null;
    'department'?: number | null;
    'last_modified_by'?: number | null;
}
export interface CoaApiTransactionMergeCreateRequest {
    /**
     * Array of exactly two transaction IDs to merge
     */
    'transaction_ids': Array<number>;
}
export interface CoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve200Response {
    'department'?: CoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve200ResponseDepartment | null;
    'tags'?: Array<CoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve200ResponseTagsInner>;
}
export interface CoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve200ResponseDepartment {
    'id'?: number;
    'name'?: string;
}
export interface CoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve200ResponseTagsInner {
    'id'?: number;
    'name'?: string;
    'group'?: number | null;
    'group_name'?: string | null;
}
export interface ConfirmTransactionSelectionRequest {
    /**
     * List of GL transaction IDs to mark as reconciled
     */
    'selected': Array<number>;
}
export interface Contract {
    'id': number;
    'entity_name': string;
    'client_name': string;
    'client_terms': string;
    'department_name': string;
    'parent_department_name': string;
    'parent_department': number;
    'tags'?: string;
    'total_revenue': number;
    'total_mrr': number;
    'total_billed': number;
    'total_unbilled': number;
    'total_paid': number;
    'total_outstanding': number;
    'total_deferred_revenue': number;
    'currency'?: string;
    'entity_currency'?: string;
    'attachments': Array<any>;
    'contract_end_date'?: string | null;
    'last_modified_at': string;
    'is_deleted': string;
    'deleted_at': string;
    'usage_tiers'?: string;
    'has_invoices': boolean;
    'has_journal_entries': boolean;
    'has_credit_memos': boolean;
    'search_vector': string | null;
    'search_text': string | null;
    'billing_frequency'?: BillingFrequencyEnum;
    'deal_name'?: string | null;
    'deal_id'?: string | null;
    'consultant'?: string | null;
    'closed_date'?: string | null;
    'total_contract_value'?: number | null;
    'contract_start_date'?: string | null;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'crm_link'?: string | null;
    'contract_link'?: string | null;
    'status'?: ContractStatusEnum;
    'source'?: ContractSourceEnum;
    'source_deal_data'?: any | null;
    'created_at': string;
    'auto_renew'?: boolean;
    'auto_renew_duration'?: number | null;
    'auto_renew_invoice'?: boolean;
    /**
     * Minimum monthly commitment amount (allowance threshold)
     */
    'minimum_monthly_commitment_amount'?: number | null;
    /**
     * Minimum monthly commitment quantity (allowance threshold in units)
     */
    'minimum_monthly_commitment_quantity'?: number | null;
    'purchase_order_number'?: string | null;
    'customer': number;
    'entity'?: number | null;
    'client'?: number | null;
    'department'?: number | null;
    'journal_entries'?: Array<number>;
}


export interface ContractBundle {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'lines': Array<ContractBundleLine>;
    'bundle_name': string;
    'bundle_description'?: string | null;
    'start_date': string;
    'end_date': string;
    'use_daily_accounting'?: boolean;
    'use_catchup'?: boolean;
    'catchup_date'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'contract': number;
}
export interface ContractBundleLine {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'contract_bundle'?: number;
    'product_name': string;
    'amount'?: number | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'product'?: number | null;
}
export interface ContractCustomer {
    'id': number;
    'contacts'?: Array<VendorContact>;
    'parent_name': string;
    'stripe_connection_name': string | null;
    'stripe_connection_entity': number | null;
    'stripe_connection_portal_url': string | null;
    'stripe_connection_portal_enabled': boolean | null;
    'stripe_connection_invoicing_enabled': boolean | null;
    'vendor_custom_field_1_name': string;
    'payment_term_name_display': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'active_contracts': number;
    'completed_contracts': number;
    'pending_contracts': number;
    'total_contracts': number;
    'total_revenue': number;
    'total_deferred_revenue': number;
    'total_mrr': number;
    'total_billed': number;
    'total_unbilled': number;
    'total_paid': number;
    'total_outstanding': number;
    'total_credit_memos': number;
    'credit_memo_applied': number;
    'credit_memo_available': number;
    'currency': string;
    'search_vector': string | null;
    'search_text': string | null;
    'vendor_type'?: VendorType391Enum | null;
    'name': string | null;
    'dba'?: string | null;
    'company_name'?: string | null;
    'website'?: string | null;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'email'?: string | null;
    'phone_number'?: string | null;
    'mobile_number'?: string | null;
    'address_street_1'?: string | null;
    'address_street_2'?: string | null;
    'city'?: string | null;
    'state'?: string | null;
    'zip_code'?: string | null;
    'country'?: string | null;
    'billing_address_street_1'?: string | null;
    'billing_address_street_2'?: string | null;
    'billing_city'?: string | null;
    'billing_state'?: string | null;
    'billing_zip_code'?: string | null;
    'billing_country'?: string | null;
    'shipping_addressee'?: string | null;
    'billing_addressee'?: string | null;
    'notes'?: string | null;
    'business_id_ssn'?: string | null;
    'is_1099'?: boolean;
    'vat_number'?: string | null;
    /**
     * Avalara entity/use code for tax exemptions (e.g., A - Federal Government, B - State/Local Govt)
     */
    'entity_use_code'?: string | null;
    'stripe_customer_id'?: string | null;
    'use_stripe_auto_bill'?: boolean | null;
    'bill_vendor_id'?: string | null;
    'external_id'?: string | null;
    'source'?: Source170Enum | null;
    'invoice_message'?: string | null;
    'abbreviation'?: string | null;
    'created_at': string;
    'status'?: Status372Enum;
    'anrok_customer_id'?: string | null;
    'terms'?: TermsEnum | null;
    /**
     * Pre-computed lineage array from root to this vendor
     */
    'lineage_array'?: Array<string> | null;
    'customer': number;
    'parent'?: number | null;
    'stripe_connection': number | null;
    'default_expense_category'?: number | null;
    'vendor_custom_field_1'?: number | null;
    /**
     * Payment term for this vendor
     */
    'payment_term'?: number | null;
}


export interface ContractDuplicateResponse {
    /**
     * The new contract\'s ID
     */
    'id': number;
}
export interface ContractMilestone {
    'id': number;
    'customer': number;
    'contract': number;
    'product'?: number | null;
    'product_bundle': string;
    'contract_product_bundle': ContractProductBundleRead;
    'product_name': string;
    'product_bundle_name': string;
    'milestone_name': string;
    'milestone_date': string;
    'amount': number;
    'description'?: string | null;
    'department'?: number | null;
    'department_name': string;
    'tags': Array<TransactionTag>;
    'revenue_transaction_id': number;
    'created_at': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
}
/**
 * Serializer for ContractProductBundle with nested lines.  Used for retrieving and updating contract-specific bundle allocations. When updating, validates that line amounts sum to total_amount.
 */
export interface ContractProductBundle {
    'id': number;
    /**
     * Original ProductBundle template this was created from
     */
    'source_bundle': number | null;
    'source_bundle_name': string | null;
    /**
     * Total amount to be allocated across products
     */
    'total_amount': number;
    'currency': string;
    'lines': Array<ContractProductBundleLine>;
    'created_at': string;
    'last_modified_at': string;
}
/**
 * Serializer for individual product allocation lines within a ContractProductBundle.
 */
export interface ContractProductBundleLine {
    'id': number;
    'product': number;
    'product_name': string;
    'product_id_str': string;
    /**
     * Dollar amount allocated to this product
     */
    'amount': number;
    /**
     * Calculated percentage based on amount / total
     */
    'percentage': string;
    /**
     * Original percentage from source ProductBundle for auditing
     */
    'original_percentage': number | null;
}
/**
 * Read-only serializer for ContractProductBundleLine in milestone responses.
 */
export interface ContractProductBundleLineRead {
    'id': number;
    'product': number;
    'product_name': string;
    /**
     * Dollar amount allocated to this product
     */
    'amount': number;
    'percentage': string;
    /**
     * Original percentage from source ProductBundle for auditing
     */
    'original_percentage'?: number | null;
}
/**
 * Serializer for updating individual line amounts.
 */
export interface ContractProductBundleLineUpdate {
    /**
     * Product ID
     */
    'product': number;
    /**
     * New dollar amount for this product allocation
     */
    'amount': number;
}
/**
 * Read-only serializer for ContractProductBundle in milestone responses.
 */
export interface ContractProductBundleRead {
    'id': number;
    /**
     * Original ProductBundle template this was created from
     */
    'source_bundle'?: number | null;
    'source_bundle_name': string | null;
    /**
     * Total amount to be allocated across products
     */
    'total_amount': number;
    'currency'?: string;
    'lines': Array<ContractProductBundleLineRead>;
}
/**
 * Serializer for the allocation update request body.
 */
export interface ContractProductBundleUpdate {
    'lines': Array<ContractProductBundleLineUpdate>;
}
/**
 * * `SALESFORCE` - Salesforce * `HUBSPOT` - Hubspot * `STRIPE` - Stripe * `MANUAL` - Manual
 */

export const ContractSourceEnum = {
    Salesforce: 'SALESFORCE',
    Hubspot: 'HUBSPOT',
    Stripe: 'STRIPE',
    Manual: 'MANUAL'
} as const;

export type ContractSourceEnum = typeof ContractSourceEnum[keyof typeof ContractSourceEnum];


/**
 * * `ACTIVE` - Active * `PENDING` - Pending * `COMPLETED` - Completed * `DELETED` - Deleted
 */

export const ContractStatusEnum = {
    Active: 'ACTIVE',
    Pending: 'PENDING',
    Completed: 'COMPLETED',
    Deleted: 'DELETED'
} as const;

export type ContractStatusEnum = typeof ContractStatusEnum[keyof typeof ContractStatusEnum];


export interface ContractSubscription {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'lines': string;
    'product_name': string;
    'product_bundle': string;
    'product_bundle_name': string;
    'contract_product_bundle': ContractProductBundleRead;
    'total_value': number;
    'last_modified_at': string;
    'rate'?: number | null;
    'quantity'?: number | null;
    'is_contract_amendment'?: boolean;
    'start_date'?: string | null;
    'end_date'?: string | null;
    'mrr'?: number | null;
    'notes'?: string | null;
    'use_daily_accounting'?: boolean;
    'use_catchup'?: boolean;
    'catchup_date'?: string | null;
    /**
     * Fixed Rate: rate stays constant, quantity calculated. Fixed Quantity: quantity stays constant (e.g., seats), rate calculated.  * `FIXED_RATE` - Fixed Rate * `FIXED_QUANTITY` - Fixed Quantity
     */
    'invoice_calculation'?: InvoiceCalculationEnum;
    'created_at': string;
    'customer': number;
    'contract': number;
    'product'?: number | null;
    'modified_subscription'?: number | null;
}


export interface ContractUsage {
    'id': number;
    'contract': number;
    'product'?: number | null;
    'product_bundle': string;
    'contract_product_bundle': ContractProductBundleRead;
    'product_name': string;
    'product_bundle_name': string;
    'usage_group'?: number | null;
    'usage_group_name': string;
    'department'?: number | null;
    'tags'?: string;
    'description'?: string | null;
    'start_date'?: string | null;
    'end_date'?: string | null;
    'lines': string;
    'created_at': string | null;
    'last_modified_at': string | null;
}
export interface CostAllocation {
    'id': number;
    'lines': Array<CostAllocationLine>;
    'line_count': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'name': string;
    'number'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'account'?: number | null;
}
export interface CostAllocationLine {
    'id': number;
    'allocation'?: number;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'account_name': string;
    'department_name': string;
    'tags': Array<TransactionTag>;
    'percentage'?: number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'account': number;
    'department'?: number | null;
}
export interface CreditMemoPaymentInput {
    'credit_memo_id': number;
    'amount': number;
    /**
     * Application date
     */
    'posted_at': string;
}
export interface CustomField {
    'id': number;
    'app': string;
    'model': string;
    'name': string;
    'label': string;
    'field_type': FieldTypeEnum;
    'options'?: any;
    'is_required'?: boolean;
    'display_order'?: number;
    'is_active'?: boolean;
    'created_at': string;
    'updated_at': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
}


export interface CustomerCurrency {
    'id': number;
    'name': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'currency'?: string;
    'created_at': string;
    'customer': number;
}
export interface Department {
    'id': number;
    'parent_name': string;
    'tags': Array<TransactionTag>;
    'last_modified_at': string;
    'active'?: boolean;
    'code'?: string | null;
    'name': string | null;
    'display_name'?: string | null;
    'created_at': string;
    'customer': number;
    'parent'?: number | null;
}
export interface EmptyTransactionInput {
    'amount': number;
    /**
     * Payment date for term discount calculation
     */
    'payment_date': string;
}
/**
 * Standard error response.
 */
export interface ErrorResponse {
    /**
     * Error message describing what went wrong
     */
    'error': string;
}
/**
 * * `text` - Free Text * `single_select` - Single Select * `date` - Date * `number` - Number * `boolean` - Boolean
 */

export const FieldTypeEnum = {
    Text: 'text',
    SingleSelect: 'single_select',
    Date: 'date',
    Number: 'number',
    Boolean: 'boolean'
} as const;

export type FieldTypeEnum = typeof FieldTypeEnum[keyof typeof FieldTypeEnum];


export interface FixedAsset {
    'id': number;
    'entity_name': string;
    'entity_currency': string;
    'useful_life': number;
    'asset_class_name': string;
    'asset_account': string;
    'asset_account_name': string;
    'depreciation_expense_account': string;
    'depreciation_expense_account_name': string;
    'accumulated_depreciation_account': string;
    'accumulated_depreciation_account_name': string;
    'purchase_journal_entry_order': string;
    'purchase_transaction_id': string;
    'vendor_name': string;
    'department_name': string;
    'tags': Array<TransactionTag>;
    'attachments': Array<any>;
    'depreciations'?: Array<FixedAssetDepreciation> | null;
    'depreciation_end_date': string;
    'disposals': Array<FixedAssetDisposal> | null;
    'net_book_value': string;
    'depreciated_until'?: string | null;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'name': string;
    'description'?: string | null;
    'currency'?: string;
    'initial_value'?: number;
    'salvage_value'?: number;
    'purchase_date': string;
    'depreciation_start_date': string;
    'created_at': string;
    'status'?: FixedAssetStatusEnum;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'customer': number;
    'entity'?: number | null;
    'asset_class'?: number | null;
    'purchase_journal_entry'?: number | null;
    'purchase_transaction'?: number | null;
    'vendor'?: number | null;
    'department'?: number | null;
}


/**
 * Serializer for pending asset matches in review queue
 */
export interface FixedAssetAutomationMatch {
    'id': number;
    'rule': number;
    'rule_name': string;
    'rule_account_name': string;
    'rule_threshold': number;
    'rule_needs_review': boolean;
    'transaction': number;
    'transaction_description': string;
    'transaction_date': string;
    'transaction_amount': string;
    'proposed_name': string;
    'proposed_asset_class': number;
    'proposed_initial_value': number;
    'proposed_salvage_value'?: number;
    'proposed_purchase_date': string;
    'proposed_depreciation_start_date': string;
    'proposed_entity'?: number | null;
    'proposed_department'?: number | null;
    'proposed_vendor'?: number | null;
    /**
     * The asset created when this match was accepted
     */
    'created_asset': number | null;
    'created_at': string;
}
/**
 * Serializer for automation rules
 */
export interface FixedAssetAutomationRule {
    'id': number;
    /**
     * Descriptive name for this rule
     */
    'name': string;
    /**
     * Entity this rule applies to (determines book currency)
     */
    'entity': number;
    'entity_name': string;
    /**
     * Book currency from entity (auto-populated)
     */
    'currency': string;
    /**
     * Create assets when transactions are posted to this account
     */
    'account': number;
    'account_name': string;
    'account_number': string;
    /**
     * Minimum transaction amount in book currency (materiality threshold)
     */
    'amount_threshold': number;
    /**
     * Asset class to use for created assets
     */
    'asset_class': number;
    'asset_class_name': string;
    /**
     * If true, queue assets for review before creation
     */
    'needs_review'?: boolean;
    /**
     * Only apply to transactions created after this rule
     */
    'forward_looking'?: boolean;
    'created_at': string;
    'last_modified_at': string;
}
export interface FixedAssetClass {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'asset_account_name': string;
    'accumulated_depreciation_account_name': string;
    'depreciation_expense_account_name': string;
    'name': string;
    'useful_life': number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'asset_account'?: number | null;
    'accumulated_depreciation_account'?: number | null;
    'depreciation_expense_account'?: number | null;
}
export interface FixedAssetDepreciation {
    'id': number;
    'fixed_asset'?: number;
    'journal_entry_order': string;
    'depreciated_until'?: string | null;
    'posted'?: boolean;
    'post_date': string;
    'amount'?: number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'journal_entry'?: number | null;
}
export interface FixedAssetDisposal {
    'id': number;
    'journal_entry_order': string;
    'transaction_id'?: string;
    'disposal_date': string;
    'disposal_percentage'?: number;
    'proceeds_amount'?: number;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'fixed_asset': number;
    'journal_entry'?: number | null;
}
/**
 * * `ACTIVE` - Active * `DEPRECIATED` - Depreciated * `DISPOSED` - Disposed
 */

export const FixedAssetStatusEnum = {
    Active: 'ACTIVE',
    Depreciated: 'DEPRECIATED',
    Disposed: 'DISPOSED'
} as const;

export type FixedAssetStatusEnum = typeof FixedAssetStatusEnum[keyof typeof FixedAssetStatusEnum];


export interface GetDefaultPaymentInput {
    /**
     * Date when payment would be posted
     */
    'posted_at': string;
    /**
     * Optional transaction amount
     */
    'transaction_amount'?: number | null;
}
export interface GetDefaultPaymentOutput {
    'default_payment_amount': number;
    'payment_term_discount_note'?: string | null;
}
export interface IntercompanyJournalEntry {
    'id': number;
    'transactions': Array<ChartTransaction>;
    'attachments': Array<any>;
    'reversal_of_order': string;
    'reversals': Array<number>;
    'reversal_date'?: string;
    'entities'?: any;
    'entity_name': string;
    'entity_currency': string;
    'order'?: string;
    'journals_to_delete'?: Array<number>;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'type'?: TypeF6cEnum;
    'journal_id'?: string;
    'memo'?: string | null;
    'currency'?: string;
    'created_automatically'?: boolean;
    'date'?: string;
    'ref_number'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'reversal_of'?: number | null;
}


/**
 * * `FIXED_RATE` - Fixed Rate * `FIXED_QUANTITY` - Fixed Quantity
 */

export const InvoiceCalculationEnum = {
    FixedRate: 'FIXED_RATE',
    FixedQuantity: 'FIXED_QUANTITY'
} as const;

export type InvoiceCalculationEnum = typeof InvoiceCalculationEnum[keyof typeof InvoiceCalculationEnum];


export interface JournalEntry {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'transactions': Array<ChartTransaction>;
    'attachments': Array<any>;
    'invoice': number;
    'reversal_of_order': string;
    'reversals': Array<number>;
    'reversal_date'?: string;
    'entity_name': string;
    'entity_currency': string;
    'order'?: string;
    'revenue_transactions'?: Array<number>;
    'bulk_upload'?: boolean;
    'chat_uuid'?: string;
    'update_reversal'?: boolean;
    'credit_memos': Array<number>;
    'debit_memos': Array<number>;
    'journals_to_delete'?: Array<number>;
    'ramp_use_sandbox': string;
    'search_vector': string | null;
    'search_text': string | null;
    'type'?: TypeF6cEnum;
    'journal_id'?: string;
    'memo'?: string | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'use_average_rate'?: boolean | null;
    'created_automatically'?: boolean;
    'date'?: string;
    'ref_number'?: string | null;
    'created_at': string;
    'source'?: string | null;
    'source_id'?: string | null;
    'last_modified_at': string;
    'customer': number;
    'recurrent_journal_entry'?: number | null;
    'entity'?: number | null;
    'reversal_of'?: number | null;
    'intercompany_journal'?: number | null;
    'source_file'?: number | null;
    'chat'?: number | null;
}


export interface JournalEntryPostResponse {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'transactions': Array<ChartTransaction>;
    'reversal_of_order': string;
    'reversals': Array<number>;
    'reversal_date'?: string;
    'order'?: string;
    'revenue_transactions'?: Array<number>;
    'bulk_upload'?: boolean;
    'chat_uuid'?: string;
    'update_reversal'?: boolean;
    'journals_to_delete'?: Array<number>;
    'ramp_use_sandbox': string;
    'search_vector': string | null;
    'search_text': string | null;
    'type'?: TypeF6cEnum;
    'journal_id'?: string;
    'memo'?: string | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'use_average_rate'?: boolean | null;
    'created_automatically'?: boolean;
    'date'?: string;
    'ref_number'?: string | null;
    'created_at': string;
    'source'?: string | null;
    'source_id'?: string | null;
    'last_modified_at': string;
    'customer': number;
    'recurrent_journal_entry'?: number | null;
    'entity'?: number | null;
    'reversal_of'?: number | null;
    'intercompany_journal'?: number | null;
    'source_file'?: number | null;
    'chat'?: number | null;
}


/**
 * Serializer for marking a credit memo as used with a transaction.
 */
export interface MarkCreditMemoUsed {
    'transaction_id': number;
    'account_id': number;
    'amount': number;
    'payment_date': string;
    'memo'?: string | null;
}
/**
 * Serializer for marking a debit memo as used with a transaction.
 */
export interface MarkDebitMemoUsed {
    'transaction_id': number;
    'account_id': number;
    'amount': number;
    'payment_date': string;
    'memo'?: string | null;
}
export interface MarkPaid {
    'transaction_match_id'?: number | null;
    'transactions'?: Array<MarkPaidTransaction> | null;
    'credit_memos'?: Array<MarkPaidCreditMemo> | null;
    'debit_memos'?: Array<MarkPaidDebitMemo> | null;
    'empty_transactions'?: Array<MarkPaidEmptyTransaction> | null;
}
export interface MarkPaidCreditMemo {
    'credit_memo_id': number;
    'amount': number;
    'posted_at': string;
}
export interface MarkPaidDebitMemo {
    'debit_memo_id': number;
    'amount': number;
    'posted_at': string;
}
export interface MarkPaidEmptyTransaction {
    'account_id': number;
    'account_name': string;
    'amount': number;
    'payment_date': string;
    'department_id'?: number | null;
    'tag_ids'?: Array<number>;
    'memo'?: string | null;
    'currency'?: string | null;
    'amount_in_invoice_currency'?: number | null;
    'amount_in_bill_currency'?: number | null;
}
export interface MarkPaidTransaction {
    'transaction_match_id'?: number | null;
    'transaction_id'?: number | null;
    'transaction_ids'?: Array<number> | null;
    'account_id'?: number | null;
    'amount': number;
    'amount_payable'?: number | null;
}
export interface ModelFile {
    'id': number;
    'customer': number;
    'created_at': string;
    'created_by': number | null;
    'created_by_name': string;
    'created_by_email': string;
    'last_modified_at': string;
    'name': string;
    'url': string;
    's3_content_type'?: string | null;
    's3_content_length'?: number | null;
    's3_path': string;
    'object_id'?: number | null;
    'app': string;
    'model': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
}
export interface PaginatedAccountingCreditMemoList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<AccountingCreditMemo>;
}
export interface PaginatedAccountingDebitMemoList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<AccountingDebitMemo>;
}
export interface PaginatedAccountingInvoiceListList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<AccountingInvoiceList>;
}
export interface PaginatedBankAccountList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<BankAccount>;
}
export interface PaginatedBankTransactionList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<BankTransaction>;
}
export interface PaginatedBudgetList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Budget>;
}
export interface PaginatedChartAccountList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<ChartAccount>;
}
export interface PaginatedContractCustomerList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<ContractCustomer>;
}
export interface PaginatedContractList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Contract>;
}
export interface PaginatedContractMilestoneList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<ContractMilestone>;
}
export interface PaginatedContractUsageList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<ContractUsage>;
}
export interface PaginatedCostAllocationList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<CostAllocation>;
}
export interface PaginatedCustomFieldList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<CustomField>;
}
export interface PaginatedCustomerCurrencyList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<CustomerCurrency>;
}
export interface PaginatedDepartmentList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Department>;
}
export interface PaginatedFileList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<any>;
}
export interface PaginatedFixedAssetAutomationMatchList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<FixedAssetAutomationMatch>;
}
export interface PaginatedFixedAssetAutomationRuleList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<FixedAssetAutomationRule>;
}
export interface PaginatedFixedAssetClassList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<FixedAssetClass>;
}
export interface PaginatedFixedAssetList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<FixedAsset>;
}
export interface PaginatedIntercompanyJournalEntryList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<IntercompanyJournalEntry>;
}
export interface PaginatedJournalEntryList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<JournalEntry>;
}
export interface PaginatedProductBundleList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<ProductBundle>;
}
export interface PaginatedProductList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Product>;
}
export interface PaginatedReconciliationReportV2List {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<ReconciliationReportV2>;
}
export interface PaginatedReconciliationReportV2SourceTransactionList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<ReconciliationReportV2SourceTransaction>;
}
export interface PaginatedRevenueTransactionList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<RevenueTransaction>;
}
export interface PaginatedTransactionMatchList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<TransactionMatch>;
}
export interface PaginatedTransactionTagGroupList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<TransactionTagGroup>;
}
export interface PaginatedTransactionTagList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<TransactionTag>;
}
export interface PaginatedVendorContactList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<VendorContact>;
}
export interface PaginatedVendorList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<Vendor>;
}
export interface PaginatedVendorSummaryList {
    'count': number;
    'next'?: string | null;
    'previous'?: string | null;
    'results': Array<VendorSummary>;
}
export interface PatchedAccountingBill {
    'id'?: number;
    'lines'?: Array<AccountingBillLine>;
    'payments'?: Array<AccountingBillPayment>;
    'payment_journal_entries'?: Array<number>;
    'status'?: string;
    'past_due_days'?: number | null;
    'entity_name'?: string;
    'entity_currency'?: string;
    'vendor_name'?: string;
    /**
     * Return AP account name with number in \'number - name\' format, similar to name_and_number.
     */
    'ap_account_name'?: string | null;
    'attachments'?: Array<any>;
    'total_amount'?: number;
    'amount_due'?: number;
    'amount_paid'?: number;
    'item_date'?: string | null;
    'migrated_journal_id'?: number | null;
    'voided_date'?: string;
    'voided_journal_entry_order'?: string;
    'amortizations'?: string;
    'last_modified_at'?: string;
    'ramp_use_sandbox'?: string;
    'zip_metadata'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'payment_term_name'?: string;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'mailing_address'?: string | null;
    'terms'?: TermsEnum | null;
    'bill_number'?: string;
    'bill_date'?: string;
    'due_date'?: string;
    'paid_date'?: string | null;
    'message_on_bill'?: string | null;
    'source_id'?: string | null;
    'source'?: string | null;
    'external_ramp_id'?: string | null;
    'payment_status'?: AccountingBillPaymentStatusEnum | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'created_at'?: string;
    'tax_behavior'?: TaxBehaviorEnum | null;
    'bill_type'?: BillTypeEnum;
    'customer'?: number;
    'entity'?: number;
    'vendor'?: number | null;
    /**
     * Payment term for this bill
     */
    'payment_term'?: number | null;
    'journal_entry'?: number | null;
    'source_file'?: number | null;
    'tax_rate'?: number | null;
    /**
     * Accounts Payable account for this bill
     */
    'ap_account'?: number | null;
    'voided_journal_entry'?: number | null;
}


export interface PatchedAccountingCreditMemo {
    'id'?: number;
    'lines'?: Array<AccountingCreditMemoLine>;
    'payments'?: Array<AccountingCreditMemoPayment>;
    /**
     * Calculate amount remaining from database fields
     */
    'amount_remaining'?: number;
    'entity_name'?: string;
    'entity_currency'?: string;
    'client_name'?: string;
    'client_email'?: string;
    'contract_name'?: string;
    'credit_account_number'?: string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'credit_account_name'?: string;
    'attachments'?: Array<any>;
    'credit_memo_number'?: string;
    'migrated_journal_id'?: number | null;
    'voided_date'?: string;
    'voided_journal_entry_order'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'ref_number'?: string | null;
    'credit_memo_date'?: string;
    'applied_date'?: string | null;
    'message_on_credit_memo'?: string | null;
    'application_status'?: ApplicationStatusEnum | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'created_at'?: string;
    'last_sent_at'?: string | null;
    /**
     * ID of the negation transaction in Anrok for this credit memo
     */
    'anrok_transaction_id'?: string | null;
    /**
     * Sum of all line item amounts
     */
    'total_amount'?: number;
    /**
     * Sum of all non-voided payment amounts
     */
    'amount_used'?: number;
    'customer'?: number;
    'entity'?: number;
    'client'?: number | null;
    'credit_account'?: number | null;
    'journal_entry'?: number | null;
    'contract'?: number | null;
    'voided_journal_entry'?: number | null;
    'anrok_connection'?: number | null;
}


export interface PatchedAccountingDebitMemo {
    'id'?: number;
    'lines'?: Array<AccountingDebitMemoLine>;
    'payments'?: Array<AccountingDebitMemoPayment>;
    /**
     * Calculate amount remaining from database fields
     */
    'amount_remaining'?: number;
    'entity_name'?: string;
    'entity_currency'?: string;
    'vendor_name'?: string;
    'debit_account_number'?: string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'debit_account_name'?: string;
    'attachments'?: Array<any>;
    'debit_memo_number'?: string;
    'migrated_journal_id'?: number | null;
    'voided_date'?: string;
    'voided_journal_entry_order'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'ref_number'?: string | null;
    'debit_memo_date'?: string;
    'applied_date'?: string | null;
    'message_on_debit_memo'?: string | null;
    'source_id'?: string | null;
    'source'?: string | null;
    'application_status'?: ApplicationStatusEnum | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'created_at'?: string;
    /**
     * Sum of all line item amounts
     */
    'total_amount'?: number;
    /**
     * Sum of all non-voided payment amounts
     */
    'amount_used'?: number;
    'customer'?: number;
    'entity'?: number;
    'vendor'?: number | null;
    'debit_account'?: number | null;
    'journal_entry'?: number | null;
    'voided_journal_entry'?: number | null;
}


export interface PatchedAccountingInvoice {
    'id'?: number;
    'lines'?: Array<AccountingInvoiceLine>;
    'emails'?: Array<{ [key: string]: any; }>;
    'payments'?: Array<AccountingInvoicePayment>;
    'payment_journal_entries'?: Array<number>;
    'journal_entry_intercompany'?: string;
    'client_name'?: string;
    'client_email'?: string;
    'client_invoice_message'?: string;
    'client_use_stripe_auto_bill'?: boolean;
    'status'?: string;
    'past_due_days'?: number | null;
    'entity_name'?: string;
    'entity_currency'?: string;
    'entity_invoice_message'?: string;
    'total_amount'?: number;
    'amount_paid'?: number;
    'amount_due'?: number;
    'contract_name'?: string;
    'attachments'?: Array<any>;
    'invoice_number'?: string;
    'stripe_connection_name'?: string;
    'stripe_connection_entity'?: number;
    'stripe_connection_billing_portal_enabled'?: boolean;
    'avalara_connection_name'?: string;
    'avalara_connection_company'?: string;
    'tax_rate_name'?: string;
    'tax_rate_value'?: number;
    'payment_term_name'?: string;
    'revenue_transactions'?: Array<number>;
    'item_date'?: string | null;
    'migrated_journal_id'?: number | null;
    'voided_journal_entry_order'?: number | null;
    'department'?: number | null;
    'department_name'?: string | null;
    'tags'?: Array<number>;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'auto_send_invoice'?: boolean | null;
    'auto_send_invoice_at'?: string | null;
    'auto_sent_at'?: string | null;
    /**
     * Dictionary tracking when reminders were sent for each day overdue (e.g., {\'5\': \'2024-01-15\', \'10\': \'2024-01-20\'})
     */
    'reminder_sent_dates'?: any;
    /**
     * Dictionary tracking when pre-due reminders were sent for each day before due date (e.g., {\'3\': \'2024-01-10\', \'7\': \'2024-01-06\'})
     */
    'pre_due_reminder_sent_dates'?: any;
    'billing_address'?: string | null;
    'billing_addressee'?: string | null;
    'shipping_address'?: string | null;
    'shipping_addressee'?: string | null;
    'terms'?: TermsEnum | null;
    'ref_number'?: string | null;
    'purchase_order_number'?: string | null;
    'invoice_date'?: string;
    'due_date'?: string;
    'shipping_date'?: string | null;
    'paid_date'?: string | null;
    'uncollectible_date'?: string | null;
    'sent_date'?: string | null;
    'period_start'?: string | null;
    'period_end'?: string | null;
    'location_of_sale'?: string | null;
    'message_on_invoice'?: string | null;
    'payment_status'?: PaymentStatusF21Enum | null;
    /**
     * ID of the transaction in Anrok (set when transaction is created)
     */
    'anrok_transaction_id'?: string | null;
    'warning_message'?: string | null;
    'created_at'?: string;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'last_sent_at'?: string | null;
    'integration_id'?: string | null;
    'integration_context'?: any | null;
    'vat_number'?: string | null;
    /**
     * Discount amount for the invoice
     */
    'discount'?: number | null;
    /**
     * Discount amount applied based on payment term early payment discount
     */
    'payment_term_applied_discount'?: number | null;
    'use_stripe_auto_bill'?: boolean | null;
    'stripe_payment_link_id'?: string | null;
    'stripe_payment_intent_id'?: string | null;
    'stripe_invoice_id'?: string | null;
    'stripe_pdf_url'?: string | null;
    'stripe_payment_link'?: string | null;
    'source'?: string | null;
    'source_id'?: string | null;
    'voided_date'?: string | null;
    'customer'?: number;
    'entity'?: number;
    'client'?: number | null;
    'payment_term'?: number | null;
    'bad_debt_journal_entry'?: number | null;
    'journal_entry'?: number | null;
    'voided_journal_entry'?: number | null;
    'entity_transfer_journal_entry'?: number | null;
    'contract'?: number | null;
    'avalara_connection'?: number | null;
    'sphere_connection'?: number | null;
    'anrok_connection'?: number | null;
    'tax_rate'?: number | null;
    'stripe_connection'?: number | null;
    'source_file'?: number | null;
}


export interface PatchedBankAccount {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'entity_name'?: string;
    'department_name'?: string;
    'chart_of_accounts_account_name'?: string;
    'account_type'?: string;
    'account_subtype'?: string;
    'account_cashflow_classification'?: string;
    'type_name'?: string;
    'subtype_name'?: string;
    'cashflow_classification_name'?: string;
    'account_id'?: string;
    'currency'?: string;
    'external_account_id'?: string | null;
    'name'?: string | null;
    'nickname'?: string | null;
    'status'?: string | null;
    'type'?: BankAccountTypeEnum | null;
    'available_balance'?: number | null;
    'current_balance'?: number | null;
    'institution_id'?: string | null;
    'source'?: string | null;
    /**
     * ABA routing number (9 digits) for US bank accounts
     */
    'aba_routing_number'?: string | null;
    /**
     * SWIFT BIC code (8 or 11 characters) for international accounts
     */
    'swift_bic'?: string | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'entity'?: number;
    'chart_of_accounts_account'?: number | null;
    'department'?: number | null;
    'tags'?: Array<number>;
}


export interface PatchedBankTransaction {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'account_name'?: string;
    'date_month'?: string | null;
    'date_year'?: string | null;
    'journal'?: number | null;
    'journal_order'?: string | null;
    'intercompany_journal'?: number | null;
    'reconciliation_report'?: number;
    'reconciliation_report_ending_date'?: string;
    'last_modified_at'?: string;
    'transaction_id'?: string;
    'external_transaction_id'?: string | null;
    'currency'?: string;
    'amount'?: number | null;
    'amount_native'?: number | null;
    'posted_at'?: string | null;
    'status'?: string | null;
    'note'?: string | null;
    'bank_description'?: string | null;
    'external_memo'?: string | null;
    'merchant_id'?: string | null;
    'merchant_name'?: string | null;
    'merchant_nickname'?: string | null;
    'kind'?: string | null;
    'excluded'?: boolean;
    'assigned'?: boolean;
    'metadata'?: any | null;
    'created_at'?: string;
    'customer'?: number;
    'account'?: number;
}
export interface PatchedBudget {
    'id'?: number;
    'entity_name'?: string;
    'prior_start_date'?: string;
    'prior_end_date'?: string;
    'department_name'?: string;
    'tags'?: Array<TransactionTag>;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'name'?: string;
    'description'?: string | null;
    'cadence'?: string | null;
    'start_date'?: string;
    'end_date'?: string | null;
    'periods'?: number;
    'breakdown_type'?: BreakdownTypeEnum;
    'currency'?: string;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'entity'?: number | null;
    'department'?: number | null;
}


export interface PatchedBudgetAccount {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'account_name'?: string;
    'account_lineage'?: string;
    'department_name'?: string;
    'period'?: number;
    'amount'?: number;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'budget'?: number;
    'account'?: number;
    'department'?: number | null;
}
export interface PatchedChartAccount {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'reconciliation_ending_date'?: string;
    'reconciliation_ending_balance'?: number;
    'balance_ytd'?: number;
    'name_and_number'?: string;
    'parent_name_and_number'?: string;
    'sort_key'?: string;
    'has_associated_data'?: boolean;
    'last_modified_at'?: string;
    'account_id'?: string;
    'number'?: string | null;
    'currency'?: string;
    'name'?: string | null;
    'nickname'?: string | null;
    'description'?: string | null;
    'status'?: Status372Enum;
    'account_type'?: AccountTypeEnum;
    'account_subtype'?: AccountSubtypeEnum;
    'account_cashflow_classification'?: AccountCashflowClassificationEnum;
    'include_in_eliminations'?: boolean;
    'include_in_revaluations'?: boolean;
    'protected'?: boolean;
    /**
     * Allow manual journal entries to post to this AR/AP account, bypassing subledger validation
     */
    'skip_subledger_validation'?: boolean;
    'created_at'?: string;
    'last_recompute_balance_at'?: string | null;
    'lock_recompute_balance_key'?: string | null;
    'customer'?: number;
    'parent'?: number | null;
    'parent_bank_account'?: number | null;
}


export interface PatchedChartAccountSettings {
    'id'?: number;
    'uncategorized_name_and_number'?: string;
    'accounts_payable_name_and_number'?: string;
    'accounts_receivable_name_and_number'?: string;
    'deferred_revenue_name_and_number'?: string;
    'accrued_revenue_name_and_number'?: string;
    'unrealized_gain_loss_name_and_number'?: string;
    'realized_gain_loss_name_and_number'?: string;
    'rounding_account_name_and_number'?: string;
    'unapplied_credits_name_and_number'?: string;
    'unapplied_debits_name_and_number'?: string;
    'unbilled_revenue_name_and_number'?: string;
    'default_clearing_name_and_number'?: string;
    'discount_account_name_and_number'?: string;
    'refund_account_name_and_number'?: string;
    'processing_fees_name_and_number'?: string;
    'deferred_processing_fees_name_and_number'?: string;
    'tax_account_name_and_number'?: string;
    'payout_account_name_and_number'?: string;
    'cta_account_name_and_number'?: string;
    'fixed_asset_disposal_name_and_number'?: string;
    /**
     * When enabled, fixed assets placed in service after the threshold day will begin depreciation the following month (full-month depreciation only)
     */
    'enable_mid_month_convention'?: boolean;
    /**
     * Day of month threshold (0-31). Assets placed in service AFTER this day will start depreciation the following month
     */
    'mid_month_threshold'?: number;
    /**
     * When enabled, prepaid amortizations will use whole-month accounting (no proration of first/last months)
     */
    'use_whole_month_accounting_for_prepaids'?: boolean;
    /**
     * When enabled, invoice payments will be split by line items
     */
    'split_invoice_payments_by_line'?: boolean | null;
    'customer'?: number;
    'uncategorized'?: number | null;
    'accounts_payable'?: number | null;
    'accounts_receivable'?: number | null;
    'deferred_revenue'?: number | null;
    'accrued_revenue'?: number | null;
    'unrealized_gain_loss'?: number | null;
    'realized_gain_loss'?: number | null;
    'rounding_account'?: number | null;
    'unapplied_credits'?: number | null;
    'unapplied_debits'?: number | null;
    'unbilled_revenue'?: number | null;
    'default_clearing'?: number | null;
    'discount_account'?: number | null;
    'refund_account'?: number | null;
    'processing_fees'?: number | null;
    'deferred_processing_fees'?: number | null;
    'tax_account'?: number | null;
    'payout_account'?: number | null;
    'cta_account'?: number | null;
    'fixed_asset_disposal'?: number | null;
}
export interface PatchedChartEntity {
    'id'?: number;
    'parent_name'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'last_modified_at'?: string;
    'name'?: string | null;
    'description'?: string | null;
    'currency'?: string;
    'invoice_name'?: string | null;
    'invoice_email'?: string | null;
    'address_1'?: string | null;
    'address_2'?: string | null;
    'city'?: string | null;
    'state'?: string | null;
    'zip_code'?: string | null;
    'country'?: string | null;
    'invoice_message'?: string | null;
    'invoice_email_body'?: string | null;
    'invoice_email_subject'?: string | null;
    'invoice_prefix'?: string | null;
    'invoice_address'?: string | null;
    /**
     * Comma-separated list of email addresses to CC when sending invoices from this entity
     */
    'invoice_cc_emails'?: string | null;
    /**
     * When enabled, the Service Date field will be hidden on invoices for this entity
     */
    'disable_service_date'?: boolean;
    /**
     * Customization for invoice PDF display (columns, labels). See InvoiceDisplaySettingsSchema for format.
     */
    'invoice_display_settings'?: any;
    /**
     * List of PDF attachments for invoice emails. Format: [{\'file_id\': 123, \'display_name\': \'Terms\', \'url\': \'https://...\', \'include_as_attachment\': true}]
     */
    'invoice_email_attachments'?: any;
    'logo_url'?: string | null;
    'active'?: boolean;
    'fiscal_year_month'?: number;
    'fiscal_year_day'?: number;
    'created_at'?: string | null;
    /**
     * Override customer-level mid-month convention setting for this entity. Leave blank to inherit from customer.
     */
    'enable_mid_month_convention'?: boolean | null;
    /**
     * Override customer-level threshold. Leave blank to inherit from customer.
     */
    'mid_month_threshold'?: number | null;
    /**
     * Override customer-level whole-month accounting setting for this entity. Leave blank to inherit from customer.
     */
    'use_whole_month_accounting_for_prepaids'?: boolean | null;
    /**
     * Pre-computed lineage array from root to this entity
     */
    'lineage_array'?: Array<string> | null;
    'customer'?: number;
    'parent'?: number | null;
}
export interface PatchedChartTransaction {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'entity_name'?: string;
    'entity_currency'?: string;
    /**
     * Combines account number and name in the format \"number - name\"
     */
    'account_name'?: string;
    'account_number'?: string;
    'vendor_name'?: string;
    'vendor_id'?: string;
    'department_name'?: string;
    'parent_department_name'?: string;
    'parent_department'?: number;
    'tags'?: Array<TransactionTag>;
    'journal'?: number;
    'journal_order'?: string;
    'journal_memo'?: string;
    'journal_type'?: string;
    'intercompany_journal'?: number;
    'created_automatically'?: boolean;
    'journal_attachments'?: Array<any>;
    'journal_type_name'?: string | null;
    'invoice'?: string | null;
    'bill'?: string | null;
    'date_month'?: string | null;
    'date_year'?: string | null;
    'balance_after_transaction'?: number;
    'bank_account'?: string;
    'bank_account_name'?: string;
    'account'?: number | null;
    'last_modified_by_name'?: string;
    'account_type'?: string;
    'account_subtype'?: string;
    'parent_account_name'?: string;
    'files'?: string;
    'invoice_id'?: number;
    'invoice_number'?: string;
    'bill_id'?: number;
    'bill_number'?: string;
    'file_names'?: string;
    'has_matches'?: boolean;
    'has_ai'?: boolean;
    'has_rules'?: boolean;
    'has_merges'?: boolean;
    'has_fixed_asset_rule_matches'?: boolean;
    'suggested_account'?: number | null;
    'suggested_account_name'?: string | null;
    'suggested_account_number'?: string | null;
    'amount'?: number;
    'amount_native'?: number;
    'amount_book'?: number;
    'amortization_schedule'?: Array<AmortizationSchedule>;
    'created_fixed_assets'?: string;
    'reconciliation_report'?: string;
    'opposing_account_name'?: string;
    'opposing_account_number'?: string;
    'tax_rate'?: number | null;
    'apply_both_sides'?: boolean;
    'transaction_match_id'?: number | null;
    'transaction_id'?: string;
    'debit_amount'?: number | null;
    'credit_amount'?: number | null;
    'debit_amount_book'?: number | null;
    'credit_amount_book'?: number | null;
    'debit_amount_native'?: number | null;
    'credit_amount_native'?: number | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'posted_at'?: string | null;
    'merchant_name'?: string | null;
    'bank_description'?: string | null;
    'note'?: string | null;
    'receipt_url'?: string | null;
    'balance_before_transaction'?: number | null;
    'created_at'?: string;
    'external_id'?: string | null;
    'needs_review'?: boolean;
    'last_modified_at'?: string;
    'draft_matches'?: any | null;
    'last_lam_prediction_attempt'?: string | null;
    'customer'?: number;
    'entity'?: number;
    'parent_bank_transaction'?: number | null;
    'vendor'?: number | null;
    'department'?: number | null;
    'last_modified_by'?: number | null;
}
export interface PatchedContract {
    'id'?: number;
    'entity_name'?: string;
    'client_name'?: string;
    'client_terms'?: string;
    'department_name'?: string;
    'parent_department_name'?: string;
    'parent_department'?: number;
    'tags'?: string;
    'total_revenue'?: number;
    'total_mrr'?: number;
    'total_billed'?: number;
    'total_unbilled'?: number;
    'total_paid'?: number;
    'total_outstanding'?: number;
    'total_deferred_revenue'?: number;
    'currency'?: string;
    'entity_currency'?: string;
    'attachments'?: Array<any>;
    'contract_end_date'?: string | null;
    'last_modified_at'?: string;
    'is_deleted'?: string;
    'deleted_at'?: string;
    'usage_tiers'?: string;
    'has_invoices'?: boolean;
    'has_journal_entries'?: boolean;
    'has_credit_memos'?: boolean;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'billing_frequency'?: BillingFrequencyEnum;
    'deal_name'?: string | null;
    'deal_id'?: string | null;
    'consultant'?: string | null;
    'closed_date'?: string | null;
    'total_contract_value'?: number | null;
    'contract_start_date'?: string | null;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'crm_link'?: string | null;
    'contract_link'?: string | null;
    'status'?: ContractStatusEnum;
    'source'?: ContractSourceEnum;
    'source_deal_data'?: any | null;
    'created_at'?: string;
    'auto_renew'?: boolean;
    'auto_renew_duration'?: number | null;
    'auto_renew_invoice'?: boolean;
    /**
     * Minimum monthly commitment amount (allowance threshold)
     */
    'minimum_monthly_commitment_amount'?: number | null;
    /**
     * Minimum monthly commitment quantity (allowance threshold in units)
     */
    'minimum_monthly_commitment_quantity'?: number | null;
    'purchase_order_number'?: string | null;
    'customer'?: number;
    'entity'?: number | null;
    'client'?: number | null;
    'department'?: number | null;
    'journal_entries'?: Array<number>;
}


export interface PatchedContractBundle {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'lines'?: Array<ContractBundleLine>;
    'bundle_name'?: string;
    'bundle_description'?: string | null;
    'start_date'?: string;
    'end_date'?: string;
    'use_daily_accounting'?: boolean;
    'use_catchup'?: boolean;
    'catchup_date'?: string | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'contract'?: number;
}
export interface PatchedContractCustomer {
    'id'?: number;
    'contacts'?: Array<VendorContact>;
    'parent_name'?: string;
    'stripe_connection_name'?: string | null;
    'stripe_connection_entity'?: number | null;
    'stripe_connection_portal_url'?: string | null;
    'stripe_connection_portal_enabled'?: boolean | null;
    'stripe_connection_invoicing_enabled'?: boolean | null;
    'vendor_custom_field_1_name'?: string;
    'payment_term_name_display'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'active_contracts'?: number;
    'completed_contracts'?: number;
    'pending_contracts'?: number;
    'total_contracts'?: number;
    'total_revenue'?: number;
    'total_deferred_revenue'?: number;
    'total_mrr'?: number;
    'total_billed'?: number;
    'total_unbilled'?: number;
    'total_paid'?: number;
    'total_outstanding'?: number;
    'total_credit_memos'?: number;
    'credit_memo_applied'?: number;
    'credit_memo_available'?: number;
    'currency'?: string;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'vendor_type'?: VendorType391Enum | null;
    'name'?: string | null;
    'dba'?: string | null;
    'company_name'?: string | null;
    'website'?: string | null;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'email'?: string | null;
    'phone_number'?: string | null;
    'mobile_number'?: string | null;
    'address_street_1'?: string | null;
    'address_street_2'?: string | null;
    'city'?: string | null;
    'state'?: string | null;
    'zip_code'?: string | null;
    'country'?: string | null;
    'billing_address_street_1'?: string | null;
    'billing_address_street_2'?: string | null;
    'billing_city'?: string | null;
    'billing_state'?: string | null;
    'billing_zip_code'?: string | null;
    'billing_country'?: string | null;
    'shipping_addressee'?: string | null;
    'billing_addressee'?: string | null;
    'notes'?: string | null;
    'business_id_ssn'?: string | null;
    'is_1099'?: boolean;
    'vat_number'?: string | null;
    /**
     * Avalara entity/use code for tax exemptions (e.g., A - Federal Government, B - State/Local Govt)
     */
    'entity_use_code'?: string | null;
    'stripe_customer_id'?: string | null;
    'use_stripe_auto_bill'?: boolean | null;
    'bill_vendor_id'?: string | null;
    'external_id'?: string | null;
    'source'?: Source170Enum | null;
    'invoice_message'?: string | null;
    'abbreviation'?: string | null;
    'created_at'?: string;
    'status'?: Status372Enum;
    'anrok_customer_id'?: string | null;
    'terms'?: TermsEnum | null;
    /**
     * Pre-computed lineage array from root to this vendor
     */
    'lineage_array'?: Array<string> | null;
    'customer'?: number;
    'parent'?: number | null;
    'stripe_connection'?: number | null;
    'default_expense_category'?: number | null;
    'vendor_custom_field_1'?: number | null;
    /**
     * Payment term for this vendor
     */
    'payment_term'?: number | null;
}


export interface PatchedContractMilestone {
    'id'?: number;
    'customer'?: number;
    'contract'?: number;
    'product'?: number | null;
    'product_bundle'?: string;
    'contract_product_bundle'?: ContractProductBundleRead;
    'product_name'?: string;
    'product_bundle_name'?: string;
    'milestone_name'?: string;
    'milestone_date'?: string;
    'amount'?: number;
    'description'?: string | null;
    'department'?: number | null;
    'department_name'?: string;
    'tags'?: Array<TransactionTag>;
    'revenue_transaction_id'?: number;
    'created_at'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
}
/**
 * Serializer for the allocation update request body.
 */
export interface PatchedContractProductBundleUpdate {
    'lines'?: Array<ContractProductBundleLineUpdate>;
}
export interface PatchedContractSubscription {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'lines'?: string;
    'product_name'?: string;
    'product_bundle'?: string;
    'product_bundle_name'?: string;
    'contract_product_bundle'?: ContractProductBundleRead;
    'total_value'?: number;
    'last_modified_at'?: string;
    'rate'?: number | null;
    'quantity'?: number | null;
    'is_contract_amendment'?: boolean;
    'start_date'?: string | null;
    'end_date'?: string | null;
    'mrr'?: number | null;
    'notes'?: string | null;
    'use_daily_accounting'?: boolean;
    'use_catchup'?: boolean;
    'catchup_date'?: string | null;
    /**
     * Fixed Rate: rate stays constant, quantity calculated. Fixed Quantity: quantity stays constant (e.g., seats), rate calculated.  * `FIXED_RATE` - Fixed Rate * `FIXED_QUANTITY` - Fixed Quantity
     */
    'invoice_calculation'?: InvoiceCalculationEnum;
    'created_at'?: string;
    'customer'?: number;
    'contract'?: number;
    'product'?: number | null;
    'modified_subscription'?: number | null;
}


export interface PatchedContractUsage {
    'id'?: number;
    'contract'?: number;
    'product'?: number | null;
    'product_bundle'?: string;
    'contract_product_bundle'?: ContractProductBundleRead;
    'product_name'?: string;
    'product_bundle_name'?: string;
    'usage_group'?: number | null;
    'usage_group_name'?: string;
    'department'?: number | null;
    'tags'?: string;
    'description'?: string | null;
    'start_date'?: string | null;
    'end_date'?: string | null;
    'lines'?: string;
    'created_at'?: string | null;
    'last_modified_at'?: string | null;
}
export interface PatchedCostAllocation {
    'id'?: number;
    'lines'?: Array<CostAllocationLine>;
    'line_count'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'name'?: string;
    'number'?: string | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'account'?: number | null;
}
export interface PatchedCustomField {
    'id'?: number;
    'app'?: string;
    'model'?: string;
    'name'?: string;
    'label'?: string;
    'field_type'?: FieldTypeEnum;
    'options'?: any;
    'is_required'?: boolean;
    'display_order'?: number;
    'is_active'?: boolean;
    'created_at'?: string;
    'updated_at'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
}


export interface PatchedCustomerCurrency {
    'id'?: number;
    'name'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'currency'?: string;
    'created_at'?: string;
    'customer'?: number;
}
export interface PatchedDepartment {
    'id'?: number;
    'parent_name'?: string;
    'tags'?: Array<TransactionTag>;
    'last_modified_at'?: string;
    'active'?: boolean;
    'code'?: string | null;
    'name'?: string | null;
    'display_name'?: string | null;
    'created_at'?: string;
    'customer'?: number;
    'parent'?: number | null;
}
export interface PatchedFile {
    'id'?: number;
    'customer'?: number;
    'created_at'?: string;
    'created_by'?: number | null;
    'created_by_name'?: string;
    'created_by_email'?: string;
    'last_modified_at'?: string;
    'name'?: string;
    'url'?: string;
    's3_content_type'?: string | null;
    's3_content_length'?: number | null;
    's3_path'?: string;
    'object_id'?: number | null;
    'app'?: string;
    'model'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
}
export interface PatchedFixedAsset {
    'id'?: number;
    'entity_name'?: string;
    'entity_currency'?: string;
    'useful_life'?: number;
    'asset_class_name'?: string;
    'asset_account'?: string;
    'asset_account_name'?: string;
    'depreciation_expense_account'?: string;
    'depreciation_expense_account_name'?: string;
    'accumulated_depreciation_account'?: string;
    'accumulated_depreciation_account_name'?: string;
    'purchase_journal_entry_order'?: string;
    'purchase_transaction_id'?: string;
    'vendor_name'?: string;
    'department_name'?: string;
    'tags'?: Array<TransactionTag>;
    'attachments'?: Array<any>;
    'depreciations'?: Array<FixedAssetDepreciation> | null;
    'depreciation_end_date'?: string;
    'disposals'?: Array<FixedAssetDisposal> | null;
    'net_book_value'?: string;
    'depreciated_until'?: string | null;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'name'?: string;
    'description'?: string | null;
    'currency'?: string;
    'initial_value'?: number;
    'salvage_value'?: number;
    'purchase_date'?: string;
    'depreciation_start_date'?: string;
    'created_at'?: string;
    'status'?: FixedAssetStatusEnum;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'customer'?: number;
    'entity'?: number | null;
    'asset_class'?: number | null;
    'purchase_journal_entry'?: number | null;
    'purchase_transaction'?: number | null;
    'vendor'?: number | null;
    'department'?: number | null;
}


/**
 * Serializer for pending asset matches in review queue
 */
export interface PatchedFixedAssetAutomationMatch {
    'id'?: number;
    'rule'?: number;
    'rule_name'?: string;
    'rule_account_name'?: string;
    'rule_threshold'?: number;
    'rule_needs_review'?: boolean;
    'transaction'?: number;
    'transaction_description'?: string;
    'transaction_date'?: string;
    'transaction_amount'?: string;
    'proposed_name'?: string;
    'proposed_asset_class'?: number;
    'proposed_initial_value'?: number;
    'proposed_salvage_value'?: number;
    'proposed_purchase_date'?: string;
    'proposed_depreciation_start_date'?: string;
    'proposed_entity'?: number | null;
    'proposed_department'?: number | null;
    'proposed_vendor'?: number | null;
    /**
     * The asset created when this match was accepted
     */
    'created_asset'?: number | null;
    'created_at'?: string;
}
/**
 * Serializer for automation rules
 */
export interface PatchedFixedAssetAutomationRule {
    'id'?: number;
    /**
     * Descriptive name for this rule
     */
    'name'?: string;
    /**
     * Entity this rule applies to (determines book currency)
     */
    'entity'?: number;
    'entity_name'?: string;
    /**
     * Book currency from entity (auto-populated)
     */
    'currency'?: string;
    /**
     * Create assets when transactions are posted to this account
     */
    'account'?: number;
    'account_name'?: string;
    'account_number'?: string;
    /**
     * Minimum transaction amount in book currency (materiality threshold)
     */
    'amount_threshold'?: number;
    /**
     * Asset class to use for created assets
     */
    'asset_class'?: number;
    'asset_class_name'?: string;
    /**
     * If true, queue assets for review before creation
     */
    'needs_review'?: boolean;
    /**
     * Only apply to transactions created after this rule
     */
    'forward_looking'?: boolean;
    'created_at'?: string;
    'last_modified_at'?: string;
}
export interface PatchedFixedAssetClass {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'asset_account_name'?: string;
    'accumulated_depreciation_account_name'?: string;
    'depreciation_expense_account_name'?: string;
    'name'?: string;
    'useful_life'?: number;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'asset_account'?: number | null;
    'accumulated_depreciation_account'?: number | null;
    'depreciation_expense_account'?: number | null;
}
export interface PatchedIntercompanyJournalEntry {
    'id'?: number;
    'transactions'?: Array<ChartTransaction>;
    'attachments'?: Array<any>;
    'reversal_of_order'?: string;
    'reversals'?: Array<number>;
    'reversal_date'?: string;
    'entities'?: any;
    'entity_name'?: string;
    'entity_currency'?: string;
    'order'?: string;
    'journals_to_delete'?: Array<number>;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'type'?: TypeF6cEnum;
    'journal_id'?: string;
    'memo'?: string | null;
    'currency'?: string;
    'created_automatically'?: boolean;
    'date'?: string;
    'ref_number'?: string | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'reversal_of'?: number | null;
}


export interface PatchedJournalEntryPostResponse {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'transactions'?: Array<ChartTransaction>;
    'reversal_of_order'?: string;
    'reversals'?: Array<number>;
    'reversal_date'?: string;
    'order'?: string;
    'revenue_transactions'?: Array<number>;
    'bulk_upload'?: boolean;
    'chat_uuid'?: string;
    'update_reversal'?: boolean;
    'journals_to_delete'?: Array<number>;
    'ramp_use_sandbox'?: string;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'type'?: TypeF6cEnum;
    'journal_id'?: string;
    'memo'?: string | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'use_average_rate'?: boolean | null;
    'created_automatically'?: boolean;
    'date'?: string;
    'ref_number'?: string | null;
    'created_at'?: string;
    'source'?: string | null;
    'source_id'?: string | null;
    'last_modified_at'?: string;
    'customer'?: number;
    'recurrent_journal_entry'?: number | null;
    'entity'?: number | null;
    'reversal_of'?: number | null;
    'intercompany_journal'?: number | null;
    'source_file'?: number | null;
    'chat'?: number | null;
}


export interface PatchedProduct {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'department_name'?: string;
    'invoice_account_name'?: string;
    'revenue_account_name'?: string;
    'ar_account_name'?: string;
    'invoice_unbilled_account_name'?: string;
    'tax_account_name'?: string;
    'tags'?: Array<TransactionTag>;
    'last_modified_at'?: string;
    'product_id'?: string | null;
    'product_name'?: string | null;
    'product_description'?: string | null;
    'currency'?: string | null;
    'price'?: number | null;
    'cost'?: number | null;
    'exclude_from_mrr'?: boolean;
    'is_taxable'?: boolean;
    'created_at'?: string;
    'stripe_product_id'?: string | null;
    'avalara_item_id'?: number | null;
    'avalara_item_data'?: any | null;
    /**
     * Avalara tax code (e.g., SW052000 for SAAS)
     */
    'avalara_tax_code'?: string | null;
    'anrok_item_id'?: string | null;
    'sphere_item_id'?: string | null;
    /**
     * Apply Department and Tag categorization to all lines on Invoice Journals
     */
    'apply_dept_tag_to_invoice_journals'?: boolean | null;
    'customer'?: number;
    'department'?: number | null;
    'invoice_account'?: number | null;
    'revenue_account'?: number | null;
    'ar_account'?: number | null;
    'invoice_unbilled_account'?: number | null;
}
export interface PatchedProductBundle {
    'id'?: number;
    'bundle_name'?: string;
    'bundle_description'?: string | null;
    'stripe_product_id'?: string | null;
    'anrok_item_id'?: string | null;
    'lines'?: Array<ProductBundleLine>;
    'created_at'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
}
export interface PatchedReconciliationReportV2 {
    'id'?: number;
    'entity_name'?: string;
    'account_name'?: string;
    'account_number'?: string;
    'account_type'?: string;
    'account_subtype'?: string;
    'reconciled_by_name'?: string;
    'reconciled_by_email'?: string;
    'approved_by_name'?: string;
    'approved_by_email'?: string;
    'async_task'?: AsyncTask;
    'attachments'?: Array<any>;
    'csv_statements'?: string;
    'currency'?: string;
    'statement_starting_date'?: string | null;
    'statement_ending_date'?: string | null;
    'starting_balance'?: number;
    'ending_balance'?: number;
    'total_credit_amount'?: number | null;
    'total_debit_amount'?: number | null;
    'adjustments'?: number | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'reconciled_on'?: string | null;
    'approved_on'?: string | null;
    'status'?: ReconciliationReportV2StatusEnum;
    'unmatched_statement_transactions'?: any | null;
    'customer'?: number;
    'entity'?: number | null;
    'account'?: number;
    'matching_task'?: number | null;
    'reconciled_by'?: number | null;
    'approved_by'?: number | null;
}


export interface PatchedRevenueTransaction {
    'id'?: number;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'entity_name'?: string;
    'entity_currency'?: string;
    'client_name'?: string;
    'contract_name'?: string;
    'product_name'?: string;
    'product_bundle_name'?: string;
    'product_is_taxable'?: boolean;
    'contract_identifier'?: string;
    'client_identifier'?: string;
    'product_identifier'?: string;
    'gross_amount'?: string;
    'invoice_number'?: string;
    'invoice_date'?: string;
    'invoice_payment_status'?: string;
    'invoice_voided_date'?: string;
    'revenue_type'?: string;
    'journal_entry_order'?: string;
    'contract_subscription_notes'?: string;
    'department_name'?: string;
    'parent_department_name'?: string;
    'parent_department'?: number;
    'tags'?: string;
    'usage_tier_name'?: string;
    'last_modified_at'?: string;
    'anrok_item_id'?: string;
    'sphere_item_id'?: string;
    'source'?: string | null;
    'description'?: string | null;
    'external_id'?: string | null;
    'client_external_id'?: string | null;
    'contract_external_id'?: string | null;
    'contract_subscription_external_id'?: string | null;
    'product_external_id'?: string | null;
    'accounting_period'?: string | null;
    'transaction_date'?: string | null;
    'transaction_end_date'?: string | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'recognized'?: number | null;
    'amount'?: number | null;
    'quantity'?: number | null;
    'rate'?: number | null;
    'discount'?: number | null;
    'refunds'?: number | null;
    'processing_fees'?: number | null;
    'platform_fees'?: number | null;
    'transfers'?: number | null;
    'tax'?: number | null;
    /**
     * Invoice starting balance or other balance adjustments (e.g., previous balance applied to this transaction)
     */
    'balance_adjustment'?: number | null;
    'mrr'?: number | null;
    'renewall'?: boolean;
    /**
     * Marked as invoiced during migration. Does not create GL entries or AR.
     */
    'is_migration_invoiced'?: boolean;
    'created_at'?: string | null;
    'customer'?: number;
    'entity'?: number | null;
    'client'?: number | null;
    'contract'?: number | null;
    'contract_subscription'?: number | null;
    'non_contract_subscription'?: number | null;
    'contract_usage'?: number | null;
    'contract_milestone'?: number | null;
    'non_contract_usage'?: number | null;
    'product'?: number | null;
    'product_bundle'?: number | null;
    /**
     * Reference to contract-specific editable product bundle allocation
     */
    'contract_product_bundle'?: number | null;
    'contract_bundle'?: number | null;
    'journal_entry'?: number | null;
    'invoice'?: number | null;
    'department'?: number | null;
    'usage_tier'?: number | null;
}
export interface PatchedTransactionMatch {
    'id'?: number;
    'matched_object'?: string;
    'app_label'?: string;
    'model'?: string;
    'drafts'?: string;
    'object_id'?: number;
    'created_at'?: string;
    'reviewed_at'?: string | null;
    'status'?: TransactionMatchStatusEnum;
    'customer'?: number;
    'transaction'?: number;
    'content_type'?: number;
    'reviewed_by'?: number | null;
}


export interface PatchedTransactionTag {
    'id'?: number;
    'group_name'?: string;
    'parent_name'?: string | null;
    'parent'?: number | null;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'is_active'?: boolean;
    'name'?: string | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
    'group'?: number | null;
}
export interface PatchedTransactionTagGroup {
    'id'?: number;
    'slug'?: string;
    'name'?: string | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
}
export interface PatchedVendor {
    'id'?: number;
    'contacts'?: Array<VendorContact>;
    'parent_name'?: string;
    'stripe_connection_name'?: string | null;
    'stripe_connection_entity'?: number | null;
    'stripe_connection_portal_url'?: string | null;
    'stripe_connection_portal_enabled'?: boolean | null;
    'stripe_connection_invoicing_enabled'?: boolean | null;
    'vendor_custom_field_1_name'?: string;
    'payment_term_name_display'?: string;
    'last_modified_at'?: string;
    'is_deleted'?: boolean;
    'deleted_at'?: string | null;
    'search_vector'?: string | null;
    'search_text'?: string | null;
    'vendor_type'?: VendorType391Enum | null;
    'name'?: string | null;
    'dba'?: string | null;
    'company_name'?: string | null;
    'website'?: string | null;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'email'?: string | null;
    'phone_number'?: string | null;
    'mobile_number'?: string | null;
    'address_street_1'?: string | null;
    'address_street_2'?: string | null;
    'city'?: string | null;
    'state'?: string | null;
    'zip_code'?: string | null;
    'country'?: string | null;
    'billing_address_street_1'?: string | null;
    'billing_address_street_2'?: string | null;
    'billing_city'?: string | null;
    'billing_state'?: string | null;
    'billing_zip_code'?: string | null;
    'billing_country'?: string | null;
    'shipping_addressee'?: string | null;
    'billing_addressee'?: string | null;
    'notes'?: string | null;
    'business_id_ssn'?: string | null;
    'is_1099'?: boolean;
    'vat_number'?: string | null;
    /**
     * Avalara entity/use code for tax exemptions (e.g., A - Federal Government, B - State/Local Govt)
     */
    'entity_use_code'?: string | null;
    'stripe_customer_id'?: string | null;
    'use_stripe_auto_bill'?: boolean | null;
    'bill_vendor_id'?: string | null;
    'external_id'?: string | null;
    'source'?: Source170Enum | null;
    'invoice_message'?: string | null;
    'abbreviation'?: string | null;
    'created_at'?: string;
    'status'?: Status372Enum;
    'anrok_customer_id'?: string | null;
    'terms'?: TermsEnum | null;
    /**
     * Pre-computed lineage array from root to this vendor
     */
    'lineage_array'?: Array<string> | null;
    'customer'?: number;
    'parent'?: number | null;
    'stripe_connection'?: number | null;
    'default_expense_category'?: number | null;
    'vendor_custom_field_1'?: number | null;
    /**
     * Payment term for this vendor
     */
    'payment_term'?: number | null;
}


export interface PatchedVendorCustomField1 {
    'id'?: number;
    'value'?: string | null;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
}
export interface PatchedWebhook {
    'id'?: number;
    'uuid'?: string;
    'url'?: string;
    'token'?: string;
    'topics'?: Array<WebhookTopic>;
    'active'?: boolean;
    'created_at'?: string;
    'last_modified_at'?: string;
    'customer'?: number;
}
/**
 * * `open` - Open * `sent` - Sent * `partial` - Partially Paid * `paid` - Paid * `uncollectible` - Uncollectible * `voided` - Voided
 */

export const PaymentStatusF21Enum = {
    Open: 'open',
    Sent: 'sent',
    Partial: 'partial',
    Paid: 'paid',
    Uncollectible: 'uncollectible',
    Voided: 'voided'
} as const;

export type PaymentStatusF21Enum = typeof PaymentStatusF21Enum[keyof typeof PaymentStatusF21Enum];


/**
 * * `CREDIT_MEMO` - Credit Memo * `BANK_TRANSACTION` - Bank Transaction * `MANUAL_TRANSACTION` - Manual Transaction
 */

export const PaymentTypeEnum = {
    CreditMemo: 'CREDIT_MEMO',
    BankTransaction: 'BANK_TRANSACTION',
    ManualTransaction: 'MANUAL_TRANSACTION'
} as const;

export type PaymentTypeEnum = typeof PaymentTypeEnum[keyof typeof PaymentTypeEnum];


export interface Product {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'department_name': string;
    'invoice_account_name': string;
    'revenue_account_name': string;
    'ar_account_name': string;
    'invoice_unbilled_account_name': string;
    'tax_account_name': string;
    'tags': Array<TransactionTag>;
    'last_modified_at': string;
    'product_id'?: string | null;
    'product_name'?: string | null;
    'product_description'?: string | null;
    'currency'?: string | null;
    'price'?: number | null;
    'cost'?: number | null;
    'exclude_from_mrr'?: boolean;
    'is_taxable'?: boolean;
    'created_at': string;
    'stripe_product_id'?: string | null;
    'avalara_item_id'?: number | null;
    'avalara_item_data'?: any | null;
    /**
     * Avalara tax code (e.g., SW052000 for SAAS)
     */
    'avalara_tax_code'?: string | null;
    'anrok_item_id'?: string | null;
    'sphere_item_id'?: string | null;
    /**
     * Apply Department and Tag categorization to all lines on Invoice Journals
     */
    'apply_dept_tag_to_invoice_journals'?: boolean | null;
    'customer': number;
    'department'?: number | null;
    'invoice_account'?: number | null;
    'revenue_account'?: number | null;
    'ar_account'?: number | null;
    'invoice_unbilled_account'?: number | null;
}
export interface ProductBundle {
    'id': number;
    'bundle_name': string;
    'bundle_description'?: string | null;
    'stripe_product_id': string | null;
    'anrok_item_id': string | null;
    'lines': Array<ProductBundleLine>;
    'created_at': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
}
export interface ProductBundleLine {
    'id': number;
    'product': number;
    'product_name': string;
    'product_id_str': string;
    'percentage_allocation': number;
}
export interface ReconciliationReportV2 {
    'id': number;
    'entity_name': string;
    'account_name': string;
    'account_number': string;
    'account_type': string;
    'account_subtype': string;
    'reconciled_by_name': string;
    'reconciled_by_email': string;
    'approved_by_name': string;
    'approved_by_email': string;
    'async_task': AsyncTask;
    'attachments': Array<any>;
    'csv_statements': string;
    'currency'?: string;
    'statement_starting_date'?: string | null;
    'statement_ending_date'?: string | null;
    'starting_balance'?: number;
    'ending_balance'?: number;
    'total_credit_amount'?: number | null;
    'total_debit_amount'?: number | null;
    'adjustments'?: number | null;
    'created_at': string;
    'last_modified_at': string;
    'reconciled_on'?: string | null;
    'approved_on': string | null;
    'status'?: ReconciliationReportV2StatusEnum;
    'unmatched_statement_transactions'?: any | null;
    'customer': number;
    'entity'?: number | null;
    'account': number;
    'matching_task'?: number | null;
    'reconciled_by'?: number | null;
    'approved_by': number | null;
}


export interface ReconciliationReportV2SourceTransaction {
    'id': number;
    'currency': string;
    'posted_at'?: string | null;
    'debit_amount_in_currency': string;
    'credit_amount_in_currency': string;
    'bank_description'?: string | null;
    'reconciliation_transaction': Array<ReconciliationReportV2Transaction>;
    'journal_id': number;
    'journal_order': string;
}
export interface ReconciliationReportV2StatementTransaction {
    'id': number;
    'page_number': number;
    'reconciliation_transaction_id': string;
    'date': string;
    'deposit'?: number | null;
    'withdrawal'?: number | null;
    'description'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'reconciliation_report': number;
    'page': number;
}
/**
 * * `DRAFT` - Draft * `PENDING_APPROVAL` - Pending Approval * `APPROVED` - Approved * `DELETED` - Deleted
 */

export const ReconciliationReportV2StatusEnum = {
    Draft: 'DRAFT',
    PendingApproval: 'PENDING_APPROVAL',
    Approved: 'APPROVED',
    Deleted: 'DELETED'
} as const;

export type ReconciliationReportV2StatusEnum = typeof ReconciliationReportV2StatusEnum[keyof typeof ReconciliationReportV2StatusEnum];


export interface ReconciliationReportV2Transaction {
    'id': number;
    'transaction': ChartTransaction;
    'suggestion': ReconciliationReportV2StatementTransaction;
    'status'?: ReconciliationReportV2TransactionStatusEnum;
    'suggested_transaction'?: string | null;
    'suggested_transaction_data'?: any | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'reconciliation_report': number;
}


/**
 * * `DRAFT` - Draft * `RECONCILED` - Reconciled
 */

export const ReconciliationReportV2TransactionStatusEnum = {
    Draft: 'DRAFT',
    Reconciled: 'RECONCILED'
} as const;

export type ReconciliationReportV2TransactionStatusEnum = typeof ReconciliationReportV2TransactionStatusEnum[keyof typeof ReconciliationReportV2TransactionStatusEnum];


export interface RevenueTransaction {
    'id': number;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'entity_name': string;
    'entity_currency': string;
    'client_name': string;
    'contract_name': string;
    'product_name': string;
    'product_bundle_name': string;
    'product_is_taxable': boolean;
    'contract_identifier': string;
    'client_identifier': string;
    'product_identifier': string;
    'gross_amount': string;
    'invoice_number': string;
    'invoice_date': string;
    'invoice_payment_status': string;
    'invoice_voided_date': string;
    'revenue_type': string;
    'journal_entry_order': string;
    'contract_subscription_notes': string;
    'department_name': string;
    'parent_department_name': string;
    'parent_department': number;
    'tags'?: string;
    'usage_tier_name': string;
    'last_modified_at': string;
    'anrok_item_id': string;
    'sphere_item_id': string;
    'source'?: string | null;
    'description'?: string | null;
    'external_id'?: string | null;
    'client_external_id'?: string | null;
    'contract_external_id'?: string | null;
    'contract_subscription_external_id'?: string | null;
    'product_external_id'?: string | null;
    'accounting_period'?: string | null;
    'transaction_date'?: string | null;
    'transaction_end_date'?: string | null;
    'currency'?: string;
    'exchange_rate'?: number | null;
    'exchange_rate_book'?: number | null;
    'recognized'?: number | null;
    'amount'?: number | null;
    'quantity'?: number | null;
    'rate'?: number | null;
    'discount'?: number | null;
    'refunds'?: number | null;
    'processing_fees'?: number | null;
    'platform_fees'?: number | null;
    'transfers'?: number | null;
    'tax'?: number | null;
    /**
     * Invoice starting balance or other balance adjustments (e.g., previous balance applied to this transaction)
     */
    'balance_adjustment'?: number | null;
    'mrr'?: number | null;
    'renewall'?: boolean;
    /**
     * Marked as invoiced during migration. Does not create GL entries or AR.
     */
    'is_migration_invoiced'?: boolean;
    'created_at': string | null;
    'customer': number;
    'entity'?: number | null;
    'client'?: number | null;
    'contract'?: number | null;
    'contract_subscription'?: number | null;
    'non_contract_subscription'?: number | null;
    'contract_usage'?: number | null;
    'contract_milestone'?: number | null;
    'non_contract_usage'?: number | null;
    'product'?: number | null;
    'product_bundle'?: number | null;
    /**
     * Reference to contract-specific editable product bundle allocation
     */
    'contract_product_bundle'?: number | null;
    'contract_bundle'?: number | null;
    'journal_entry'?: number | null;
    'invoice'?: number | null;
    'department'?: number | null;
    'usage_tier'?: number | null;
}
/**
 * * `BILL` - Bill * `BREX` - Brex * `HUBSPOT` - Hubspot * `MANUAL` - Manual * `SALESFORCE` - Salesforce
 */

export const Source170Enum = {
    Bill: 'BILL',
    Brex: 'BREX',
    Hubspot: 'HUBSPOT',
    Manual: 'MANUAL',
    Salesforce: 'SALESFORCE'
} as const;

export type Source170Enum = typeof Source170Enum[keyof typeof Source170Enum];


/**
 * * `ACTIVE` - Active * `INACTIVE` - Inactive
 */

export const Status372Enum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type Status372Enum = typeof Status372Enum[keyof typeof Status372Enum];


/**
 * * `inclusive` - Inclusive * `exclusive` - Exclusive
 */

export const TaxBehaviorEnum = {
    Inclusive: 'inclusive',
    Exclusive: 'exclusive'
} as const;

export type TaxBehaviorEnum = typeof TaxBehaviorEnum[keyof typeof TaxBehaviorEnum];


export interface TerminateContract {
    'termination_date': string;
    /**
     * List of invoice IDs to void atomically when terminating the contract.
     */
    'void_invoice_ids'?: Array<number>;
    /**
     * Date to use when voiding invoices. Required when void_invoice_ids is provided.
     */
    'void_date'?: string;
}
/**
 * Response serializer for contract termination with hints about drafted operations.
 */
export interface TerminateContractResponse {
    /**
     * Whether the contract was terminated directly (True) or drafted (False).
     */
    'contract_terminated': boolean;
    /**
     * Draft queue ID if contract termination was drafted instead of executed.
     */
    'contract_draft_id'?: number | null;
    /**
     * List of invoice IDs that were voided directly.
     */
    'voided_invoice_ids'?: Array<number>;
    /**
     * List of invoice IDs that were drafted for voiding (user lacks void permission).
     */
    'drafted_invoice_ids'?: Array<number>;
}
/**
 * * `custom` - Custom * `net_5` - Net 5 * `net_7` - Net 7 * `net_10` - Net 10 * `net_15` - Net 15 * `net_20` - Net 20 * `net_30` - Net 30 * `net_40` - Net 40 * `net_45` - Net 45 * `net_60` - Net 60 * `net_90` - Net 90 * `net_105` - Net 105 * `net_120` - Net 120 * `due_on_receipt` - Due on Receipt
 */

export const TermsEnum = {
    Custom: 'custom',
    Net5: 'net_5',
    Net7: 'net_7',
    Net10: 'net_10',
    Net15: 'net_15',
    Net20: 'net_20',
    Net30: 'net_30',
    Net40: 'net_40',
    Net45: 'net_45',
    Net60: 'net_60',
    Net90: 'net_90',
    Net105: 'net_105',
    Net120: 'net_120',
    DueOnReceipt: 'due_on_receipt'
} as const;

export type TermsEnum = typeof TermsEnum[keyof typeof TermsEnum];


export interface TransactionMatch {
    'id': number;
    'matched_object': string;
    'app_label': string;
    'model': string;
    'drafts': string;
    'object_id': number;
    'created_at': string;
    'reviewed_at'?: string | null;
    'status'?: TransactionMatchStatusEnum;
    'customer': number;
    'transaction': number;
    'content_type': number;
    'reviewed_by'?: number | null;
}


/**
 * * `pending` - Pending * `draft` - Draft * `accepted` - Accepted * `rejected` - Rejected
 */

export const TransactionMatchStatusEnum = {
    Pending: 'pending',
    Draft: 'draft',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type TransactionMatchStatusEnum = typeof TransactionMatchStatusEnum[keyof typeof TransactionMatchStatusEnum];


export interface TransactionPaymentInput {
    'transaction_id': number;
    'amount': number;
    /**
     * Payment date for term discount calculation
     */
    'posted_at': string;
}
export interface TransactionTag {
    'id': number;
    'group_name': string;
    'parent_name': string | null;
    'parent'?: number | null;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'is_active'?: boolean;
    'name': string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
    'group'?: number | null;
}
export interface TransactionTagGroup {
    'id': number;
    'slug': string;
    'name': string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
}
export interface TrialBalanceAccount {
    'id': string;
    'name': string;
    'number': string;
    'account_type'?: string;
    'balances'?: TrialBalanceAccountBalance;
    'departments'?: { [key: string]: any; };
    'department'?: string;
    'entities'?: { [key: string]: any; };
    'parent'?: string;
}
export interface TrialBalanceAccountBalance {
    'debits': number;
    'credits': number;
}
export interface TrialBalanceData {
    'accounts': Array<TrialBalanceAccount>;
}
export interface TrialBalanceResponse {
    'trial_balance': TrialBalanceData;
    'start_date': string;
    'end_date': string;
    'breakdown'?: { [key: string]: any; };
}
/**
 * * `bill` - Bill * `bill_payment` - Bill Payment * `bill_prepayment` - Bill Prepayment * `check` - Check * `credit_card` - Credit Card * `credit_memo` - Credit Memo * `credit_memo_payment` - Credit Memo Payment * `debit_memo` - Debit Memo * `debit_memo_payment` - Debit Memo Payment * `deposit` - Deposit * `expense` - Expense * `invoice` - Invoice * `intercompany_journal` - Intercompany Journal * `invoice_payment` - Invoice Payment * `journal_entry` - Journal Entry * `lease` - Lease * `payment` - Payment * `receive_payment` - Receive Payment * `refund` - Refund * `revenue_recognition` - Revenue Recognition * `sales_receipt` - Sales Receipt * `transfer` - Transfer * `vendor_credit` - Vendor Credit * `void_bill` - Void Bill * `void_bill_payment` - Void Bill Payment * `void_invoice_payment` - Void Invoice Payment * `void_credit_memo` - Void Credit Memo * `void_invoice` - Void Invoice * `elimination` - Elimination * `revaluation` - Revaluation
 */

export const TypeF6cEnum = {
    Bill: 'bill',
    BillPayment: 'bill_payment',
    BillPrepayment: 'bill_prepayment',
    Check: 'check',
    CreditCard: 'credit_card',
    CreditMemo: 'credit_memo',
    CreditMemoPayment: 'credit_memo_payment',
    DebitMemo: 'debit_memo',
    DebitMemoPayment: 'debit_memo_payment',
    Deposit: 'deposit',
    Expense: 'expense',
    Invoice: 'invoice',
    IntercompanyJournal: 'intercompany_journal',
    InvoicePayment: 'invoice_payment',
    JournalEntry: 'journal_entry',
    Lease: 'lease',
    Payment: 'payment',
    ReceivePayment: 'receive_payment',
    Refund: 'refund',
    RevenueRecognition: 'revenue_recognition',
    SalesReceipt: 'sales_receipt',
    Transfer: 'transfer',
    VendorCredit: 'vendor_credit',
    VoidBill: 'void_bill',
    VoidBillPayment: 'void_bill_payment',
    VoidInvoicePayment: 'void_invoice_payment',
    VoidCreditMemo: 'void_credit_memo',
    VoidInvoice: 'void_invoice',
    Elimination: 'elimination',
    Revaluation: 'revaluation'
} as const;

export type TypeF6cEnum = typeof TypeF6cEnum[keyof typeof TypeF6cEnum];


export interface Vendor {
    'id': number;
    'contacts'?: Array<VendorContact>;
    'parent_name': string;
    'stripe_connection_name': string | null;
    'stripe_connection_entity': number | null;
    'stripe_connection_portal_url': string | null;
    'stripe_connection_portal_enabled': boolean | null;
    'stripe_connection_invoicing_enabled': boolean | null;
    'vendor_custom_field_1_name': string;
    'payment_term_name_display': string;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
    'search_vector': string | null;
    'search_text': string | null;
    'vendor_type'?: VendorType391Enum | null;
    'name': string | null;
    'dba'?: string | null;
    'company_name'?: string | null;
    'website'?: string | null;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'email'?: string | null;
    'phone_number'?: string | null;
    'mobile_number'?: string | null;
    'address_street_1'?: string | null;
    'address_street_2'?: string | null;
    'city'?: string | null;
    'state'?: string | null;
    'zip_code'?: string | null;
    'country'?: string | null;
    'billing_address_street_1'?: string | null;
    'billing_address_street_2'?: string | null;
    'billing_city'?: string | null;
    'billing_state'?: string | null;
    'billing_zip_code'?: string | null;
    'billing_country'?: string | null;
    'shipping_addressee'?: string | null;
    'billing_addressee'?: string | null;
    'notes'?: string | null;
    'business_id_ssn'?: string | null;
    'is_1099'?: boolean;
    'vat_number'?: string | null;
    /**
     * Avalara entity/use code for tax exemptions (e.g., A - Federal Government, B - State/Local Govt)
     */
    'entity_use_code'?: string | null;
    'stripe_customer_id'?: string | null;
    'use_stripe_auto_bill'?: boolean | null;
    'bill_vendor_id'?: string | null;
    'external_id'?: string | null;
    'source'?: Source170Enum | null;
    'invoice_message'?: string | null;
    'abbreviation'?: string | null;
    'created_at': string;
    'status'?: Status372Enum;
    'anrok_customer_id'?: string | null;
    'terms'?: TermsEnum | null;
    /**
     * Pre-computed lineage array from root to this vendor
     */
    'lineage_array'?: Array<string> | null;
    'customer': number;
    'parent'?: number | null;
    'stripe_connection'?: number | null;
    'default_expense_category'?: number | null;
    'vendor_custom_field_1'?: number | null;
    /**
     * Payment term for this vendor
     */
    'payment_term'?: number | null;
}


export interface VendorContact {
    'id': number;
    'name'?: string | null;
    'first_name'?: string | null;
    'last_name'?: string | null;
    'email'?: string | null;
    'phone_number'?: string | null;
    'mobile_number'?: string | null;
    'last_modified_at': string;
    'is_deleted': boolean;
    'deleted_at': string | null;
}
export interface VendorCustomField1 {
    'id': number;
    'value'?: string | null;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
}
export interface VendorSummary {
    'id': number;
    'name'?: string | null;
    'dba'?: string | null;
    'total_spend'?: number;
    'total_paid'?: number;
    'total_unpaid'?: number;
    'total_credits'?: number;
    'credit_used'?: number;
    'credit_available'?: number;
    'transaction_debits'?: number;
    'transaction_credits'?: number;
}
/**
 * * `vendor` - Vendor * `customer` - Customer * `employee` - Employee
 */

export const VendorType391Enum = {
    Vendor: 'vendor',
    Customer: 'customer',
    Employee: 'employee'
} as const;

export type VendorType391Enum = typeof VendorType391Enum[keyof typeof VendorType391Enum];


export interface VoidBillRequest {
    'void_date': string;
}
export interface VoidCreditMemoRequest {
    'void_date': string;
}
export interface VoidDebitMemoRequest {
    'void_date': string;
}
export interface VoidInvoiceRequest {
    'void_date'?: string;
}
export interface VoidPayment {
    'void_date'?: string | null;
}
export interface Webhook {
    'id': number;
    'uuid': string;
    'url': string;
    'token': string;
    'topics'?: Array<WebhookTopic>;
    'active': boolean;
    'created_at': string;
    'last_modified_at': string;
    'customer': number;
}
export interface WebhookEvent {
    'id': number;
    'object': any;
    'status': string;
    'created_at': string;
    'url': string;
    'topic': string;
    'http': any;
    'webhook': number | null;
}
export interface WebhookTopic {
    'id': number;
    'name': string;
}

/**
 * AccountsPayableApi - axios parameter creator
 */
export const AccountsPayableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for thousands of bills by exact bill number match in a single request. Optimized for performance.
         * @summary Bulk Search Bills by Number
         * @param {BulkBillSearch} bulkBillSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillBulkSearchCreate: async (bulkBillSearch: BulkBillSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkBillSearch' is not null or undefined
            assertParamExists('coaApiV1BillBulkSearchCreate', 'bulkBillSearch', bulkBillSearch)
            const localVarPath = `/coa/api/v1/bill/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkBillSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync multiple bills to Ramp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillBulkSyncToRampCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/bulk-sync-to-ramp/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Creates a new accounting bill with line items and automatic journal entry generation.          This endpoint allows for complex bill creation with:         - Multiple line items with different accounts, departments, and vendor assignments         - Automatic accounts payable journal entry creation         - Tax calculations and tax account handling         - Exchange rate support for multi-currency transactions         - Custom field support for additional bill metadata          Requirements:         - All referenced accounts must exist and be active         - Vendor must exist         - Entity must exist         - Line items must have valid amounts and descriptions         - Currency must be valid for the entity         - Accounting date must be before closed book date         
         * @summary Create Accounting Bill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Permanently deletes an accounting bill and its associated journal entry.          This endpoint performs a complete deletion of the bill including:         - Removal of all bill line items and associated data         - Deletion of the corresponding accounts payable journal entry         - Cleanup of any tax calculations and allocations         - Removal of vendor payment allocations if applicable          **Important Notes:**         - This operation is irreversible and permanently removes the bill from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity         - All double-entry bookkeeping records related to this bill will be removed         - Any payments allocated to this bill should be handled separately before deletion         - Deletion may affect financial reports and account balances          **Restrictions:**         - Bills with allocated payments may require payment reallocation first         - Consider the impact on historical financial reporting         - Bills cannot be deleted in a closed period         
         * @summary Delete Accounting Bill
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1BillDestroy', 'id', id)
            const localVarPath = `/coa/api/v1/bill/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the default department and tags from the bill line with the largest total amount.          This endpoint is used to provide default values when creating empty transactions (marking as paid without a transaction).         The total amount is calculated as: amount + tax.         If multiple lines have the same total amount, the line with the lowest ID (first created) is selected.         The department and tags are retrieved directly from the bill line.
         * @summary Get Default Department and Tags for Empty Transaction
         * @param {number} billId ID of the bill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve: async (billId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve', 'billId', billId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/empty-transaction-default-department-tags`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a partial update of an existing accounting bill using PATCH semantics.          This endpoint allows selective modification of bill fields without requiring         a complete bill replacement. You can update specific aspects of the bill while         leaving other fields unchanged.          **Updatable Fields:**         - Bill metadata (number, dates, descriptions, vendor, entity)         - Line items (amounts, accounts, descriptions, departments)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Currency and exchange rates         
         * @summary Partial Update Accounting Bill
         * @param {string} id 
         * @param {PatchedAccountingBill} [patchedAccountingBill] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPartialUpdate: async (id: string, patchedAccountingBill?: PatchedAccountingBill, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1BillPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/v1/bill/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccountingBill, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a bill as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply debit memos to reduce the bill balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - debit_memos: List of debit memos to apply         - empty_transactions: List of manual payments without transactions
         * @summary Mark Bill as Paid
         * @param {number} billId ID of the bill to mark as paid
         * @param {MarkPaid} [markPaid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPayCreate: async (billId: number, markPaid?: MarkPaid, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillPayCreate', 'billId', billId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/pay/`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markPaid, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void an existing bill payment.          This creates a reversing journal entry to void the payment and updates the bill status.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
         * @summary Void Bill Payment
         * @param {number} billId ID of the bill
         * @param {number} paymentId ID of the payment to void
         * @param {VoidPayment} [voidPayment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPaymentVoidCreate: async (billId: number, paymentId: number, voidPayment?: VoidPayment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillPaymentVoidCreate', 'billId', billId)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('coaApiV1BillPaymentVoidCreate', 'paymentId', paymentId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/payment/{payment_id}/void/`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)))
                .replace(`{${"payment_id"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voidPayment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a bill payment.          This removes the payment record and updates the transaction to uncategorized.
         * @summary Delete Bill Payment
         * @param {number} billId ID of the bill
         * @param {number} paymentId ID of the payment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPaymentVoidDestroy: async (billId: number, paymentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillPaymentVoidDestroy', 'billId', billId)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('coaApiV1BillPaymentVoidDestroy', 'paymentId', paymentId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/payment/{payment_id}/void/`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)))
                .replace(`{${"payment_id"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reopen a voided bill.          This removes the void date and void journal entry, and sets the bill status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Bill
         * @param {number} billId ID of the voided bill to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillReopenCreate: async (billId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillReopenCreate', 'billId', billId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/reopen/`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a paginated list of accounting bills with comprehensive filtering, search, and sorting capabilities.          This endpoint provides complete access to your bills data with:         - Advanced filtering by date ranges, payment status, vendors, entities, and currency         - Full-text search across bill numbers, vendor names, addresses, and bill messages         - Flexible sorting by any field including calculated fields (totals, amounts due, etc.)         - Comprehensive pagination with customizable page sizes         - Aging calculations and payment status categorization         - Automatic calculation of totals, amounts paid, and amounts due          **Deleted Records Support:**         - When include_deleted=true: Returns ONLY deleted bills with minimal data (id, is_deleted, deleted_at, last_modified_at)         - When include_deleted=false or omitted: Returns ONLY active bills with full data         - Timestamp filtering (last_modified_at__gte/lte) works with both active and deleted records         
         * @summary List Accounting Bills
         * @param {string} [currency] Filter by currency code (e.g., USD, EUR)
         * @param {boolean} [download] If true, triggers async download workflow and sends bills via email
         * @param {string} [endDate] Filter bills with bill_date on or before this date (YYYY-MM-DD)
         * @param {number} [entity] Filter by entity ID. Can be specified multiple times for multiple entities
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page (default: 50, max: 1000)
         * @param {number} [offset] The initial index from which to return the results
         * @param {string} [q] Search query - searches by mailing address, bill number, message on bill, or vendor name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Special fields: vendor_name, total_amount, amount_paid, amount_due, payment. Default: -bill_date
         * @param {string} [startDate] Filter bills with bill_date on or after this date (YYYY-MM-DD)
         * @param {CoaApiV1BillRetrieveStatusEnum} [status] Filter by payment status
         * @param {number} [vendor] Filter by vendor ID. Can be specified multiple times for multiple vendors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillRetrieve: async (currency?: string, download?: boolean, endDate?: string, entity?: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, startDate?: string, status?: CoaApiV1BillRetrieveStatusEnum, vendor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (vendor !== undefined) {
                localVarQueryParameter['vendor'] = vendor;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a single accounting bill by ID with complete detail including all line items, payments, and related data.          This endpoint returns comprehensive bill information including:         - Full bill details with vendor, entity, and customer information         - All line items with account details, departments, tags, and amortization schedules         - Complete payment history with journal entry references         - Calculated fields including total amounts, amounts paid, amounts due, and payment status         - Journal entry references for accounting integration         - Exchange rate information for multi-currency bills         
         * @summary Retrieve Accounting Bill
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillRetrieve2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1BillRetrieve2', 'id', id)
            const localVarPath = `/coa/api/v1/bill/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync a bill without a source to Ramp using the enabled Ramp connection
         * @summary Sync Bill to Ramp
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillSyncToRampCreate: async (billId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillSyncToRampCreate', 'billId', billId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/sync-to-ramp/`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Update an existing accounting bill with complete replacement of all data including line items and metadata.          This endpoint performs a full update (PUT) of an accounting bill with:         - Complete replacement of all bill data including vendor, entity, dates, and terms         - Full replacement of all line items with new account assignments, amounts, and descriptions         - Automatic recalculation of journal entries and accounting transactions         - Preservation of payment history while updating balances and amounts due         - Validation of all referenced accounts, vendors, entities, and departments         - Automatic exchange rate updates for multi-currency bills         - Custom field updates and attachment management         
         * @summary Update Accounting Bill
         * @param {string} id 
         * @param {AccountingBill} accountingBill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillUpdate: async (id: string, accountingBill: AccountingBill, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1BillUpdate', 'id', id)
            // verify required parameter 'accountingBill' is not null or undefined
            assertParamExists('coaApiV1BillUpdate', 'accountingBill', accountingBill)
            const localVarPath = `/coa/api/v1/bill/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountingBill, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void an existing bill.          This creates a reversing journal entry to void the bill by reversing all debit and credit amounts.         The bill status will be updated to reflect the void.
         * @summary Void Bill
         * @param {number} billId ID of the bill to void
         * @param {VoidBillRequest} voidBillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillVoidCreate: async (billId: number, voidBillRequest: VoidBillRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillVoidCreate', 'billId', billId)
            // verify required parameter 'voidBillRequest' is not null or undefined
            assertParamExists('coaApiV1BillVoidCreate', 'voidBillRequest', voidBillRequest)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/void/`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voidBillRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for thousands of debit memos by exact debit memo number match in a single request. Optimized for performance.
         * @summary Bulk Search Debit Memos by Number
         * @param {BulkDebitMemoSearch} bulkDebitMemoSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoBulkSearchCreate: async (bulkDebitMemoSearch: BulkDebitMemoSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDebitMemoSearch' is not null or undefined
            assertParamExists('coaApiV1DebitMemoBulkSearchCreate', 'bulkDebitMemoSearch', bulkDebitMemoSearch)
            const localVarPath = `/coa/api/v1/debit-memo/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDebitMemoSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Creates a new accounting debit memo with line items and automatic journal entry generation.          Debit memos are used to record amounts owed to vendors or to adjust vendor account balances.         This endpoint handles multi-currency transactions, departmental allocations, and automatic         double-entry bookkeeping.         
         * @summary Create Debit Memo
         * @param {AccountingDebitMemo} accountingDebitMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoCreate: async (accountingDebitMemo: AccountingDebitMemo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountingDebitMemo' is not null or undefined
            assertParamExists('coaApiV1DebitMemoCreate', 'accountingDebitMemo', accountingDebitMemo)
            const localVarPath = `/coa/api/v1/debit-memo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountingDebitMemo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Debit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1DebitMemoDestroy', 'id', id)
            const localVarPath = `/coa/api/v1/debit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieves a paginated list of accounting debit memos with filtering and sorting capabilities.          Supports filtering by date ranges, status, vendors, entities, and full-text search.         
         * @summary List Debit Memos
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/debit-memo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a debit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/P to clear the debit memo.         The debit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
         * @summary Mark Debit Memo as Used
         * @param {number} debitMemoId ID of the debit memo to mark as used
         * @param {MarkDebitMemoUsed} markDebitMemoUsed 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoMarkUsedCreate: async (debitMemoId: number, markDebitMemoUsed: MarkDebitMemoUsed, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'debitMemoId' is not null or undefined
            assertParamExists('coaApiV1DebitMemoMarkUsedCreate', 'debitMemoId', debitMemoId)
            // verify required parameter 'markDebitMemoUsed' is not null or undefined
            assertParamExists('coaApiV1DebitMemoMarkUsedCreate', 'markDebitMemoUsed', markDebitMemoUsed)
            const localVarPath = `/coa/api/v1/debit-memo/{debit_memo_id}/mark-used`
                .replace(`{${"debit_memo_id"}}`, encodeURIComponent(String(debitMemoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markDebitMemoUsed, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Next Debit Memo Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoNextDebitMemoNumberRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/debit-memo/next-debit-memo-number`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a partial update of an existing accounting debit memo using PATCH semantics.          This endpoint allows selective modification of debit memo fields without requiring         a complete replacement.         
         * @summary Partial Update Debit Memo
         * @param {number} id 
         * @param {PatchedAccountingDebitMemo} [patchedAccountingDebitMemo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoPartialUpdate: async (id: number, patchedAccountingDebitMemo?: PatchedAccountingDebitMemo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1DebitMemoPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/v1/debit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccountingDebitMemo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reopen a voided debit memo.          This removes the void date and void journal entry, and sets the debit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Debit Memo
         * @param {number} debitMemoId ID of the voided debit memo to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoReopenCreate: async (debitMemoId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'debitMemoId' is not null or undefined
            assertParamExists('coaApiV1DebitMemoReopenCreate', 'debitMemoId', debitMemoId)
            const localVarPath = `/coa/api/v1/debit-memo/{debit_memo_id}/reopen/`
                .replace(`{${"debit_memo_id"}}`, encodeURIComponent(String(debitMemoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieves a single accounting debit memo with complete details including line items,         payments, and accounting relationships.         
         * @summary Retrieve Debit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1DebitMemoRetrieve', 'id', id)
            const localVarPath = `/coa/api/v1/debit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a complete update of an existing accounting debit memo using PUT semantics.          This endpoint allows full replacement of debit memo data including line items         and journal entry recalculation.         
         * @summary Update Debit Memo
         * @param {number} id 
         * @param {AccountingDebitMemo} accountingDebitMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoUpdate: async (id: number, accountingDebitMemo: AccountingDebitMemo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1DebitMemoUpdate', 'id', id)
            // verify required parameter 'accountingDebitMemo' is not null or undefined
            assertParamExists('coaApiV1DebitMemoUpdate', 'accountingDebitMemo', accountingDebitMemo)
            const localVarPath = `/coa/api/v1/debit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountingDebitMemo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void an existing debit memo.          This creates a reversing journal entry to void the debit memo by reversing all debit and credit amounts.         The debit memo status will be updated to reflect the void.
         * @summary Void Debit Memo
         * @param {number} debitMemoId ID of the debit memo to void
         * @param {VoidDebitMemoRequest} voidDebitMemoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoVoidCreate: async (debitMemoId: number, voidDebitMemoRequest: VoidDebitMemoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'debitMemoId' is not null or undefined
            assertParamExists('coaApiV1DebitMemoVoidCreate', 'debitMemoId', debitMemoId)
            // verify required parameter 'voidDebitMemoRequest' is not null or undefined
            assertParamExists('coaApiV1DebitMemoVoidCreate', 'voidDebitMemoRequest', voidDebitMemoRequest)
            const localVarPath = `/coa/api/v1/debit-memo/{debit_memo_id}/void/`
                .replace(`{${"debit_memo_id"}}`, encodeURIComponent(String(debitMemoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voidDebitMemoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsPayableApi - functional programming interface
 */
export const AccountsPayableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsPayableApiAxiosParamCreator(configuration)
    return {
        /**
         * Search for thousands of bills by exact bill number match in a single request. Optimized for performance.
         * @summary Bulk Search Bills by Number
         * @param {BulkBillSearch} bulkBillSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillBulkSearchCreate(bulkBillSearch: BulkBillSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillBulkSearchCreate(bulkBillSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sync multiple bills to Ramp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillBulkSyncToRampCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillBulkSyncToRampCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillBulkSyncToRampCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Creates a new accounting bill with line items and automatic journal entry generation.          This endpoint allows for complex bill creation with:         - Multiple line items with different accounts, departments, and vendor assignments         - Automatic accounts payable journal entry creation         - Tax calculations and tax account handling         - Exchange rate support for multi-currency transactions         - Custom field support for additional bill metadata          Requirements:         - All referenced accounts must exist and be active         - Vendor must exist         - Entity must exist         - Line items must have valid amounts and descriptions         - Currency must be valid for the entity         - Accounting date must be before closed book date         
         * @summary Create Accounting Bill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Permanently deletes an accounting bill and its associated journal entry.          This endpoint performs a complete deletion of the bill including:         - Removal of all bill line items and associated data         - Deletion of the corresponding accounts payable journal entry         - Cleanup of any tax calculations and allocations         - Removal of vendor payment allocations if applicable          **Important Notes:**         - This operation is irreversible and permanently removes the bill from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity         - All double-entry bookkeeping records related to this bill will be removed         - Any payments allocated to this bill should be handled separately before deletion         - Deletion may affect financial reports and account balances          **Restrictions:**         - Bills with allocated payments may require payment reallocation first         - Consider the impact on historical financial reporting         - Bills cannot be deleted in a closed period         
         * @summary Delete Accounting Bill
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the default department and tags from the bill line with the largest total amount.          This endpoint is used to provide default values when creating empty transactions (marking as paid without a transaction).         The total amount is calculated as: amount + tax.         If multiple lines have the same total amount, the line with the lowest ID (first created) is selected.         The department and tags are retrieved directly from the bill line.
         * @summary Get Default Department and Tags for Empty Transaction
         * @param {number} billId ID of the bill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve(billId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve(billId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a partial update of an existing accounting bill using PATCH semantics.          This endpoint allows selective modification of bill fields without requiring         a complete bill replacement. You can update specific aspects of the bill while         leaving other fields unchanged.          **Updatable Fields:**         - Bill metadata (number, dates, descriptions, vendor, entity)         - Line items (amounts, accounts, descriptions, departments)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Currency and exchange rates         
         * @summary Partial Update Accounting Bill
         * @param {string} id 
         * @param {PatchedAccountingBill} [patchedAccountingBill] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillPartialUpdate(id: string, patchedAccountingBill?: PatchedAccountingBill, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillPartialUpdate(id, patchedAccountingBill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark a bill as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply debit memos to reduce the bill balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - debit_memos: List of debit memos to apply         - empty_transactions: List of manual payments without transactions
         * @summary Mark Bill as Paid
         * @param {number} billId ID of the bill to mark as paid
         * @param {MarkPaid} [markPaid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillPayCreate(billId: number, markPaid?: MarkPaid, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillPayCreate(billId, markPaid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillPayCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Void an existing bill payment.          This creates a reversing journal entry to void the payment and updates the bill status.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
         * @summary Void Bill Payment
         * @param {number} billId ID of the bill
         * @param {number} paymentId ID of the payment to void
         * @param {VoidPayment} [voidPayment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillPaymentVoidCreate(billId: number, paymentId: number, voidPayment?: VoidPayment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingBillPayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillPaymentVoidCreate(billId, paymentId, voidPayment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillPaymentVoidCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a bill payment.          This removes the payment record and updates the transaction to uncategorized.
         * @summary Delete Bill Payment
         * @param {number} billId ID of the bill
         * @param {number} paymentId ID of the payment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillPaymentVoidDestroy(billId: number, paymentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillPaymentVoidDestroy(billId, paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillPaymentVoidDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reopen a voided bill.          This removes the void date and void journal entry, and sets the bill status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Bill
         * @param {number} billId ID of the voided bill to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillReopenCreate(billId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillReopenCreate(billId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillReopenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a paginated list of accounting bills with comprehensive filtering, search, and sorting capabilities.          This endpoint provides complete access to your bills data with:         - Advanced filtering by date ranges, payment status, vendors, entities, and currency         - Full-text search across bill numbers, vendor names, addresses, and bill messages         - Flexible sorting by any field including calculated fields (totals, amounts due, etc.)         - Comprehensive pagination with customizable page sizes         - Aging calculations and payment status categorization         - Automatic calculation of totals, amounts paid, and amounts due          **Deleted Records Support:**         - When include_deleted=true: Returns ONLY deleted bills with minimal data (id, is_deleted, deleted_at, last_modified_at)         - When include_deleted=false or omitted: Returns ONLY active bills with full data         - Timestamp filtering (last_modified_at__gte/lte) works with both active and deleted records         
         * @summary List Accounting Bills
         * @param {string} [currency] Filter by currency code (e.g., USD, EUR)
         * @param {boolean} [download] If true, triggers async download workflow and sends bills via email
         * @param {string} [endDate] Filter bills with bill_date on or before this date (YYYY-MM-DD)
         * @param {number} [entity] Filter by entity ID. Can be specified multiple times for multiple entities
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page (default: 50, max: 1000)
         * @param {number} [offset] The initial index from which to return the results
         * @param {string} [q] Search query - searches by mailing address, bill number, message on bill, or vendor name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Special fields: vendor_name, total_amount, amount_paid, amount_due, payment. Default: -bill_date
         * @param {string} [startDate] Filter bills with bill_date on or after this date (YYYY-MM-DD)
         * @param {CoaApiV1BillRetrieveStatusEnum} [status] Filter by payment status
         * @param {number} [vendor] Filter by vendor ID. Can be specified multiple times for multiple vendors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillRetrieve(currency?: string, download?: boolean, endDate?: string, entity?: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, startDate?: string, status?: CoaApiV1BillRetrieveStatusEnum, vendor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillRetrieve(currency, download, endDate, entity, includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, q, sort, startDate, status, vendor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a single accounting bill by ID with complete detail including all line items, payments, and related data.          This endpoint returns comprehensive bill information including:         - Full bill details with vendor, entity, and customer information         - All line items with account details, departments, tags, and amortization schedules         - Complete payment history with journal entry references         - Calculated fields including total amounts, amounts paid, amounts due, and payment status         - Journal entry references for accounting integration         - Exchange rate information for multi-currency bills         
         * @summary Retrieve Accounting Bill
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillRetrieve2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillRetrieve2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillRetrieve2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sync a bill without a source to Ramp using the enabled Ramp connection
         * @summary Sync Bill to Ramp
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillSyncToRampCreate(billId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillSyncToRampCreate(billId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillSyncToRampCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Update an existing accounting bill with complete replacement of all data including line items and metadata.          This endpoint performs a full update (PUT) of an accounting bill with:         - Complete replacement of all bill data including vendor, entity, dates, and terms         - Full replacement of all line items with new account assignments, amounts, and descriptions         - Automatic recalculation of journal entries and accounting transactions         - Preservation of payment history while updating balances and amounts due         - Validation of all referenced accounts, vendors, entities, and departments         - Automatic exchange rate updates for multi-currency bills         - Custom field updates and attachment management         
         * @summary Update Accounting Bill
         * @param {string} id 
         * @param {AccountingBill} accountingBill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillUpdate(id: string, accountingBill: AccountingBill, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillUpdate(id, accountingBill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Void an existing bill.          This creates a reversing journal entry to void the bill by reversing all debit and credit amounts.         The bill status will be updated to reflect the void.
         * @summary Void Bill
         * @param {number} billId ID of the bill to void
         * @param {VoidBillRequest} voidBillRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillVoidCreate(billId: number, voidBillRequest: VoidBillRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingBill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillVoidCreate(billId, voidBillRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1BillVoidCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for thousands of debit memos by exact debit memo number match in a single request. Optimized for performance.
         * @summary Bulk Search Debit Memos by Number
         * @param {BulkDebitMemoSearch} bulkDebitMemoSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoBulkSearchCreate(bulkDebitMemoSearch: BulkDebitMemoSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoBulkSearchCreate(bulkDebitMemoSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Creates a new accounting debit memo with line items and automatic journal entry generation.          Debit memos are used to record amounts owed to vendors or to adjust vendor account balances.         This endpoint handles multi-currency transactions, departmental allocations, and automatic         double-entry bookkeeping.         
         * @summary Create Debit Memo
         * @param {AccountingDebitMemo} accountingDebitMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoCreate(accountingDebitMemo: AccountingDebitMemo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingDebitMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoCreate(accountingDebitMemo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Debit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieves a paginated list of accounting debit memos with filtering and sorting capabilities.          Supports filtering by date ranges, status, vendors, entities, and full-text search.         
         * @summary List Debit Memos
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccountingDebitMemoList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoList(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark a debit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/P to clear the debit memo.         The debit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
         * @summary Mark Debit Memo as Used
         * @param {number} debitMemoId ID of the debit memo to mark as used
         * @param {MarkDebitMemoUsed} markDebitMemoUsed 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoMarkUsedCreate(debitMemoId: number, markDebitMemoUsed: MarkDebitMemoUsed, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoMarkUsedCreate(debitMemoId, markDebitMemoUsed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoMarkUsedCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Next Debit Memo Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoNextDebitMemoNumberRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoNextDebitMemoNumberRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoNextDebitMemoNumberRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a partial update of an existing accounting debit memo using PATCH semantics.          This endpoint allows selective modification of debit memo fields without requiring         a complete replacement.         
         * @summary Partial Update Debit Memo
         * @param {number} id 
         * @param {PatchedAccountingDebitMemo} [patchedAccountingDebitMemo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoPartialUpdate(id: number, patchedAccountingDebitMemo?: PatchedAccountingDebitMemo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingDebitMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoPartialUpdate(id, patchedAccountingDebitMemo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reopen a voided debit memo.          This removes the void date and void journal entry, and sets the debit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Debit Memo
         * @param {number} debitMemoId ID of the voided debit memo to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoReopenCreate(debitMemoId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingDebitMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoReopenCreate(debitMemoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoReopenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieves a single accounting debit memo with complete details including line items,         payments, and accounting relationships.         
         * @summary Retrieve Debit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingDebitMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a complete update of an existing accounting debit memo using PUT semantics.          This endpoint allows full replacement of debit memo data including line items         and journal entry recalculation.         
         * @summary Update Debit Memo
         * @param {number} id 
         * @param {AccountingDebitMemo} accountingDebitMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoUpdate(id: number, accountingDebitMemo: AccountingDebitMemo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingDebitMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoUpdate(id, accountingDebitMemo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Void an existing debit memo.          This creates a reversing journal entry to void the debit memo by reversing all debit and credit amounts.         The debit memo status will be updated to reflect the void.
         * @summary Void Debit Memo
         * @param {number} debitMemoId ID of the debit memo to void
         * @param {VoidDebitMemoRequest} voidDebitMemoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1DebitMemoVoidCreate(debitMemoId: number, voidDebitMemoRequest: VoidDebitMemoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingDebitMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1DebitMemoVoidCreate(debitMemoId, voidDebitMemoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsPayableApi.coaApiV1DebitMemoVoidCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsPayableApi - factory interface
 */
export const AccountsPayableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsPayableApiFp(configuration)
    return {
        /**
         * Search for thousands of bills by exact bill number match in a single request. Optimized for performance.
         * @summary Bulk Search Bills by Number
         * @param {AccountsPayableApiCoaApiV1BillBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillBulkSearchCreate(requestParameters: AccountsPayableApiCoaApiV1BillBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.coaApiV1BillBulkSearchCreate(requestParameters.bulkBillSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync multiple bills to Ramp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillBulkSyncToRampCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillBulkSyncToRampCreate(options).then((request) => request(axios, basePath));
        },
        /**
         *          Creates a new accounting bill with line items and automatic journal entry generation.          This endpoint allows for complex bill creation with:         - Multiple line items with different accounts, departments, and vendor assignments         - Automatic accounts payable journal entry creation         - Tax calculations and tax account handling         - Exchange rate support for multi-currency transactions         - Custom field support for additional bill metadata          Requirements:         - All referenced accounts must exist and be active         - Vendor must exist         - Entity must exist         - Line items must have valid amounts and descriptions         - Currency must be valid for the entity         - Accounting date must be before closed book date         
         * @summary Create Accounting Bill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillCreate(options).then((request) => request(axios, basePath));
        },
        /**
         *          Permanently deletes an accounting bill and its associated journal entry.          This endpoint performs a complete deletion of the bill including:         - Removal of all bill line items and associated data         - Deletion of the corresponding accounts payable journal entry         - Cleanup of any tax calculations and allocations         - Removal of vendor payment allocations if applicable          **Important Notes:**         - This operation is irreversible and permanently removes the bill from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity         - All double-entry bookkeeping records related to this bill will be removed         - Any payments allocated to this bill should be handled separately before deletion         - Deletion may affect financial reports and account balances          **Restrictions:**         - Bills with allocated payments may require payment reallocation first         - Consider the impact on historical financial reporting         - Bills cannot be deleted in a closed period         
         * @summary Delete Accounting Bill
         * @param {AccountsPayableApiCoaApiV1BillDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillDestroy(requestParameters: AccountsPayableApiCoaApiV1BillDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the default department and tags from the bill line with the largest total amount.          This endpoint is used to provide default values when creating empty transactions (marking as paid without a transaction).         The total amount is calculated as: amount + tax.         If multiple lines have the same total amount, the line with the lowest ID (first created) is selected.         The department and tags are retrieved directly from the bill line.
         * @summary Get Default Department and Tags for Empty Transaction
         * @param {AccountsPayableApiCoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve(requestParameters: AccountsPayableApiCoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve200Response> {
            return localVarFp.coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve(requestParameters.billId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a partial update of an existing accounting bill using PATCH semantics.          This endpoint allows selective modification of bill fields without requiring         a complete bill replacement. You can update specific aspects of the bill while         leaving other fields unchanged.          **Updatable Fields:**         - Bill metadata (number, dates, descriptions, vendor, entity)         - Line items (amounts, accounts, descriptions, departments)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Currency and exchange rates         
         * @summary Partial Update Accounting Bill
         * @param {AccountsPayableApiCoaApiV1BillPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPartialUpdate(requestParameters: AccountsPayableApiCoaApiV1BillPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingBill> {
            return localVarFp.coaApiV1BillPartialUpdate(requestParameters.id, requestParameters.patchedAccountingBill, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a bill as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply debit memos to reduce the bill balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - debit_memos: List of debit memos to apply         - empty_transactions: List of manual payments without transactions
         * @summary Mark Bill as Paid
         * @param {AccountsPayableApiCoaApiV1BillPayCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPayCreate(requestParameters: AccountsPayableApiCoaApiV1BillPayCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingBill> {
            return localVarFp.coaApiV1BillPayCreate(requestParameters.billId, requestParameters.markPaid, options).then((request) => request(axios, basePath));
        },
        /**
         * Void an existing bill payment.          This creates a reversing journal entry to void the payment and updates the bill status.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
         * @summary Void Bill Payment
         * @param {AccountsPayableApiCoaApiV1BillPaymentVoidCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPaymentVoidCreate(requestParameters: AccountsPayableApiCoaApiV1BillPaymentVoidCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingBillPayment> {
            return localVarFp.coaApiV1BillPaymentVoidCreate(requestParameters.billId, requestParameters.paymentId, requestParameters.voidPayment, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a bill payment.          This removes the payment record and updates the transaction to uncategorized.
         * @summary Delete Bill Payment
         * @param {AccountsPayableApiCoaApiV1BillPaymentVoidDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillPaymentVoidDestroy(requestParameters: AccountsPayableApiCoaApiV1BillPaymentVoidDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillPaymentVoidDestroy(requestParameters.billId, requestParameters.paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reopen a voided bill.          This removes the void date and void journal entry, and sets the bill status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Bill
         * @param {AccountsPayableApiCoaApiV1BillReopenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillReopenCreate(requestParameters: AccountsPayableApiCoaApiV1BillReopenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingBill> {
            return localVarFp.coaApiV1BillReopenCreate(requestParameters.billId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a paginated list of accounting bills with comprehensive filtering, search, and sorting capabilities.          This endpoint provides complete access to your bills data with:         - Advanced filtering by date ranges, payment status, vendors, entities, and currency         - Full-text search across bill numbers, vendor names, addresses, and bill messages         - Flexible sorting by any field including calculated fields (totals, amounts due, etc.)         - Comprehensive pagination with customizable page sizes         - Aging calculations and payment status categorization         - Automatic calculation of totals, amounts paid, and amounts due          **Deleted Records Support:**         - When include_deleted=true: Returns ONLY deleted bills with minimal data (id, is_deleted, deleted_at, last_modified_at)         - When include_deleted=false or omitted: Returns ONLY active bills with full data         - Timestamp filtering (last_modified_at__gte/lte) works with both active and deleted records         
         * @summary List Accounting Bills
         * @param {AccountsPayableApiCoaApiV1BillRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillRetrieve(requestParameters: AccountsPayableApiCoaApiV1BillRetrieveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillRetrieve(requestParameters.currency, requestParameters.download, requestParameters.endDate, requestParameters.entity, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.startDate, requestParameters.status, requestParameters.vendor, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a single accounting bill by ID with complete detail including all line items, payments, and related data.          This endpoint returns comprehensive bill information including:         - Full bill details with vendor, entity, and customer information         - All line items with account details, departments, tags, and amortization schedules         - Complete payment history with journal entry references         - Calculated fields including total amounts, amounts paid, amounts due, and payment status         - Journal entry references for accounting integration         - Exchange rate information for multi-currency bills         
         * @summary Retrieve Accounting Bill
         * @param {AccountsPayableApiCoaApiV1BillRetrieve2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillRetrieve2(requestParameters: AccountsPayableApiCoaApiV1BillRetrieve2Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountingBill> {
            return localVarFp.coaApiV1BillRetrieve2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync a bill without a source to Ramp using the enabled Ramp connection
         * @summary Sync Bill to Ramp
         * @param {AccountsPayableApiCoaApiV1BillSyncToRampCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillSyncToRampCreate(requestParameters: AccountsPayableApiCoaApiV1BillSyncToRampCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillSyncToRampCreate(requestParameters.billId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Update an existing accounting bill with complete replacement of all data including line items and metadata.          This endpoint performs a full update (PUT) of an accounting bill with:         - Complete replacement of all bill data including vendor, entity, dates, and terms         - Full replacement of all line items with new account assignments, amounts, and descriptions         - Automatic recalculation of journal entries and accounting transactions         - Preservation of payment history while updating balances and amounts due         - Validation of all referenced accounts, vendors, entities, and departments         - Automatic exchange rate updates for multi-currency bills         - Custom field updates and attachment management         
         * @summary Update Accounting Bill
         * @param {AccountsPayableApiCoaApiV1BillUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillUpdate(requestParameters: AccountsPayableApiCoaApiV1BillUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingBill> {
            return localVarFp.coaApiV1BillUpdate(requestParameters.id, requestParameters.accountingBill, options).then((request) => request(axios, basePath));
        },
        /**
         * Void an existing bill.          This creates a reversing journal entry to void the bill by reversing all debit and credit amounts.         The bill status will be updated to reflect the void.
         * @summary Void Bill
         * @param {AccountsPayableApiCoaApiV1BillVoidCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillVoidCreate(requestParameters: AccountsPayableApiCoaApiV1BillVoidCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingBill> {
            return localVarFp.coaApiV1BillVoidCreate(requestParameters.billId, requestParameters.voidBillRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for thousands of debit memos by exact debit memo number match in a single request. Optimized for performance.
         * @summary Bulk Search Debit Memos by Number
         * @param {AccountsPayableApiCoaApiV1DebitMemoBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoBulkSearchCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.coaApiV1DebitMemoBulkSearchCreate(requestParameters.bulkDebitMemoSearch, options).then((request) => request(axios, basePath));
        },
        /**
         *          Creates a new accounting debit memo with line items and automatic journal entry generation.          Debit memos are used to record amounts owed to vendors or to adjust vendor account balances.         This endpoint handles multi-currency transactions, departmental allocations, and automatic         double-entry bookkeeping.         
         * @summary Create Debit Memo
         * @param {AccountsPayableApiCoaApiV1DebitMemoCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingDebitMemo> {
            return localVarFp.coaApiV1DebitMemoCreate(requestParameters.accountingDebitMemo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Debit Memo
         * @param {AccountsPayableApiCoaApiV1DebitMemoDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoDestroy(requestParameters: AccountsPayableApiCoaApiV1DebitMemoDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1DebitMemoDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieves a paginated list of accounting debit memos with filtering and sorting capabilities.          Supports filtering by date ranges, status, vendors, entities, and full-text search.         
         * @summary List Debit Memos
         * @param {AccountsPayableApiCoaApiV1DebitMemoListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoList(requestParameters: AccountsPayableApiCoaApiV1DebitMemoListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccountingDebitMemoList> {
            return localVarFp.coaApiV1DebitMemoList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a debit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/P to clear the debit memo.         The debit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
         * @summary Mark Debit Memo as Used
         * @param {AccountsPayableApiCoaApiV1DebitMemoMarkUsedCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoMarkUsedCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoMarkUsedCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.coaApiV1DebitMemoMarkUsedCreate(requestParameters.debitMemoId, requestParameters.markDebitMemoUsed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Next Debit Memo Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoNextDebitMemoNumberRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1DebitMemoNextDebitMemoNumberRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a partial update of an existing accounting debit memo using PATCH semantics.          This endpoint allows selective modification of debit memo fields without requiring         a complete replacement.         
         * @summary Partial Update Debit Memo
         * @param {AccountsPayableApiCoaApiV1DebitMemoPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoPartialUpdate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingDebitMemo> {
            return localVarFp.coaApiV1DebitMemoPartialUpdate(requestParameters.id, requestParameters.patchedAccountingDebitMemo, options).then((request) => request(axios, basePath));
        },
        /**
         * Reopen a voided debit memo.          This removes the void date and void journal entry, and sets the debit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Debit Memo
         * @param {AccountsPayableApiCoaApiV1DebitMemoReopenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoReopenCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoReopenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingDebitMemo> {
            return localVarFp.coaApiV1DebitMemoReopenCreate(requestParameters.debitMemoId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieves a single accounting debit memo with complete details including line items,         payments, and accounting relationships.         
         * @summary Retrieve Debit Memo
         * @param {AccountsPayableApiCoaApiV1DebitMemoRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoRetrieve(requestParameters: AccountsPayableApiCoaApiV1DebitMemoRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingDebitMemo> {
            return localVarFp.coaApiV1DebitMemoRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a complete update of an existing accounting debit memo using PUT semantics.          This endpoint allows full replacement of debit memo data including line items         and journal entry recalculation.         
         * @summary Update Debit Memo
         * @param {AccountsPayableApiCoaApiV1DebitMemoUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoUpdate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingDebitMemo> {
            return localVarFp.coaApiV1DebitMemoUpdate(requestParameters.id, requestParameters.accountingDebitMemo, options).then((request) => request(axios, basePath));
        },
        /**
         * Void an existing debit memo.          This creates a reversing journal entry to void the debit memo by reversing all debit and credit amounts.         The debit memo status will be updated to reflect the void.
         * @summary Void Debit Memo
         * @param {AccountsPayableApiCoaApiV1DebitMemoVoidCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1DebitMemoVoidCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoVoidCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingDebitMemo> {
            return localVarFp.coaApiV1DebitMemoVoidCreate(requestParameters.debitMemoId, requestParameters.voidDebitMemoRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for coaApiV1BillBulkSearchCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillBulkSearchCreateRequest {
    readonly bulkBillSearch: BulkBillSearch
}

/**
 * Request parameters for coaApiV1BillDestroy operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillDestroyRequest {
    readonly id: string
}

/**
 * Request parameters for coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieveRequest {
    /**
     * ID of the bill
     */
    readonly billId: number
}

/**
 * Request parameters for coaApiV1BillPartialUpdate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillPartialUpdateRequest {
    readonly id: string

    readonly patchedAccountingBill?: PatchedAccountingBill
}

/**
 * Request parameters for coaApiV1BillPayCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillPayCreateRequest {
    /**
     * ID of the bill to mark as paid
     */
    readonly billId: number

    readonly markPaid?: MarkPaid
}

/**
 * Request parameters for coaApiV1BillPaymentVoidCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillPaymentVoidCreateRequest {
    /**
     * ID of the bill
     */
    readonly billId: number

    /**
     * ID of the payment to void
     */
    readonly paymentId: number

    readonly voidPayment?: VoidPayment
}

/**
 * Request parameters for coaApiV1BillPaymentVoidDestroy operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillPaymentVoidDestroyRequest {
    /**
     * ID of the bill
     */
    readonly billId: number

    /**
     * ID of the payment to delete
     */
    readonly paymentId: number
}

/**
 * Request parameters for coaApiV1BillReopenCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillReopenCreateRequest {
    /**
     * ID of the voided bill to reopen
     */
    readonly billId: number
}

/**
 * Request parameters for coaApiV1BillRetrieve operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillRetrieveRequest {
    /**
     * Filter by currency code (e.g., USD, EUR)
     */
    readonly currency?: string

    /**
     * If true, triggers async download workflow and sends bills via email
     */
    readonly download?: boolean

    /**
     * Filter bills with bill_date on or before this date (YYYY-MM-DD)
     */
    readonly endDate?: string

    /**
     * Filter by entity ID. Can be specified multiple times for multiple entities
     */
    readonly entity?: number

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page (default: 50, max: 1000)
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results
     */
    readonly offset?: number

    /**
     * Search query - searches by mailing address, bill number, message on bill, or vendor name
     */
    readonly q?: string

    /**
     * Sort order. Use field name for ascending, -field for descending. Special fields: vendor_name, total_amount, amount_paid, amount_due, payment. Default: -bill_date
     */
    readonly sort?: string

    /**
     * Filter bills with bill_date on or after this date (YYYY-MM-DD)
     */
    readonly startDate?: string

    /**
     * Filter by payment status
     */
    readonly status?: CoaApiV1BillRetrieveStatusEnum

    /**
     * Filter by vendor ID. Can be specified multiple times for multiple vendors
     */
    readonly vendor?: number
}

/**
 * Request parameters for coaApiV1BillRetrieve2 operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillRetrieve2Request {
    readonly id: string
}

/**
 * Request parameters for coaApiV1BillSyncToRampCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillSyncToRampCreateRequest {
    readonly billId: number
}

/**
 * Request parameters for coaApiV1BillUpdate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillUpdateRequest {
    readonly id: string

    readonly accountingBill: AccountingBill
}

/**
 * Request parameters for coaApiV1BillVoidCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1BillVoidCreateRequest {
    /**
     * ID of the bill to void
     */
    readonly billId: number

    readonly voidBillRequest: VoidBillRequest
}

/**
 * Request parameters for coaApiV1DebitMemoBulkSearchCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoBulkSearchCreateRequest {
    readonly bulkDebitMemoSearch: BulkDebitMemoSearch
}

/**
 * Request parameters for coaApiV1DebitMemoCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoCreateRequest {
    readonly accountingDebitMemo: AccountingDebitMemo
}

/**
 * Request parameters for coaApiV1DebitMemoDestroy operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1DebitMemoList operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoListRequest {
    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiV1DebitMemoMarkUsedCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoMarkUsedCreateRequest {
    /**
     * ID of the debit memo to mark as used
     */
    readonly debitMemoId: number

    readonly markDebitMemoUsed: MarkDebitMemoUsed
}

/**
 * Request parameters for coaApiV1DebitMemoPartialUpdate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoPartialUpdateRequest {
    readonly id: number

    readonly patchedAccountingDebitMemo?: PatchedAccountingDebitMemo
}

/**
 * Request parameters for coaApiV1DebitMemoReopenCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoReopenCreateRequest {
    /**
     * ID of the voided debit memo to reopen
     */
    readonly debitMemoId: number
}

/**
 * Request parameters for coaApiV1DebitMemoRetrieve operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1DebitMemoUpdate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoUpdateRequest {
    readonly id: number

    readonly accountingDebitMemo: AccountingDebitMemo
}

/**
 * Request parameters for coaApiV1DebitMemoVoidCreate operation in AccountsPayableApi.
 */
export interface AccountsPayableApiCoaApiV1DebitMemoVoidCreateRequest {
    /**
     * ID of the debit memo to void
     */
    readonly debitMemoId: number

    readonly voidDebitMemoRequest: VoidDebitMemoRequest
}

/**
 * AccountsPayableApi - object-oriented interface
 */
export class AccountsPayableApi extends BaseAPI {
    /**
     * Search for thousands of bills by exact bill number match in a single request. Optimized for performance.
     * @summary Bulk Search Bills by Number
     * @param {AccountsPayableApiCoaApiV1BillBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillBulkSearchCreate(requestParameters: AccountsPayableApiCoaApiV1BillBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillBulkSearchCreate(requestParameters.bulkBillSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync multiple bills to Ramp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillBulkSyncToRampCreate(options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillBulkSyncToRampCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Creates a new accounting bill with line items and automatic journal entry generation.          This endpoint allows for complex bill creation with:         - Multiple line items with different accounts, departments, and vendor assignments         - Automatic accounts payable journal entry creation         - Tax calculations and tax account handling         - Exchange rate support for multi-currency transactions         - Custom field support for additional bill metadata          Requirements:         - All referenced accounts must exist and be active         - Vendor must exist         - Entity must exist         - Line items must have valid amounts and descriptions         - Currency must be valid for the entity         - Accounting date must be before closed book date         
     * @summary Create Accounting Bill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillCreate(options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Permanently deletes an accounting bill and its associated journal entry.          This endpoint performs a complete deletion of the bill including:         - Removal of all bill line items and associated data         - Deletion of the corresponding accounts payable journal entry         - Cleanup of any tax calculations and allocations         - Removal of vendor payment allocations if applicable          **Important Notes:**         - This operation is irreversible and permanently removes the bill from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity         - All double-entry bookkeeping records related to this bill will be removed         - Any payments allocated to this bill should be handled separately before deletion         - Deletion may affect financial reports and account balances          **Restrictions:**         - Bills with allocated payments may require payment reallocation first         - Consider the impact on historical financial reporting         - Bills cannot be deleted in a closed period         
     * @summary Delete Accounting Bill
     * @param {AccountsPayableApiCoaApiV1BillDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillDestroy(requestParameters: AccountsPayableApiCoaApiV1BillDestroyRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the default department and tags from the bill line with the largest total amount.          This endpoint is used to provide default values when creating empty transactions (marking as paid without a transaction).         The total amount is calculated as: amount + tax.         If multiple lines have the same total amount, the line with the lowest ID (first created) is selected.         The department and tags are retrieved directly from the bill line.
     * @summary Get Default Department and Tags for Empty Transaction
     * @param {AccountsPayableApiCoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve(requestParameters: AccountsPayableApiCoaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillEmptyTransactionDefaultDepartmentTagsRetrieve(requestParameters.billId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a partial update of an existing accounting bill using PATCH semantics.          This endpoint allows selective modification of bill fields without requiring         a complete bill replacement. You can update specific aspects of the bill while         leaving other fields unchanged.          **Updatable Fields:**         - Bill metadata (number, dates, descriptions, vendor, entity)         - Line items (amounts, accounts, descriptions, departments)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Currency and exchange rates         
     * @summary Partial Update Accounting Bill
     * @param {AccountsPayableApiCoaApiV1BillPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillPartialUpdate(requestParameters: AccountsPayableApiCoaApiV1BillPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillPartialUpdate(requestParameters.id, requestParameters.patchedAccountingBill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a bill as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply debit memos to reduce the bill balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - debit_memos: List of debit memos to apply         - empty_transactions: List of manual payments without transactions
     * @summary Mark Bill as Paid
     * @param {AccountsPayableApiCoaApiV1BillPayCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillPayCreate(requestParameters: AccountsPayableApiCoaApiV1BillPayCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillPayCreate(requestParameters.billId, requestParameters.markPaid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void an existing bill payment.          This creates a reversing journal entry to void the payment and updates the bill status.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
     * @summary Void Bill Payment
     * @param {AccountsPayableApiCoaApiV1BillPaymentVoidCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillPaymentVoidCreate(requestParameters: AccountsPayableApiCoaApiV1BillPaymentVoidCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillPaymentVoidCreate(requestParameters.billId, requestParameters.paymentId, requestParameters.voidPayment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a bill payment.          This removes the payment record and updates the transaction to uncategorized.
     * @summary Delete Bill Payment
     * @param {AccountsPayableApiCoaApiV1BillPaymentVoidDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillPaymentVoidDestroy(requestParameters: AccountsPayableApiCoaApiV1BillPaymentVoidDestroyRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillPaymentVoidDestroy(requestParameters.billId, requestParameters.paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reopen a voided bill.          This removes the void date and void journal entry, and sets the bill status back to open.         The voiding journal entry will be deleted to reverse the void operation.
     * @summary Reopen Voided Bill
     * @param {AccountsPayableApiCoaApiV1BillReopenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillReopenCreate(requestParameters: AccountsPayableApiCoaApiV1BillReopenCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillReopenCreate(requestParameters.billId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a paginated list of accounting bills with comprehensive filtering, search, and sorting capabilities.          This endpoint provides complete access to your bills data with:         - Advanced filtering by date ranges, payment status, vendors, entities, and currency         - Full-text search across bill numbers, vendor names, addresses, and bill messages         - Flexible sorting by any field including calculated fields (totals, amounts due, etc.)         - Comprehensive pagination with customizable page sizes         - Aging calculations and payment status categorization         - Automatic calculation of totals, amounts paid, and amounts due          **Deleted Records Support:**         - When include_deleted=true: Returns ONLY deleted bills with minimal data (id, is_deleted, deleted_at, last_modified_at)         - When include_deleted=false or omitted: Returns ONLY active bills with full data         - Timestamp filtering (last_modified_at__gte/lte) works with both active and deleted records         
     * @summary List Accounting Bills
     * @param {AccountsPayableApiCoaApiV1BillRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillRetrieve(requestParameters: AccountsPayableApiCoaApiV1BillRetrieveRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillRetrieve(requestParameters.currency, requestParameters.download, requestParameters.endDate, requestParameters.entity, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.startDate, requestParameters.status, requestParameters.vendor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a single accounting bill by ID with complete detail including all line items, payments, and related data.          This endpoint returns comprehensive bill information including:         - Full bill details with vendor, entity, and customer information         - All line items with account details, departments, tags, and amortization schedules         - Complete payment history with journal entry references         - Calculated fields including total amounts, amounts paid, amounts due, and payment status         - Journal entry references for accounting integration         - Exchange rate information for multi-currency bills         
     * @summary Retrieve Accounting Bill
     * @param {AccountsPayableApiCoaApiV1BillRetrieve2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillRetrieve2(requestParameters: AccountsPayableApiCoaApiV1BillRetrieve2Request, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillRetrieve2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync a bill without a source to Ramp using the enabled Ramp connection
     * @summary Sync Bill to Ramp
     * @param {AccountsPayableApiCoaApiV1BillSyncToRampCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillSyncToRampCreate(requestParameters: AccountsPayableApiCoaApiV1BillSyncToRampCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillSyncToRampCreate(requestParameters.billId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Update an existing accounting bill with complete replacement of all data including line items and metadata.          This endpoint performs a full update (PUT) of an accounting bill with:         - Complete replacement of all bill data including vendor, entity, dates, and terms         - Full replacement of all line items with new account assignments, amounts, and descriptions         - Automatic recalculation of journal entries and accounting transactions         - Preservation of payment history while updating balances and amounts due         - Validation of all referenced accounts, vendors, entities, and departments         - Automatic exchange rate updates for multi-currency bills         - Custom field updates and attachment management         
     * @summary Update Accounting Bill
     * @param {AccountsPayableApiCoaApiV1BillUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillUpdate(requestParameters: AccountsPayableApiCoaApiV1BillUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillUpdate(requestParameters.id, requestParameters.accountingBill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void an existing bill.          This creates a reversing journal entry to void the bill by reversing all debit and credit amounts.         The bill status will be updated to reflect the void.
     * @summary Void Bill
     * @param {AccountsPayableApiCoaApiV1BillVoidCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillVoidCreate(requestParameters: AccountsPayableApiCoaApiV1BillVoidCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1BillVoidCreate(requestParameters.billId, requestParameters.voidBillRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for thousands of debit memos by exact debit memo number match in a single request. Optimized for performance.
     * @summary Bulk Search Debit Memos by Number
     * @param {AccountsPayableApiCoaApiV1DebitMemoBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoBulkSearchCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoBulkSearchCreate(requestParameters.bulkDebitMemoSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Creates a new accounting debit memo with line items and automatic journal entry generation.          Debit memos are used to record amounts owed to vendors or to adjust vendor account balances.         This endpoint handles multi-currency transactions, departmental allocations, and automatic         double-entry bookkeeping.         
     * @summary Create Debit Memo
     * @param {AccountsPayableApiCoaApiV1DebitMemoCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoCreate(requestParameters.accountingDebitMemo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Debit Memo
     * @param {AccountsPayableApiCoaApiV1DebitMemoDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoDestroy(requestParameters: AccountsPayableApiCoaApiV1DebitMemoDestroyRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieves a paginated list of accounting debit memos with filtering and sorting capabilities.          Supports filtering by date ranges, status, vendors, entities, and full-text search.         
     * @summary List Debit Memos
     * @param {AccountsPayableApiCoaApiV1DebitMemoListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoList(requestParameters: AccountsPayableApiCoaApiV1DebitMemoListRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a debit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/P to clear the debit memo.         The debit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
     * @summary Mark Debit Memo as Used
     * @param {AccountsPayableApiCoaApiV1DebitMemoMarkUsedCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoMarkUsedCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoMarkUsedCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoMarkUsedCreate(requestParameters.debitMemoId, requestParameters.markDebitMemoUsed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Next Debit Memo Number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoNextDebitMemoNumberRetrieve(options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoNextDebitMemoNumberRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a partial update of an existing accounting debit memo using PATCH semantics.          This endpoint allows selective modification of debit memo fields without requiring         a complete replacement.         
     * @summary Partial Update Debit Memo
     * @param {AccountsPayableApiCoaApiV1DebitMemoPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoPartialUpdate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoPartialUpdate(requestParameters.id, requestParameters.patchedAccountingDebitMemo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reopen a voided debit memo.          This removes the void date and void journal entry, and sets the debit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
     * @summary Reopen Voided Debit Memo
     * @param {AccountsPayableApiCoaApiV1DebitMemoReopenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoReopenCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoReopenCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoReopenCreate(requestParameters.debitMemoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieves a single accounting debit memo with complete details including line items,         payments, and accounting relationships.         
     * @summary Retrieve Debit Memo
     * @param {AccountsPayableApiCoaApiV1DebitMemoRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoRetrieve(requestParameters: AccountsPayableApiCoaApiV1DebitMemoRetrieveRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a complete update of an existing accounting debit memo using PUT semantics.          This endpoint allows full replacement of debit memo data including line items         and journal entry recalculation.         
     * @summary Update Debit Memo
     * @param {AccountsPayableApiCoaApiV1DebitMemoUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoUpdate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoUpdate(requestParameters.id, requestParameters.accountingDebitMemo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void an existing debit memo.          This creates a reversing journal entry to void the debit memo by reversing all debit and credit amounts.         The debit memo status will be updated to reflect the void.
     * @summary Void Debit Memo
     * @param {AccountsPayableApiCoaApiV1DebitMemoVoidCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1DebitMemoVoidCreate(requestParameters: AccountsPayableApiCoaApiV1DebitMemoVoidCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsPayableApiFp(this.configuration).coaApiV1DebitMemoVoidCreate(requestParameters.debitMemoId, requestParameters.voidDebitMemoRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CoaApiV1BillRetrieveStatusEnum = {
    _130: '1_30',
    _3160: '31_60',
    _6190: '61_90',
    _91120: '91_120',
    Current: 'current',
    Open: 'open',
    Over120: 'over_120',
    Paid: 'paid',
    PartiallyPaid: 'partially_paid',
    PastDue: 'past_due',
    PaymentNotFound: 'payment_not_found',
    PaymentPending: 'payment_pending',
    Unpaid: 'unpaid',
    Voided: 'voided'
} as const;
export type CoaApiV1BillRetrieveStatusEnum = typeof CoaApiV1BillRetrieveStatusEnum[keyof typeof CoaApiV1BillRetrieveStatusEnum];


/**
 * AccountsReceivableApi - axios parameter creator
 */
export const AccountsReceivableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      Create multiple invoices atomically in a single transaction.      All invoices are created within a single database transaction. If any invoice creation fails,     all invoices are rolled back and no invoices are created.      This endpoint validates all invoices before creating any of them, ensuring data integrity.     
         * @summary Bulk Create Invoices
         * @param {BulkCreateInvoices} bulkCreateInvoices 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInvoices: async (bulkCreateInvoices: BulkCreateInvoices, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkCreateInvoices' is not null or undefined
            assertParamExists('bulkCreateInvoices', 'bulkCreateInvoices', bulkCreateInvoices)
            const localVarPath = `/coa/api/v1/invoice/bulk-create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkCreateInvoices, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for thousands of credit memos by exact credit memo number match in a single request. Optimized for performance.
         * @summary Bulk Search Credit Memos by Number
         * @param {BulkCreditMemoSearch} bulkCreditMemoSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoBulkSearchCreate: async (bulkCreditMemoSearch: BulkCreditMemoSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkCreditMemoSearch' is not null or undefined
            assertParamExists('coaApiV1CreditMemoBulkSearchCreate', 'bulkCreditMemoSearch', bulkCreditMemoSearch)
            const localVarPath = `/coa/api/v1/credit-memo/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkCreditMemoSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Creates a new accounting credit memo with line items and automatic journal entry generation.          This endpoint allows for comprehensive credit memo creation with:         - Multiple line items with different products, accounts, amounts, and departmental allocations         - Automatic journal entry creation following double-entry bookkeeping principles         - Multi-currency support with exchange rate handling         - Client and entity relationship management         - Contract associations for revenue recognition tracking         - Product-based line item categorization with tax handling         - Tag-based transaction categorization and reporting         
         * @summary Create Credit Memo
         * @param {AccountingCreditMemo} accountingCreditMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoCreate: async (accountingCreditMemo: AccountingCreditMemo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountingCreditMemo' is not null or undefined
            assertParamExists('coaApiV1CreditMemoCreate', 'accountingCreditMemo', accountingCreditMemo)
            const localVarPath = `/coa/api/v1/credit-memo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountingCreditMemo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Permanently deletes an accounting credit memo and all associated data from the system.          This endpoint performs a complete removal of the credit memo including:         - Complete credit memo record deletion with all line items         - Automatic journal entry removal and accounting transaction cleanup          **Accounting Impact:**         - Associated journal entries are automatically deleted to maintain accounting integrity         - Exchange rate records and multi-currency data are cleaned up          **Restrictions:**         - Credit memos that have been applied to invoices cannot be deleted         - Credit memos in closed accounting periods may have deletion restrictions         - Consider the impact on historical financial reporting         
         * @summary Delete Credit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1CreditMemoDestroy', 'id', id)
            const localVarPath = `/coa/api/v1/credit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieves a paginated list of accounting credit memos with comprehensive filtering and sorting capabilities.          This endpoint provides a powerful interface for browsing and searching credit memos with:         - Advanced filtering by date ranges, status, clients, entities, and contracts         - Full-text search across credit memo numbers, messages, and client names         - Flexible sorting by multiple fields including amounts and relationships         - Optimized performance with efficient database queries and pagination         - Complete credit memo details including line items, payment status, and accounting relationships          **Key Features:**         - Date range filtering for credit memo creation and application dates         - Status-based filtering (open, partially_used, used, voided)         - Client and entity-based filtering with hierarchical client support         - Contract association filtering for revenue recognition workflows         - Full-text search capabilities across key fields          **Query Parameters:**         - `start_date`, `end_date`: Filter by credit memo date range         - `status`: Filter by application status (open, partially_used, used, voided)         - `q`: Full-text search across credit memo number, message, and client name         - `client`: Filter by specific client IDs (supports multiple values)         - `entity`: Filter by specific entity IDs (supports multiple values)         - `contract`: Filter by specific contract IDs (supports multiple values)         - `sort`: Sort by various fields (credit_memo_date, client_name, total_amount, etc.)         - `limit`, `offset`: Pagination controls for large result sets         
         * @summary List Credit Memos
         * @param {Array<number>} [client] Filter by client IDs (can specify multiple)
         * @param {Array<number>} [contract] Filter by contract IDs (can specify multiple)
         * @param {string} [endDate] Filter credit memos created on or before this date (YYYY-MM-DD format)
         * @param {Array<number>} [entity] Filter by entity IDs (can specify multiple)
         * @param {number} [limit] Number of results to return per page
         * @param {number} [offset] Number of results to skip for pagination
         * @param {string} [q] Search credit memo numbers, messages, and client names
         * @param {CoaApiV1CreditMemoListSortEnum} [sort] Sort results by field (prefix with - for descending)
         * @param {string} [startDate] Filter credit memos created on or after this date (YYYY-MM-DD format)
         * @param {CoaApiV1CreditMemoListStatusEnum} [status] Filter by application status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoList: async (client?: Array<number>, contract?: Array<number>, endDate?: string, entity?: Array<number>, limit?: number, offset?: number, q?: string, sort?: CoaApiV1CreditMemoListSortEnum, startDate?: string, status?: CoaApiV1CreditMemoListStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/credit-memo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (client) {
                localVarQueryParameter['client'] = client;
            }

            if (contract) {
                localVarQueryParameter['contract'] = contract;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (entity) {
                localVarQueryParameter['entity'] = entity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a credit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/R to clear the credit memo.         The credit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
         * @summary Mark Credit Memo as Used
         * @param {number} creditMemoId ID of the credit memo to mark as used
         * @param {MarkCreditMemoUsed} markCreditMemoUsed 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoMarkUsedCreate: async (creditMemoId: number, markCreditMemoUsed: MarkCreditMemoUsed, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditMemoId' is not null or undefined
            assertParamExists('coaApiV1CreditMemoMarkUsedCreate', 'creditMemoId', creditMemoId)
            // verify required parameter 'markCreditMemoUsed' is not null or undefined
            assertParamExists('coaApiV1CreditMemoMarkUsedCreate', 'markCreditMemoUsed', markCreditMemoUsed)
            const localVarPath = `/coa/api/v1/credit-memo/{credit_memo_id}/mark-used`
                .replace(`{${"credit_memo_id"}}`, encodeURIComponent(String(creditMemoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markCreditMemoUsed, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Next Credit Memo Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoNextCreditMemoNumberRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/credit-memo/next-credit-memo-number`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a partial update of an existing accounting credit memo using PATCH semantics.          This endpoint allows selective modification of credit memo fields without requiring         a complete credit memo replacement. You can update specific aspects of the credit memo while         leaving other fields unchanged.          **Updatable Fields:**         - Credit memo metadata (dates, messages, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Reference numbers and contract associations         - Exchange rates and currency information         - Custom fields and additional metadata         - Application status and tracking information         
         * @summary Partial Update Credit Memo
         * @param {number} id 
         * @param {PatchedAccountingCreditMemo} [patchedAccountingCreditMemo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoPartialUpdate: async (id: number, patchedAccountingCreditMemo?: PatchedAccountingCreditMemo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1CreditMemoPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/v1/credit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccountingCreditMemo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reopen a voided credit memo.          This removes the void date and void journal entry, and sets the credit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Credit Memo
         * @param {number} creditMemoId ID of the voided credit memo to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoReopenCreate: async (creditMemoId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditMemoId' is not null or undefined
            assertParamExists('coaApiV1CreditMemoReopenCreate', 'creditMemoId', creditMemoId)
            const localVarPath = `/coa/api/v1/credit-memo/{credit_memo_id}/reopen/`
                .replace(`{${"credit_memo_id"}}`, encodeURIComponent(String(creditMemoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieves a single accounting credit memo with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive credit memo information with:         - Complete credit memo metadata (dates, amounts, status, currency, terms)         - All associated line items with product details, account information, and departmental allocations         - Payment application history with journal entry references and transaction details         - Client and entity information with relationship details         - Contract associations for revenue recognition and reporting         - File attachments and supporting documentation         - Journal entry references for accounting audit trails and compliance         
         * @summary Retrieve Credit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1CreditMemoRetrieve', 'id', id)
            const localVarPath = `/coa/api/v1/credit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a complete update of an existing accounting credit memo using PUT semantics.          This endpoint allows full replacement of credit memo data including:         - Complete credit memo metadata update (dates, amounts, client, entity, currency)         - Full line item replacement with new products, accounts, amounts, and departmental allocations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency credit memos         - Contract and reference number association updates         - Custom field updates and modifications          **Important Notes:**         - This is a full replacement operation - all credit memo data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
         * @summary Update Credit Memo
         * @param {number} id 
         * @param {AccountingCreditMemo} accountingCreditMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoUpdate: async (id: number, accountingCreditMemo: AccountingCreditMemo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1CreditMemoUpdate', 'id', id)
            // verify required parameter 'accountingCreditMemo' is not null or undefined
            assertParamExists('coaApiV1CreditMemoUpdate', 'accountingCreditMemo', accountingCreditMemo)
            const localVarPath = `/coa/api/v1/credit-memo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountingCreditMemo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void an existing credit memo.          This creates a reversing journal entry to void the credit memo by reversing all debit and credit amounts.         The credit memo status will be updated to reflect the void.
         * @summary Void Credit Memo
         * @param {number} creditMemoId ID of the credit memo to void
         * @param {VoidCreditMemoRequest} voidCreditMemoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoVoidCreate: async (creditMemoId: number, voidCreditMemoRequest: VoidCreditMemoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditMemoId' is not null or undefined
            assertParamExists('coaApiV1CreditMemoVoidCreate', 'creditMemoId', creditMemoId)
            // verify required parameter 'voidCreditMemoRequest' is not null or undefined
            assertParamExists('coaApiV1CreditMemoVoidCreate', 'voidCreditMemoRequest', voidCreditMemoRequest)
            const localVarPath = `/coa/api/v1/credit-memo/{credit_memo_id}/void/`
                .replace(`{${"credit_memo_id"}}`, encodeURIComponent(String(creditMemoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voidCreditMemoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply a single transaction payment to multiple selected invoices.  Supports two selection modes: - Explicit invoice IDs (``invoice_ids``) - Filter-based selection (``filters``) for \"select all matching\" behaviour  Reuses :meth:`MarkInvoicePaidView.apply_transaction_payment` so that line-level payment splitting, FX gain/loss realisation, and transaction cleanup are all respected.  A single ``DraftQueue`` is created when approval is required.
         * @summary Bulk Apply Transaction Payment to Selected Invoices
         * @param {BulkApplyInvoicePayment} bulkApplyInvoicePayment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceBulkApplyPaymentCreate: async (bulkApplyInvoicePayment: BulkApplyInvoicePayment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkApplyInvoicePayment' is not null or undefined
            assertParamExists('coaApiV1InvoiceBulkApplyPaymentCreate', 'bulkApplyInvoicePayment', bulkApplyInvoicePayment)
            const localVarPath = `/coa/api/v1/invoice/bulk-apply-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkApplyInvoicePayment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for thousands of invoices by exact invoice number match in a single request. Optimized for performance.
         * @summary Bulk Search Invoices by Number
         * @param {BulkInvoiceSearch} bulkInvoiceSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceBulkSearchCreate: async (bulkInvoiceSearch: BulkInvoiceSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkInvoiceSearch' is not null or undefined
            assertParamExists('coaApiV1InvoiceBulkSearchCreate', 'bulkInvoiceSearch', bulkInvoiceSearch)
            const localVarPath = `/coa/api/v1/invoice/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkInvoiceSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculate the payment details for an invoice.          This endpoint calculates:         - Total amount due on the invoice         - Applied payments (existing + proposed)         - Applied credits (existing + proposed credit memos)         - Payment term discounts (based on payment dates) - ALL OR NOTHING: discount only applies if paying full invoice         - Remaining balance due          Supports payment terms with early payment discounts (all-or-nothing).         
         * @summary Calculate Invoice Payment
         * @param {number} invoiceId ID of the invoice
         * @param {CalculatePaymentInput} [calculatePaymentInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceCalculatePaymentCreate: async (invoiceId: number, calculatePaymentInput?: CalculatePaymentInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('coaApiV1InvoiceCalculatePaymentCreate', 'invoiceId', invoiceId)
            const localVarPath = `/coa/api/v1/invoice/{invoice_id}/calculate-payment`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculatePaymentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Creates a new accounting invoice with line items and automatic journal entry generation.          This endpoint allows for comprehensive invoice creation with:         - Multiple line items with different products, rates, quantities, and tax handling         - Automatic accounts receivable journal entry creation         - Tax calculations and tax account handling         - Multi-currency support with exchange rate handling         - Product-based taxation rules         - Service date tracking for revenue recognition         - Contract and purchase order integration         - Stripe payment integration support          Key features:         - Credits revenue accounts for each line item amount         - Debits accounts receivable for the total amount         - Handles tax calculations with appropriate tax accounts         - Supports entity-specific currency conversions         - Creates proper double-entry accounting transactions         - Validates client, entity, and product relationships         - Integrates with Stripe for payment processing          Requirements:         - All referenced products, clients, and entities must exist and be active         - Client must be of type \'customer\'         - Line items must have valid amounts, quantities, and rates         - Currency must be valid for the entity         - Tax calculations must comply with configured tax rules         
         * @summary Create Invoice
         * @param {AccountingInvoice} accountingInvoice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceCreate: async (accountingInvoice: AccountingInvoice, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountingInvoice' is not null or undefined
            assertParamExists('coaApiV1InvoiceCreate', 'accountingInvoice', accountingInvoice)
            const localVarPath = `/coa/api/v1/invoice/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountingInvoice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the default payment amount for an invoice based on when payment is posted.          If the invoice has discount terms and the posted date is within the discount period,         the discounted amount is returned. Otherwise, the full amount is returned.         
         * @summary Get Default Payment Amount
         * @param {number} invoiceId ID of the invoice
         * @param {GetDefaultPaymentInput} getDefaultPaymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceDefaultPaymentCreate: async (invoiceId: number, getDefaultPaymentInput: GetDefaultPaymentInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('coaApiV1InvoiceDefaultPaymentCreate', 'invoiceId', invoiceId)
            // verify required parameter 'getDefaultPaymentInput' is not null or undefined
            assertParamExists('coaApiV1InvoiceDefaultPaymentCreate', 'getDefaultPaymentInput', getDefaultPaymentInput)
            const localVarPath = `/coa/api/v1/invoice/{invoice_id}/default-payment`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDefaultPaymentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Permanently deletes an accounting invoice and its associated journal entry and related data.          This endpoint performs a complete deletion of the invoice including:         - Removal of all invoice line items and associated product data         - Deletion of the corresponding accounts receivable journal entry         - Removal of payment records and journal entries          **Important Notes:**         - This operation is irreversible and permanently removes the invoice from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity          **Restrictions:**         - Invoices in closed accounting periods cannot be deleted         - Consider the impact on historical financial reporting         
         * @summary Delete Invoice
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1InvoiceDestroy', 'id', id)
            const localVarPath = `/coa/api/v1/invoice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a paginated list of invoices with comprehensive filtering, sorting, and download capabilities.          This endpoint provides powerful invoice listing with:         - Advanced filtering by date ranges, status, clients, and entities         - Full-text search across multiple fields         - Flexible sorting options including custom calculated fields         - Async CSV export functionality via email         - Optimized queries with prefetched relationships          **Filtering Options:**         - Date-based filtering (invoice_date, due_date ranges)         - Status-based filtering (payment status, sent status, aging buckets)         - Entity and client-based filtering (supports multiple selections)         - Contract and currency filtering         - Full-text search across invoice numbers, addresses, messages, and client names          **Sorting Capabilities:**         - Standard field sorting (invoice_date, total_amount, due_date, etc.)         - Custom calculated field sorting (amount_due, client_name, contract_name)         - Ascending/descending order with null handling          **Performance Features:**         - Efficient database queries with proper indexing         - Prefetched related objects (lines, payments, clients, entities)         - Pagination support for large datasets         - Optimized for high-volume invoice management          **Export Functionality:**         - Async CSV generation and email delivery         - Filtered export based on current query parameters         - Background processing to handle large datasets         
         * @summary List Invoices
         * @param {number} [client] Filter by client ID. Can be specified multiple times
         * @param {number} [contract] Filter by contract ID
         * @param {string} [currency] Filter by currency code (e.g., USD, EUR)
         * @param {boolean} [download] If true, triggers async CSV download workflow and sends result via email
         * @param {string} [endDate] Filter invoices with invoice_date on or before this date (YYYY-MM-DD)
         * @param {number} [entity] Filter by entity ID. Can be specified multiple times
         * @param {string} [invoiceNumber] Filter by exact invoice number
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches shipping address, invoice number, message, or client name
         * @param {string} [refNumber] Filter by exact ref number
         * @param {CoaApiV1InvoiceListSentStatusEnum} [sentStatus] Filter by sent status
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Special fields: client_name, amount_due. Default: -invoice_date
         * @param {string} [startDate] Filter invoices with invoice_date on or after this date (YYYY-MM-DD)
         * @param {CoaApiV1InvoiceListStatusEnum} [status] Filter by payment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceList: async (client?: number, contract?: number, currency?: string, download?: boolean, endDate?: string, entity?: number, invoiceNumber?: string, limit?: number, offset?: number, q?: string, refNumber?: string, sentStatus?: CoaApiV1InvoiceListSentStatusEnum, sort?: string, startDate?: string, status?: CoaApiV1InvoiceListStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/invoice/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }

            if (contract !== undefined) {
                localVarQueryParameter['contract'] = contract;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (invoiceNumber !== undefined) {
                localVarQueryParameter['invoice_number'] = invoiceNumber;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (refNumber !== undefined) {
                localVarQueryParameter['ref_number'] = refNumber;
            }

            if (sentStatus !== undefined) {
                localVarQueryParameter['sentStatus'] = sentStatus;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a partial update of an existing accounting invoice using PATCH semantics.          This endpoint allows selective modification of invoice fields without requiring         a complete invoice replacement. You can update specific aspects of the invoice while         leaving other fields unchanged.          **Updatable Fields:**         - Invoice metadata (dates, terms, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Contract and purchase order associations         - Exchange rates and currency information         
         * @summary Partial Update Invoice
         * @param {number} id 
         * @param {PatchedAccountingInvoice} [patchedAccountingInvoice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePartialUpdate: async (id: number, patchedAccountingInvoice?: PatchedAccountingInvoice, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1InvoicePartialUpdate', 'id', id)
            const localVarPath = `/coa/api/v1/invoice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccountingInvoice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark an invoice as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply credit memos to reduce the invoice balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - credit_memos: List of credit memos to apply         - empty_transactions: List of manual payments without transactions
         * @summary Mark Invoice as Paid
         * @param {number} invoiceId ID of the invoice to mark as paid
         * @param {MarkPaid} [markPaid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePayCreate: async (invoiceId: number, markPaid?: MarkPaid, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('coaApiV1InvoicePayCreate', 'invoiceId', invoiceId)
            const localVarPath = `/coa/api/v1/invoice/{invoice_id}/pay/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markPaid, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void an existing invoice payment.          This creates a reversing journal entry to void the payment and updates the invoice status.         For Stripe payments, this will also process a refund through Stripe.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
         * @summary Void Invoice Payment
         * @param {number} invoiceId ID of the invoice
         * @param {number} paymentId ID of the payment to void
         * @param {VoidPayment} [voidPayment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePaymentVoidCreate: async (invoiceId: number, paymentId: number, voidPayment?: VoidPayment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('coaApiV1InvoicePaymentVoidCreate', 'invoiceId', invoiceId)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('coaApiV1InvoicePaymentVoidCreate', 'paymentId', paymentId)
            const localVarPath = `/coa/api/v1/invoice/{invoice_id}/payment/{payment_id}/void/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"payment_id"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voidPayment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an invoice payment.          This removes the payment record and updates the transaction to uncategorized.         For Stripe payments, this will also process a refund through Stripe.
         * @summary Delete Invoice Payment
         * @param {number} invoiceId ID of the invoice
         * @param {number} paymentId ID of the payment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePaymentVoidDestroy: async (invoiceId: number, paymentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('coaApiV1InvoicePaymentVoidDestroy', 'invoiceId', invoiceId)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('coaApiV1InvoicePaymentVoidDestroy', 'paymentId', paymentId)
            const localVarPath = `/coa/api/v1/invoice/{invoice_id}/payment/{payment_id}/void/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"payment_id"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reopen a voided invoice.          This removes the void date and void journal entry, and sets the invoice status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Invoice
         * @param {number} invoiceId ID of the voided invoice to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceReopenCreate: async (invoiceId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('coaApiV1InvoiceReopenCreate', 'invoiceId', invoiceId)
            const localVarPath = `/coa/api/v1/invoice/{invoice_id}/reopen/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieves a single accounting invoice with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive invoice information with:         - Complete invoice metadata (dates, amounts, status, terms)         - All associated line items with product details and tax information         - Payment history with journal entry references and transaction details         
         * @summary Retrieve Invoice
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1InvoiceRetrieve', 'id', id)
            const localVarPath = `/coa/api/v1/invoice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a complete update of an existing accounting invoice using PUT semantics.          This endpoint allows full replacement of invoice data including:         - Complete invoice metadata update (dates, amounts, terms, client, entity)         - Full line item replacement with new products, quantities, rates, and tax calculations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency invoices          **Important Notes:**         - This is a full replacement operation - all invoice data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
         * @summary Update Invoice
         * @param {number} id 
         * @param {AccountingInvoice} accountingInvoice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceUpdate: async (id: number, accountingInvoice: AccountingInvoice, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1InvoiceUpdate', 'id', id)
            // verify required parameter 'accountingInvoice' is not null or undefined
            assertParamExists('coaApiV1InvoiceUpdate', 'accountingInvoice', accountingInvoice)
            const localVarPath = `/coa/api/v1/invoice/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountingInvoice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void an existing invoice.          This creates a reversing journal entry to void the invoice by reversing all debit and credit amounts.         The invoice status will be updated to reflect the void.
         * @summary Void Invoice
         * @param {number} invoiceId ID of the invoice to void
         * @param {VoidInvoiceRequest} [voidInvoiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceVoidCreate: async (invoiceId: number, voidInvoiceRequest?: VoidInvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('coaApiV1InvoiceVoidCreate', 'invoiceId', invoiceId)
            const localVarPath = `/coa/api/v1/invoice/{invoice_id}/void/`
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voidInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new product
         * @summary Create Contract Product
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (product?: Product, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Products
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Product
         * @param {number} id 
         * @param {PatchedProduct} [patchedProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductPartialUpdate: async (id: number, patchedProduct?: PatchedProduct, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Product
         * @param {number} id 
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductUpdate: async (id: number, product?: Product, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsReceivableApi - functional programming interface
 */
export const AccountsReceivableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsReceivableApiAxiosParamCreator(configuration)
    return {
        /**
         *      Create multiple invoices atomically in a single transaction.      All invoices are created within a single database transaction. If any invoice creation fails,     all invoices are rolled back and no invoices are created.      This endpoint validates all invoices before creating any of them, ensuring data integrity.     
         * @summary Bulk Create Invoices
         * @param {BulkCreateInvoices} bulkCreateInvoices 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreateInvoices(bulkCreateInvoices: BulkCreateInvoices, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountingInvoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateInvoices(bulkCreateInvoices, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.bulkCreateInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for thousands of credit memos by exact credit memo number match in a single request. Optimized for performance.
         * @summary Bulk Search Credit Memos by Number
         * @param {BulkCreditMemoSearch} bulkCreditMemoSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoBulkSearchCreate(bulkCreditMemoSearch: BulkCreditMemoSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoBulkSearchCreate(bulkCreditMemoSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Creates a new accounting credit memo with line items and automatic journal entry generation.          This endpoint allows for comprehensive credit memo creation with:         - Multiple line items with different products, accounts, amounts, and departmental allocations         - Automatic journal entry creation following double-entry bookkeeping principles         - Multi-currency support with exchange rate handling         - Client and entity relationship management         - Contract associations for revenue recognition tracking         - Product-based line item categorization with tax handling         - Tag-based transaction categorization and reporting         
         * @summary Create Credit Memo
         * @param {AccountingCreditMemo} accountingCreditMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoCreate(accountingCreditMemo: AccountingCreditMemo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingCreditMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoCreate(accountingCreditMemo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Permanently deletes an accounting credit memo and all associated data from the system.          This endpoint performs a complete removal of the credit memo including:         - Complete credit memo record deletion with all line items         - Automatic journal entry removal and accounting transaction cleanup          **Accounting Impact:**         - Associated journal entries are automatically deleted to maintain accounting integrity         - Exchange rate records and multi-currency data are cleaned up          **Restrictions:**         - Credit memos that have been applied to invoices cannot be deleted         - Credit memos in closed accounting periods may have deletion restrictions         - Consider the impact on historical financial reporting         
         * @summary Delete Credit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieves a paginated list of accounting credit memos with comprehensive filtering and sorting capabilities.          This endpoint provides a powerful interface for browsing and searching credit memos with:         - Advanced filtering by date ranges, status, clients, entities, and contracts         - Full-text search across credit memo numbers, messages, and client names         - Flexible sorting by multiple fields including amounts and relationships         - Optimized performance with efficient database queries and pagination         - Complete credit memo details including line items, payment status, and accounting relationships          **Key Features:**         - Date range filtering for credit memo creation and application dates         - Status-based filtering (open, partially_used, used, voided)         - Client and entity-based filtering with hierarchical client support         - Contract association filtering for revenue recognition workflows         - Full-text search capabilities across key fields          **Query Parameters:**         - `start_date`, `end_date`: Filter by credit memo date range         - `status`: Filter by application status (open, partially_used, used, voided)         - `q`: Full-text search across credit memo number, message, and client name         - `client`: Filter by specific client IDs (supports multiple values)         - `entity`: Filter by specific entity IDs (supports multiple values)         - `contract`: Filter by specific contract IDs (supports multiple values)         - `sort`: Sort by various fields (credit_memo_date, client_name, total_amount, etc.)         - `limit`, `offset`: Pagination controls for large result sets         
         * @summary List Credit Memos
         * @param {Array<number>} [client] Filter by client IDs (can specify multiple)
         * @param {Array<number>} [contract] Filter by contract IDs (can specify multiple)
         * @param {string} [endDate] Filter credit memos created on or before this date (YYYY-MM-DD format)
         * @param {Array<number>} [entity] Filter by entity IDs (can specify multiple)
         * @param {number} [limit] Number of results to return per page
         * @param {number} [offset] Number of results to skip for pagination
         * @param {string} [q] Search credit memo numbers, messages, and client names
         * @param {CoaApiV1CreditMemoListSortEnum} [sort] Sort results by field (prefix with - for descending)
         * @param {string} [startDate] Filter credit memos created on or after this date (YYYY-MM-DD format)
         * @param {CoaApiV1CreditMemoListStatusEnum} [status] Filter by application status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoList(client?: Array<number>, contract?: Array<number>, endDate?: string, entity?: Array<number>, limit?: number, offset?: number, q?: string, sort?: CoaApiV1CreditMemoListSortEnum, startDate?: string, status?: CoaApiV1CreditMemoListStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccountingCreditMemoList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoList(client, contract, endDate, entity, limit, offset, q, sort, startDate, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark a credit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/R to clear the credit memo.         The credit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
         * @summary Mark Credit Memo as Used
         * @param {number} creditMemoId ID of the credit memo to mark as used
         * @param {MarkCreditMemoUsed} markCreditMemoUsed 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoMarkUsedCreate(creditMemoId: number, markCreditMemoUsed: MarkCreditMemoUsed, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoMarkUsedCreate(creditMemoId, markCreditMemoUsed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoMarkUsedCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Next Credit Memo Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoNextCreditMemoNumberRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoNextCreditMemoNumberRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoNextCreditMemoNumberRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a partial update of an existing accounting credit memo using PATCH semantics.          This endpoint allows selective modification of credit memo fields without requiring         a complete credit memo replacement. You can update specific aspects of the credit memo while         leaving other fields unchanged.          **Updatable Fields:**         - Credit memo metadata (dates, messages, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Reference numbers and contract associations         - Exchange rates and currency information         - Custom fields and additional metadata         - Application status and tracking information         
         * @summary Partial Update Credit Memo
         * @param {number} id 
         * @param {PatchedAccountingCreditMemo} [patchedAccountingCreditMemo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoPartialUpdate(id: number, patchedAccountingCreditMemo?: PatchedAccountingCreditMemo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingCreditMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoPartialUpdate(id, patchedAccountingCreditMemo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reopen a voided credit memo.          This removes the void date and void journal entry, and sets the credit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Credit Memo
         * @param {number} creditMemoId ID of the voided credit memo to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoReopenCreate(creditMemoId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingCreditMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoReopenCreate(creditMemoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoReopenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieves a single accounting credit memo with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive credit memo information with:         - Complete credit memo metadata (dates, amounts, status, currency, terms)         - All associated line items with product details, account information, and departmental allocations         - Payment application history with journal entry references and transaction details         - Client and entity information with relationship details         - Contract associations for revenue recognition and reporting         - File attachments and supporting documentation         - Journal entry references for accounting audit trails and compliance         
         * @summary Retrieve Credit Memo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingCreditMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a complete update of an existing accounting credit memo using PUT semantics.          This endpoint allows full replacement of credit memo data including:         - Complete credit memo metadata update (dates, amounts, client, entity, currency)         - Full line item replacement with new products, accounts, amounts, and departmental allocations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency credit memos         - Contract and reference number association updates         - Custom field updates and modifications          **Important Notes:**         - This is a full replacement operation - all credit memo data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
         * @summary Update Credit Memo
         * @param {number} id 
         * @param {AccountingCreditMemo} accountingCreditMemo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoUpdate(id: number, accountingCreditMemo: AccountingCreditMemo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingCreditMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoUpdate(id, accountingCreditMemo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Void an existing credit memo.          This creates a reversing journal entry to void the credit memo by reversing all debit and credit amounts.         The credit memo status will be updated to reflect the void.
         * @summary Void Credit Memo
         * @param {number} creditMemoId ID of the credit memo to void
         * @param {VoidCreditMemoRequest} voidCreditMemoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoVoidCreate(creditMemoId: number, voidCreditMemoRequest: VoidCreditMemoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingCreditMemo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoVoidCreate(creditMemoId, voidCreditMemoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1CreditMemoVoidCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply a single transaction payment to multiple selected invoices.  Supports two selection modes: - Explicit invoice IDs (``invoice_ids``) - Filter-based selection (``filters``) for \"select all matching\" behaviour  Reuses :meth:`MarkInvoicePaidView.apply_transaction_payment` so that line-level payment splitting, FX gain/loss realisation, and transaction cleanup are all respected.  A single ``DraftQueue`` is created when approval is required.
         * @summary Bulk Apply Transaction Payment to Selected Invoices
         * @param {BulkApplyInvoicePayment} bulkApplyInvoicePayment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceBulkApplyPaymentCreate(bulkApplyInvoicePayment: BulkApplyInvoicePayment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceBulkApplyPaymentCreate(bulkApplyInvoicePayment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceBulkApplyPaymentCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for thousands of invoices by exact invoice number match in a single request. Optimized for performance.
         * @summary Bulk Search Invoices by Number
         * @param {BulkInvoiceSearch} bulkInvoiceSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceBulkSearchCreate(bulkInvoiceSearch: BulkInvoiceSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceBulkSearchCreate(bulkInvoiceSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculate the payment details for an invoice.          This endpoint calculates:         - Total amount due on the invoice         - Applied payments (existing + proposed)         - Applied credits (existing + proposed credit memos)         - Payment term discounts (based on payment dates) - ALL OR NOTHING: discount only applies if paying full invoice         - Remaining balance due          Supports payment terms with early payment discounts (all-or-nothing).         
         * @summary Calculate Invoice Payment
         * @param {number} invoiceId ID of the invoice
         * @param {CalculatePaymentInput} [calculatePaymentInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceCalculatePaymentCreate(invoiceId: number, calculatePaymentInput?: CalculatePaymentInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculatePaymentOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceCalculatePaymentCreate(invoiceId, calculatePaymentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceCalculatePaymentCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Creates a new accounting invoice with line items and automatic journal entry generation.          This endpoint allows for comprehensive invoice creation with:         - Multiple line items with different products, rates, quantities, and tax handling         - Automatic accounts receivable journal entry creation         - Tax calculations and tax account handling         - Multi-currency support with exchange rate handling         - Product-based taxation rules         - Service date tracking for revenue recognition         - Contract and purchase order integration         - Stripe payment integration support          Key features:         - Credits revenue accounts for each line item amount         - Debits accounts receivable for the total amount         - Handles tax calculations with appropriate tax accounts         - Supports entity-specific currency conversions         - Creates proper double-entry accounting transactions         - Validates client, entity, and product relationships         - Integrates with Stripe for payment processing          Requirements:         - All referenced products, clients, and entities must exist and be active         - Client must be of type \'customer\'         - Line items must have valid amounts, quantities, and rates         - Currency must be valid for the entity         - Tax calculations must comply with configured tax rules         
         * @summary Create Invoice
         * @param {AccountingInvoice} accountingInvoice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceCreate(accountingInvoice: AccountingInvoice, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceCreate(accountingInvoice, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the default payment amount for an invoice based on when payment is posted.          If the invoice has discount terms and the posted date is within the discount period,         the discounted amount is returned. Otherwise, the full amount is returned.         
         * @summary Get Default Payment Amount
         * @param {number} invoiceId ID of the invoice
         * @param {GetDefaultPaymentInput} getDefaultPaymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceDefaultPaymentCreate(invoiceId: number, getDefaultPaymentInput: GetDefaultPaymentInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDefaultPaymentOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceDefaultPaymentCreate(invoiceId, getDefaultPaymentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceDefaultPaymentCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Permanently deletes an accounting invoice and its associated journal entry and related data.          This endpoint performs a complete deletion of the invoice including:         - Removal of all invoice line items and associated product data         - Deletion of the corresponding accounts receivable journal entry         - Removal of payment records and journal entries          **Important Notes:**         - This operation is irreversible and permanently removes the invoice from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity          **Restrictions:**         - Invoices in closed accounting periods cannot be deleted         - Consider the impact on historical financial reporting         
         * @summary Delete Invoice
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a paginated list of invoices with comprehensive filtering, sorting, and download capabilities.          This endpoint provides powerful invoice listing with:         - Advanced filtering by date ranges, status, clients, and entities         - Full-text search across multiple fields         - Flexible sorting options including custom calculated fields         - Async CSV export functionality via email         - Optimized queries with prefetched relationships          **Filtering Options:**         - Date-based filtering (invoice_date, due_date ranges)         - Status-based filtering (payment status, sent status, aging buckets)         - Entity and client-based filtering (supports multiple selections)         - Contract and currency filtering         - Full-text search across invoice numbers, addresses, messages, and client names          **Sorting Capabilities:**         - Standard field sorting (invoice_date, total_amount, due_date, etc.)         - Custom calculated field sorting (amount_due, client_name, contract_name)         - Ascending/descending order with null handling          **Performance Features:**         - Efficient database queries with proper indexing         - Prefetched related objects (lines, payments, clients, entities)         - Pagination support for large datasets         - Optimized for high-volume invoice management          **Export Functionality:**         - Async CSV generation and email delivery         - Filtered export based on current query parameters         - Background processing to handle large datasets         
         * @summary List Invoices
         * @param {number} [client] Filter by client ID. Can be specified multiple times
         * @param {number} [contract] Filter by contract ID
         * @param {string} [currency] Filter by currency code (e.g., USD, EUR)
         * @param {boolean} [download] If true, triggers async CSV download workflow and sends result via email
         * @param {string} [endDate] Filter invoices with invoice_date on or before this date (YYYY-MM-DD)
         * @param {number} [entity] Filter by entity ID. Can be specified multiple times
         * @param {string} [invoiceNumber] Filter by exact invoice number
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches shipping address, invoice number, message, or client name
         * @param {string} [refNumber] Filter by exact ref number
         * @param {CoaApiV1InvoiceListSentStatusEnum} [sentStatus] Filter by sent status
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Special fields: client_name, amount_due. Default: -invoice_date
         * @param {string} [startDate] Filter invoices with invoice_date on or after this date (YYYY-MM-DD)
         * @param {CoaApiV1InvoiceListStatusEnum} [status] Filter by payment status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceList(client?: number, contract?: number, currency?: string, download?: boolean, endDate?: string, entity?: number, invoiceNumber?: string, limit?: number, offset?: number, q?: string, refNumber?: string, sentStatus?: CoaApiV1InvoiceListSentStatusEnum, sort?: string, startDate?: string, status?: CoaApiV1InvoiceListStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccountingInvoiceListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceList(client, contract, currency, download, endDate, entity, invoiceNumber, limit, offset, q, refNumber, sentStatus, sort, startDate, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a partial update of an existing accounting invoice using PATCH semantics.          This endpoint allows selective modification of invoice fields without requiring         a complete invoice replacement. You can update specific aspects of the invoice while         leaving other fields unchanged.          **Updatable Fields:**         - Invoice metadata (dates, terms, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Contract and purchase order associations         - Exchange rates and currency information         
         * @summary Partial Update Invoice
         * @param {number} id 
         * @param {PatchedAccountingInvoice} [patchedAccountingInvoice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoicePartialUpdate(id: number, patchedAccountingInvoice?: PatchedAccountingInvoice, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoicePartialUpdate(id, patchedAccountingInvoice, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoicePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark an invoice as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply credit memos to reduce the invoice balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - credit_memos: List of credit memos to apply         - empty_transactions: List of manual payments without transactions
         * @summary Mark Invoice as Paid
         * @param {number} invoiceId ID of the invoice to mark as paid
         * @param {MarkPaid} [markPaid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoicePayCreate(invoiceId: number, markPaid?: MarkPaid, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoicePayCreate(invoiceId, markPaid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoicePayCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Void an existing invoice payment.          This creates a reversing journal entry to void the payment and updates the invoice status.         For Stripe payments, this will also process a refund through Stripe.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
         * @summary Void Invoice Payment
         * @param {number} invoiceId ID of the invoice
         * @param {number} paymentId ID of the payment to void
         * @param {VoidPayment} [voidPayment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoicePaymentVoidCreate(invoiceId: number, paymentId: number, voidPayment?: VoidPayment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoicePayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoicePaymentVoidCreate(invoiceId, paymentId, voidPayment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoicePaymentVoidCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an invoice payment.          This removes the payment record and updates the transaction to uncategorized.         For Stripe payments, this will also process a refund through Stripe.
         * @summary Delete Invoice Payment
         * @param {number} invoiceId ID of the invoice
         * @param {number} paymentId ID of the payment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoicePaymentVoidDestroy(invoiceId: number, paymentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoicePaymentVoidDestroy(invoiceId, paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoicePaymentVoidDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reopen a voided invoice.          This removes the void date and void journal entry, and sets the invoice status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Invoice
         * @param {number} invoiceId ID of the voided invoice to reopen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceReopenCreate(invoiceId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceReopenCreate(invoiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceReopenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieves a single accounting invoice with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive invoice information with:         - Complete invoice metadata (dates, amounts, status, terms)         - All associated line items with product details and tax information         - Payment history with journal entry references and transaction details         
         * @summary Retrieve Invoice
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a complete update of an existing accounting invoice using PUT semantics.          This endpoint allows full replacement of invoice data including:         - Complete invoice metadata update (dates, amounts, terms, client, entity)         - Full line item replacement with new products, quantities, rates, and tax calculations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency invoices          **Important Notes:**         - This is a full replacement operation - all invoice data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
         * @summary Update Invoice
         * @param {number} id 
         * @param {AccountingInvoice} accountingInvoice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceUpdate(id: number, accountingInvoice: AccountingInvoice, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceUpdate(id, accountingInvoice, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Void an existing invoice.          This creates a reversing journal entry to void the invoice by reversing all debit and credit amounts.         The invoice status will be updated to reflect the void.
         * @summary Void Invoice
         * @param {number} invoiceId ID of the invoice to void
         * @param {VoidInvoiceRequest} [voidInvoiceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceVoidCreate(invoiceId: number, voidInvoiceRequest?: VoidInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceVoidCreate(invoiceId, voidInvoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.coaApiV1InvoiceVoidCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new product
         * @summary Create Contract Product
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(product?: Product, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Products
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.listProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.rrApiV1ProductDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Product
         * @param {number} id 
         * @param {PatchedProduct} [patchedProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductPartialUpdate(id: number, patchedProduct?: PatchedProduct, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductPartialUpdate(id, patchedProduct, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.rrApiV1ProductPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.rrApiV1ProductRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Product
         * @param {number} id 
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductUpdate(id: number, product?: Product, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductUpdate(id, product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsReceivableApi.rrApiV1ProductUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsReceivableApi - factory interface
 */
export const AccountsReceivableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsReceivableApiFp(configuration)
    return {
        /**
         *      Create multiple invoices atomically in a single transaction.      All invoices are created within a single database transaction. If any invoice creation fails,     all invoices are rolled back and no invoices are created.      This endpoint validates all invoices before creating any of them, ensuring data integrity.     
         * @summary Bulk Create Invoices
         * @param {AccountsReceivableApiBulkCreateInvoicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInvoices(requestParameters: AccountsReceivableApiBulkCreateInvoicesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<AccountingInvoice>> {
            return localVarFp.bulkCreateInvoices(requestParameters.bulkCreateInvoices, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for thousands of credit memos by exact credit memo number match in a single request. Optimized for performance.
         * @summary Bulk Search Credit Memos by Number
         * @param {AccountsReceivableApiCoaApiV1CreditMemoBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoBulkSearchCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.coaApiV1CreditMemoBulkSearchCreate(requestParameters.bulkCreditMemoSearch, options).then((request) => request(axios, basePath));
        },
        /**
         *          Creates a new accounting credit memo with line items and automatic journal entry generation.          This endpoint allows for comprehensive credit memo creation with:         - Multiple line items with different products, accounts, amounts, and departmental allocations         - Automatic journal entry creation following double-entry bookkeeping principles         - Multi-currency support with exchange rate handling         - Client and entity relationship management         - Contract associations for revenue recognition tracking         - Product-based line item categorization with tax handling         - Tag-based transaction categorization and reporting         
         * @summary Create Credit Memo
         * @param {AccountsReceivableApiCoaApiV1CreditMemoCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingCreditMemo> {
            return localVarFp.coaApiV1CreditMemoCreate(requestParameters.accountingCreditMemo, options).then((request) => request(axios, basePath));
        },
        /**
         *          Permanently deletes an accounting credit memo and all associated data from the system.          This endpoint performs a complete removal of the credit memo including:         - Complete credit memo record deletion with all line items         - Automatic journal entry removal and accounting transaction cleanup          **Accounting Impact:**         - Associated journal entries are automatically deleted to maintain accounting integrity         - Exchange rate records and multi-currency data are cleaned up          **Restrictions:**         - Credit memos that have been applied to invoices cannot be deleted         - Credit memos in closed accounting periods may have deletion restrictions         - Consider the impact on historical financial reporting         
         * @summary Delete Credit Memo
         * @param {AccountsReceivableApiCoaApiV1CreditMemoDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoDestroy(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1CreditMemoDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieves a paginated list of accounting credit memos with comprehensive filtering and sorting capabilities.          This endpoint provides a powerful interface for browsing and searching credit memos with:         - Advanced filtering by date ranges, status, clients, entities, and contracts         - Full-text search across credit memo numbers, messages, and client names         - Flexible sorting by multiple fields including amounts and relationships         - Optimized performance with efficient database queries and pagination         - Complete credit memo details including line items, payment status, and accounting relationships          **Key Features:**         - Date range filtering for credit memo creation and application dates         - Status-based filtering (open, partially_used, used, voided)         - Client and entity-based filtering with hierarchical client support         - Contract association filtering for revenue recognition workflows         - Full-text search capabilities across key fields          **Query Parameters:**         - `start_date`, `end_date`: Filter by credit memo date range         - `status`: Filter by application status (open, partially_used, used, voided)         - `q`: Full-text search across credit memo number, message, and client name         - `client`: Filter by specific client IDs (supports multiple values)         - `entity`: Filter by specific entity IDs (supports multiple values)         - `contract`: Filter by specific contract IDs (supports multiple values)         - `sort`: Sort by various fields (credit_memo_date, client_name, total_amount, etc.)         - `limit`, `offset`: Pagination controls for large result sets         
         * @summary List Credit Memos
         * @param {AccountsReceivableApiCoaApiV1CreditMemoListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoList(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccountingCreditMemoList> {
            return localVarFp.coaApiV1CreditMemoList(requestParameters.client, requestParameters.contract, requestParameters.endDate, requestParameters.entity, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.startDate, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a credit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/R to clear the credit memo.         The credit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
         * @summary Mark Credit Memo as Used
         * @param {AccountsReceivableApiCoaApiV1CreditMemoMarkUsedCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoMarkUsedCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoMarkUsedCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.coaApiV1CreditMemoMarkUsedCreate(requestParameters.creditMemoId, requestParameters.markCreditMemoUsed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Next Credit Memo Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoNextCreditMemoNumberRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1CreditMemoNextCreditMemoNumberRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a partial update of an existing accounting credit memo using PATCH semantics.          This endpoint allows selective modification of credit memo fields without requiring         a complete credit memo replacement. You can update specific aspects of the credit memo while         leaving other fields unchanged.          **Updatable Fields:**         - Credit memo metadata (dates, messages, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Reference numbers and contract associations         - Exchange rates and currency information         - Custom fields and additional metadata         - Application status and tracking information         
         * @summary Partial Update Credit Memo
         * @param {AccountsReceivableApiCoaApiV1CreditMemoPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoPartialUpdate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingCreditMemo> {
            return localVarFp.coaApiV1CreditMemoPartialUpdate(requestParameters.id, requestParameters.patchedAccountingCreditMemo, options).then((request) => request(axios, basePath));
        },
        /**
         * Reopen a voided credit memo.          This removes the void date and void journal entry, and sets the credit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Credit Memo
         * @param {AccountsReceivableApiCoaApiV1CreditMemoReopenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoReopenCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoReopenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingCreditMemo> {
            return localVarFp.coaApiV1CreditMemoReopenCreate(requestParameters.creditMemoId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieves a single accounting credit memo with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive credit memo information with:         - Complete credit memo metadata (dates, amounts, status, currency, terms)         - All associated line items with product details, account information, and departmental allocations         - Payment application history with journal entry references and transaction details         - Client and entity information with relationship details         - Contract associations for revenue recognition and reporting         - File attachments and supporting documentation         - Journal entry references for accounting audit trails and compliance         
         * @summary Retrieve Credit Memo
         * @param {AccountsReceivableApiCoaApiV1CreditMemoRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoRetrieve(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingCreditMemo> {
            return localVarFp.coaApiV1CreditMemoRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a complete update of an existing accounting credit memo using PUT semantics.          This endpoint allows full replacement of credit memo data including:         - Complete credit memo metadata update (dates, amounts, client, entity, currency)         - Full line item replacement with new products, accounts, amounts, and departmental allocations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency credit memos         - Contract and reference number association updates         - Custom field updates and modifications          **Important Notes:**         - This is a full replacement operation - all credit memo data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
         * @summary Update Credit Memo
         * @param {AccountsReceivableApiCoaApiV1CreditMemoUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoUpdate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingCreditMemo> {
            return localVarFp.coaApiV1CreditMemoUpdate(requestParameters.id, requestParameters.accountingCreditMemo, options).then((request) => request(axios, basePath));
        },
        /**
         * Void an existing credit memo.          This creates a reversing journal entry to void the credit memo by reversing all debit and credit amounts.         The credit memo status will be updated to reflect the void.
         * @summary Void Credit Memo
         * @param {AccountsReceivableApiCoaApiV1CreditMemoVoidCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoVoidCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoVoidCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingCreditMemo> {
            return localVarFp.coaApiV1CreditMemoVoidCreate(requestParameters.creditMemoId, requestParameters.voidCreditMemoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply a single transaction payment to multiple selected invoices.  Supports two selection modes: - Explicit invoice IDs (``invoice_ids``) - Filter-based selection (``filters``) for \"select all matching\" behaviour  Reuses :meth:`MarkInvoicePaidView.apply_transaction_payment` so that line-level payment splitting, FX gain/loss realisation, and transaction cleanup are all respected.  A single ``DraftQueue`` is created when approval is required.
         * @summary Bulk Apply Transaction Payment to Selected Invoices
         * @param {AccountsReceivableApiCoaApiV1InvoiceBulkApplyPaymentCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceBulkApplyPaymentCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceBulkApplyPaymentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.coaApiV1InvoiceBulkApplyPaymentCreate(requestParameters.bulkApplyInvoicePayment, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for thousands of invoices by exact invoice number match in a single request. Optimized for performance.
         * @summary Bulk Search Invoices by Number
         * @param {AccountsReceivableApiCoaApiV1InvoiceBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceBulkSearchCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.coaApiV1InvoiceBulkSearchCreate(requestParameters.bulkInvoiceSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculate the payment details for an invoice.          This endpoint calculates:         - Total amount due on the invoice         - Applied payments (existing + proposed)         - Applied credits (existing + proposed credit memos)         - Payment term discounts (based on payment dates) - ALL OR NOTHING: discount only applies if paying full invoice         - Remaining balance due          Supports payment terms with early payment discounts (all-or-nothing).         
         * @summary Calculate Invoice Payment
         * @param {AccountsReceivableApiCoaApiV1InvoiceCalculatePaymentCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceCalculatePaymentCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceCalculatePaymentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CalculatePaymentOutput> {
            return localVarFp.coaApiV1InvoiceCalculatePaymentCreate(requestParameters.invoiceId, requestParameters.calculatePaymentInput, options).then((request) => request(axios, basePath));
        },
        /**
         *          Creates a new accounting invoice with line items and automatic journal entry generation.          This endpoint allows for comprehensive invoice creation with:         - Multiple line items with different products, rates, quantities, and tax handling         - Automatic accounts receivable journal entry creation         - Tax calculations and tax account handling         - Multi-currency support with exchange rate handling         - Product-based taxation rules         - Service date tracking for revenue recognition         - Contract and purchase order integration         - Stripe payment integration support          Key features:         - Credits revenue accounts for each line item amount         - Debits accounts receivable for the total amount         - Handles tax calculations with appropriate tax accounts         - Supports entity-specific currency conversions         - Creates proper double-entry accounting transactions         - Validates client, entity, and product relationships         - Integrates with Stripe for payment processing          Requirements:         - All referenced products, clients, and entities must exist and be active         - Client must be of type \'customer\'         - Line items must have valid amounts, quantities, and rates         - Currency must be valid for the entity         - Tax calculations must comply with configured tax rules         
         * @summary Create Invoice
         * @param {AccountsReceivableApiCoaApiV1InvoiceCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoice> {
            return localVarFp.coaApiV1InvoiceCreate(requestParameters.accountingInvoice, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the default payment amount for an invoice based on when payment is posted.          If the invoice has discount terms and the posted date is within the discount period,         the discounted amount is returned. Otherwise, the full amount is returned.         
         * @summary Get Default Payment Amount
         * @param {AccountsReceivableApiCoaApiV1InvoiceDefaultPaymentCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceDefaultPaymentCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceDefaultPaymentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetDefaultPaymentOutput> {
            return localVarFp.coaApiV1InvoiceDefaultPaymentCreate(requestParameters.invoiceId, requestParameters.getDefaultPaymentInput, options).then((request) => request(axios, basePath));
        },
        /**
         *          Permanently deletes an accounting invoice and its associated journal entry and related data.          This endpoint performs a complete deletion of the invoice including:         - Removal of all invoice line items and associated product data         - Deletion of the corresponding accounts receivable journal entry         - Removal of payment records and journal entries          **Important Notes:**         - This operation is irreversible and permanently removes the invoice from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity          **Restrictions:**         - Invoices in closed accounting periods cannot be deleted         - Consider the impact on historical financial reporting         
         * @summary Delete Invoice
         * @param {AccountsReceivableApiCoaApiV1InvoiceDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceDestroy(requestParameters: AccountsReceivableApiCoaApiV1InvoiceDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1InvoiceDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a paginated list of invoices with comprehensive filtering, sorting, and download capabilities.          This endpoint provides powerful invoice listing with:         - Advanced filtering by date ranges, status, clients, and entities         - Full-text search across multiple fields         - Flexible sorting options including custom calculated fields         - Async CSV export functionality via email         - Optimized queries with prefetched relationships          **Filtering Options:**         - Date-based filtering (invoice_date, due_date ranges)         - Status-based filtering (payment status, sent status, aging buckets)         - Entity and client-based filtering (supports multiple selections)         - Contract and currency filtering         - Full-text search across invoice numbers, addresses, messages, and client names          **Sorting Capabilities:**         - Standard field sorting (invoice_date, total_amount, due_date, etc.)         - Custom calculated field sorting (amount_due, client_name, contract_name)         - Ascending/descending order with null handling          **Performance Features:**         - Efficient database queries with proper indexing         - Prefetched related objects (lines, payments, clients, entities)         - Pagination support for large datasets         - Optimized for high-volume invoice management          **Export Functionality:**         - Async CSV generation and email delivery         - Filtered export based on current query parameters         - Background processing to handle large datasets         
         * @summary List Invoices
         * @param {AccountsReceivableApiCoaApiV1InvoiceListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceList(requestParameters: AccountsReceivableApiCoaApiV1InvoiceListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAccountingInvoiceListList> {
            return localVarFp.coaApiV1InvoiceList(requestParameters.client, requestParameters.contract, requestParameters.currency, requestParameters.download, requestParameters.endDate, requestParameters.entity, requestParameters.invoiceNumber, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.refNumber, requestParameters.sentStatus, requestParameters.sort, requestParameters.startDate, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a partial update of an existing accounting invoice using PATCH semantics.          This endpoint allows selective modification of invoice fields without requiring         a complete invoice replacement. You can update specific aspects of the invoice while         leaving other fields unchanged.          **Updatable Fields:**         - Invoice metadata (dates, terms, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Contract and purchase order associations         - Exchange rates and currency information         
         * @summary Partial Update Invoice
         * @param {AccountsReceivableApiCoaApiV1InvoicePartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePartialUpdate(requestParameters: AccountsReceivableApiCoaApiV1InvoicePartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoice> {
            return localVarFp.coaApiV1InvoicePartialUpdate(requestParameters.id, requestParameters.patchedAccountingInvoice, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark an invoice as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply credit memos to reduce the invoice balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - credit_memos: List of credit memos to apply         - empty_transactions: List of manual payments without transactions
         * @summary Mark Invoice as Paid
         * @param {AccountsReceivableApiCoaApiV1InvoicePayCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePayCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoicePayCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoice> {
            return localVarFp.coaApiV1InvoicePayCreate(requestParameters.invoiceId, requestParameters.markPaid, options).then((request) => request(axios, basePath));
        },
        /**
         * Void an existing invoice payment.          This creates a reversing journal entry to void the payment and updates the invoice status.         For Stripe payments, this will also process a refund through Stripe.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
         * @summary Void Invoice Payment
         * @param {AccountsReceivableApiCoaApiV1InvoicePaymentVoidCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePaymentVoidCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoicePaymentVoidCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoicePayment> {
            return localVarFp.coaApiV1InvoicePaymentVoidCreate(requestParameters.invoiceId, requestParameters.paymentId, requestParameters.voidPayment, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an invoice payment.          This removes the payment record and updates the transaction to uncategorized.         For Stripe payments, this will also process a refund through Stripe.
         * @summary Delete Invoice Payment
         * @param {AccountsReceivableApiCoaApiV1InvoicePaymentVoidDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoicePaymentVoidDestroy(requestParameters: AccountsReceivableApiCoaApiV1InvoicePaymentVoidDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1InvoicePaymentVoidDestroy(requestParameters.invoiceId, requestParameters.paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reopen a voided invoice.          This removes the void date and void journal entry, and sets the invoice status back to open.         The voiding journal entry will be deleted to reverse the void operation.
         * @summary Reopen Voided Invoice
         * @param {AccountsReceivableApiCoaApiV1InvoiceReopenCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceReopenCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceReopenCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoice> {
            return localVarFp.coaApiV1InvoiceReopenCreate(requestParameters.invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieves a single accounting invoice with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive invoice information with:         - Complete invoice metadata (dates, amounts, status, terms)         - All associated line items with product details and tax information         - Payment history with journal entry references and transaction details         
         * @summary Retrieve Invoice
         * @param {AccountsReceivableApiCoaApiV1InvoiceRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceRetrieve(requestParameters: AccountsReceivableApiCoaApiV1InvoiceRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoice> {
            return localVarFp.coaApiV1InvoiceRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a complete update of an existing accounting invoice using PUT semantics.          This endpoint allows full replacement of invoice data including:         - Complete invoice metadata update (dates, amounts, terms, client, entity)         - Full line item replacement with new products, quantities, rates, and tax calculations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency invoices          **Important Notes:**         - This is a full replacement operation - all invoice data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
         * @summary Update Invoice
         * @param {AccountsReceivableApiCoaApiV1InvoiceUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceUpdate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoice> {
            return localVarFp.coaApiV1InvoiceUpdate(requestParameters.id, requestParameters.accountingInvoice, options).then((request) => request(axios, basePath));
        },
        /**
         * Void an existing invoice.          This creates a reversing journal entry to void the invoice by reversing all debit and credit amounts.         The invoice status will be updated to reflect the void.
         * @summary Void Invoice
         * @param {AccountsReceivableApiCoaApiV1InvoiceVoidCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceVoidCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceVoidCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountingInvoice> {
            return localVarFp.coaApiV1InvoiceVoidCreate(requestParameters.invoiceId, requestParameters.voidInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new product
         * @summary Create Contract Product
         * @param {AccountsReceivableApiCreateProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(requestParameters: AccountsReceivableApiCreateProductRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.createProduct(requestParameters.product, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Products
         * @param {AccountsReceivableApiListProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(requestParameters: AccountsReceivableApiListProductsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProductList> {
            return localVarFp.listProducts(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Product
         * @param {AccountsReceivableApiRrApiV1ProductDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductDestroy(requestParameters: AccountsReceivableApiRrApiV1ProductDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ProductDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Product
         * @param {AccountsReceivableApiRrApiV1ProductPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductPartialUpdate(requestParameters: AccountsReceivableApiRrApiV1ProductPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.rrApiV1ProductPartialUpdate(requestParameters.id, requestParameters.patchedProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Product
         * @param {AccountsReceivableApiRrApiV1ProductRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductRetrieve(requestParameters: AccountsReceivableApiRrApiV1ProductRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.rrApiV1ProductRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Product
         * @param {AccountsReceivableApiRrApiV1ProductUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductUpdate(requestParameters: AccountsReceivableApiRrApiV1ProductUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.rrApiV1ProductUpdate(requestParameters.id, requestParameters.product, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkCreateInvoices operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiBulkCreateInvoicesRequest {
    readonly bulkCreateInvoices: BulkCreateInvoices
}

/**
 * Request parameters for coaApiV1CreditMemoBulkSearchCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoBulkSearchCreateRequest {
    readonly bulkCreditMemoSearch: BulkCreditMemoSearch
}

/**
 * Request parameters for coaApiV1CreditMemoCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoCreateRequest {
    readonly accountingCreditMemo: AccountingCreditMemo
}

/**
 * Request parameters for coaApiV1CreditMemoDestroy operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1CreditMemoList operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoListRequest {
    /**
     * Filter by client IDs (can specify multiple)
     */
    readonly client?: Array<number>

    /**
     * Filter by contract IDs (can specify multiple)
     */
    readonly contract?: Array<number>

    /**
     * Filter credit memos created on or before this date (YYYY-MM-DD format)
     */
    readonly endDate?: string

    /**
     * Filter by entity IDs (can specify multiple)
     */
    readonly entity?: Array<number>

    /**
     * Number of results to return per page
     */
    readonly limit?: number

    /**
     * Number of results to skip for pagination
     */
    readonly offset?: number

    /**
     * Search credit memo numbers, messages, and client names
     */
    readonly q?: string

    /**
     * Sort results by field (prefix with - for descending)
     */
    readonly sort?: CoaApiV1CreditMemoListSortEnum

    /**
     * Filter credit memos created on or after this date (YYYY-MM-DD format)
     */
    readonly startDate?: string

    /**
     * Filter by application status
     */
    readonly status?: CoaApiV1CreditMemoListStatusEnum
}

/**
 * Request parameters for coaApiV1CreditMemoMarkUsedCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoMarkUsedCreateRequest {
    /**
     * ID of the credit memo to mark as used
     */
    readonly creditMemoId: number

    readonly markCreditMemoUsed: MarkCreditMemoUsed
}

/**
 * Request parameters for coaApiV1CreditMemoPartialUpdate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoPartialUpdateRequest {
    readonly id: number

    readonly patchedAccountingCreditMemo?: PatchedAccountingCreditMemo
}

/**
 * Request parameters for coaApiV1CreditMemoReopenCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoReopenCreateRequest {
    /**
     * ID of the voided credit memo to reopen
     */
    readonly creditMemoId: number
}

/**
 * Request parameters for coaApiV1CreditMemoRetrieve operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1CreditMemoUpdate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoUpdateRequest {
    readonly id: number

    readonly accountingCreditMemo: AccountingCreditMemo
}

/**
 * Request parameters for coaApiV1CreditMemoVoidCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1CreditMemoVoidCreateRequest {
    /**
     * ID of the credit memo to void
     */
    readonly creditMemoId: number

    readonly voidCreditMemoRequest: VoidCreditMemoRequest
}

/**
 * Request parameters for coaApiV1InvoiceBulkApplyPaymentCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceBulkApplyPaymentCreateRequest {
    readonly bulkApplyInvoicePayment: BulkApplyInvoicePayment
}

/**
 * Request parameters for coaApiV1InvoiceBulkSearchCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceBulkSearchCreateRequest {
    readonly bulkInvoiceSearch: BulkInvoiceSearch
}

/**
 * Request parameters for coaApiV1InvoiceCalculatePaymentCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceCalculatePaymentCreateRequest {
    /**
     * ID of the invoice
     */
    readonly invoiceId: number

    readonly calculatePaymentInput?: CalculatePaymentInput
}

/**
 * Request parameters for coaApiV1InvoiceCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceCreateRequest {
    readonly accountingInvoice: AccountingInvoice
}

/**
 * Request parameters for coaApiV1InvoiceDefaultPaymentCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceDefaultPaymentCreateRequest {
    /**
     * ID of the invoice
     */
    readonly invoiceId: number

    readonly getDefaultPaymentInput: GetDefaultPaymentInput
}

/**
 * Request parameters for coaApiV1InvoiceDestroy operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1InvoiceList operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceListRequest {
    /**
     * Filter by client ID. Can be specified multiple times
     */
    readonly client?: number

    /**
     * Filter by contract ID
     */
    readonly contract?: number

    /**
     * Filter by currency code (e.g., USD, EUR)
     */
    readonly currency?: string

    /**
     * If true, triggers async CSV download workflow and sends result via email
     */
    readonly download?: boolean

    /**
     * Filter invoices with invoice_date on or before this date (YYYY-MM-DD)
     */
    readonly endDate?: string

    /**
     * Filter by entity ID. Can be specified multiple times
     */
    readonly entity?: number

    /**
     * Filter by exact invoice number
     */
    readonly invoiceNumber?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search query - searches shipping address, invoice number, message, or client name
     */
    readonly q?: string

    /**
     * Filter by exact ref number
     */
    readonly refNumber?: string

    /**
     * Filter by sent status
     */
    readonly sentStatus?: CoaApiV1InvoiceListSentStatusEnum

    /**
     * Sort order. Use field name for ascending, -field for descending. Special fields: client_name, amount_due. Default: -invoice_date
     */
    readonly sort?: string

    /**
     * Filter invoices with invoice_date on or after this date (YYYY-MM-DD)
     */
    readonly startDate?: string

    /**
     * Filter by payment status
     */
    readonly status?: CoaApiV1InvoiceListStatusEnum
}

/**
 * Request parameters for coaApiV1InvoicePartialUpdate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoicePartialUpdateRequest {
    readonly id: number

    readonly patchedAccountingInvoice?: PatchedAccountingInvoice
}

/**
 * Request parameters for coaApiV1InvoicePayCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoicePayCreateRequest {
    /**
     * ID of the invoice to mark as paid
     */
    readonly invoiceId: number

    readonly markPaid?: MarkPaid
}

/**
 * Request parameters for coaApiV1InvoicePaymentVoidCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoicePaymentVoidCreateRequest {
    /**
     * ID of the invoice
     */
    readonly invoiceId: number

    /**
     * ID of the payment to void
     */
    readonly paymentId: number

    readonly voidPayment?: VoidPayment
}

/**
 * Request parameters for coaApiV1InvoicePaymentVoidDestroy operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoicePaymentVoidDestroyRequest {
    /**
     * ID of the invoice
     */
    readonly invoiceId: number

    /**
     * ID of the payment to delete
     */
    readonly paymentId: number
}

/**
 * Request parameters for coaApiV1InvoiceReopenCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceReopenCreateRequest {
    /**
     * ID of the voided invoice to reopen
     */
    readonly invoiceId: number
}

/**
 * Request parameters for coaApiV1InvoiceRetrieve operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1InvoiceUpdate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceUpdateRequest {
    readonly id: number

    readonly accountingInvoice: AccountingInvoice
}

/**
 * Request parameters for coaApiV1InvoiceVoidCreate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCoaApiV1InvoiceVoidCreateRequest {
    /**
     * ID of the invoice to void
     */
    readonly invoiceId: number

    readonly voidInvoiceRequest?: VoidInvoiceRequest
}

/**
 * Request parameters for createProduct operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiCreateProductRequest {
    readonly product?: Product
}

/**
 * Request parameters for listProducts operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiListProductsRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for rrApiV1ProductDestroy operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiRrApiV1ProductDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ProductPartialUpdate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiRrApiV1ProductPartialUpdateRequest {
    readonly id: number

    readonly patchedProduct?: PatchedProduct
}

/**
 * Request parameters for rrApiV1ProductRetrieve operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiRrApiV1ProductRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ProductUpdate operation in AccountsReceivableApi.
 */
export interface AccountsReceivableApiRrApiV1ProductUpdateRequest {
    readonly id: number

    readonly product?: Product
}

/**
 * AccountsReceivableApi - object-oriented interface
 */
export class AccountsReceivableApi extends BaseAPI {
    /**
     *      Create multiple invoices atomically in a single transaction.      All invoices are created within a single database transaction. If any invoice creation fails,     all invoices are rolled back and no invoices are created.      This endpoint validates all invoices before creating any of them, ensuring data integrity.     
     * @summary Bulk Create Invoices
     * @param {AccountsReceivableApiBulkCreateInvoicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkCreateInvoices(requestParameters: AccountsReceivableApiBulkCreateInvoicesRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).bulkCreateInvoices(requestParameters.bulkCreateInvoices, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for thousands of credit memos by exact credit memo number match in a single request. Optimized for performance.
     * @summary Bulk Search Credit Memos by Number
     * @param {AccountsReceivableApiCoaApiV1CreditMemoBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoBulkSearchCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoBulkSearchCreate(requestParameters.bulkCreditMemoSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Creates a new accounting credit memo with line items and automatic journal entry generation.          This endpoint allows for comprehensive credit memo creation with:         - Multiple line items with different products, accounts, amounts, and departmental allocations         - Automatic journal entry creation following double-entry bookkeeping principles         - Multi-currency support with exchange rate handling         - Client and entity relationship management         - Contract associations for revenue recognition tracking         - Product-based line item categorization with tax handling         - Tag-based transaction categorization and reporting         
     * @summary Create Credit Memo
     * @param {AccountsReceivableApiCoaApiV1CreditMemoCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoCreate(requestParameters.accountingCreditMemo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Permanently deletes an accounting credit memo and all associated data from the system.          This endpoint performs a complete removal of the credit memo including:         - Complete credit memo record deletion with all line items         - Automatic journal entry removal and accounting transaction cleanup          **Accounting Impact:**         - Associated journal entries are automatically deleted to maintain accounting integrity         - Exchange rate records and multi-currency data are cleaned up          **Restrictions:**         - Credit memos that have been applied to invoices cannot be deleted         - Credit memos in closed accounting periods may have deletion restrictions         - Consider the impact on historical financial reporting         
     * @summary Delete Credit Memo
     * @param {AccountsReceivableApiCoaApiV1CreditMemoDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoDestroy(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoDestroyRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieves a paginated list of accounting credit memos with comprehensive filtering and sorting capabilities.          This endpoint provides a powerful interface for browsing and searching credit memos with:         - Advanced filtering by date ranges, status, clients, entities, and contracts         - Full-text search across credit memo numbers, messages, and client names         - Flexible sorting by multiple fields including amounts and relationships         - Optimized performance with efficient database queries and pagination         - Complete credit memo details including line items, payment status, and accounting relationships          **Key Features:**         - Date range filtering for credit memo creation and application dates         - Status-based filtering (open, partially_used, used, voided)         - Client and entity-based filtering with hierarchical client support         - Contract association filtering for revenue recognition workflows         - Full-text search capabilities across key fields          **Query Parameters:**         - `start_date`, `end_date`: Filter by credit memo date range         - `status`: Filter by application status (open, partially_used, used, voided)         - `q`: Full-text search across credit memo number, message, and client name         - `client`: Filter by specific client IDs (supports multiple values)         - `entity`: Filter by specific entity IDs (supports multiple values)         - `contract`: Filter by specific contract IDs (supports multiple values)         - `sort`: Sort by various fields (credit_memo_date, client_name, total_amount, etc.)         - `limit`, `offset`: Pagination controls for large result sets         
     * @summary List Credit Memos
     * @param {AccountsReceivableApiCoaApiV1CreditMemoListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoList(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoListRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoList(requestParameters.client, requestParameters.contract, requestParameters.endDate, requestParameters.entity, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.startDate, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a credit memo as used by linking to an existing transaction.          The transaction\'s debit amount will be recategorized to A/R to clear the credit memo.         The credit memo\'s status will be updated to \"used\" or \"partially_used\" based on         the amount applied vs the total amount.
     * @summary Mark Credit Memo as Used
     * @param {AccountsReceivableApiCoaApiV1CreditMemoMarkUsedCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoMarkUsedCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoMarkUsedCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoMarkUsedCreate(requestParameters.creditMemoId, requestParameters.markCreditMemoUsed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Next Credit Memo Number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoNextCreditMemoNumberRetrieve(options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoNextCreditMemoNumberRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a partial update of an existing accounting credit memo using PATCH semantics.          This endpoint allows selective modification of credit memo fields without requiring         a complete credit memo replacement. You can update specific aspects of the credit memo while         leaving other fields unchanged.          **Updatable Fields:**         - Credit memo metadata (dates, messages, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Reference numbers and contract associations         - Exchange rates and currency information         - Custom fields and additional metadata         - Application status and tracking information         
     * @summary Partial Update Credit Memo
     * @param {AccountsReceivableApiCoaApiV1CreditMemoPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoPartialUpdate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoPartialUpdate(requestParameters.id, requestParameters.patchedAccountingCreditMemo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reopen a voided credit memo.          This removes the void date and void journal entry, and sets the credit memo status back to open.         The voiding journal entry will be deleted to reverse the void operation.
     * @summary Reopen Voided Credit Memo
     * @param {AccountsReceivableApiCoaApiV1CreditMemoReopenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoReopenCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoReopenCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoReopenCreate(requestParameters.creditMemoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieves a single accounting credit memo with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive credit memo information with:         - Complete credit memo metadata (dates, amounts, status, currency, terms)         - All associated line items with product details, account information, and departmental allocations         - Payment application history with journal entry references and transaction details         - Client and entity information with relationship details         - Contract associations for revenue recognition and reporting         - File attachments and supporting documentation         - Journal entry references for accounting audit trails and compliance         
     * @summary Retrieve Credit Memo
     * @param {AccountsReceivableApiCoaApiV1CreditMemoRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoRetrieve(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoRetrieveRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a complete update of an existing accounting credit memo using PUT semantics.          This endpoint allows full replacement of credit memo data including:         - Complete credit memo metadata update (dates, amounts, client, entity, currency)         - Full line item replacement with new products, accounts, amounts, and departmental allocations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency credit memos         - Contract and reference number association updates         - Custom field updates and modifications          **Important Notes:**         - This is a full replacement operation - all credit memo data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
     * @summary Update Credit Memo
     * @param {AccountsReceivableApiCoaApiV1CreditMemoUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoUpdate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoUpdate(requestParameters.id, requestParameters.accountingCreditMemo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void an existing credit memo.          This creates a reversing journal entry to void the credit memo by reversing all debit and credit amounts.         The credit memo status will be updated to reflect the void.
     * @summary Void Credit Memo
     * @param {AccountsReceivableApiCoaApiV1CreditMemoVoidCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoVoidCreate(requestParameters: AccountsReceivableApiCoaApiV1CreditMemoVoidCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1CreditMemoVoidCreate(requestParameters.creditMemoId, requestParameters.voidCreditMemoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply a single transaction payment to multiple selected invoices.  Supports two selection modes: - Explicit invoice IDs (``invoice_ids``) - Filter-based selection (``filters``) for \"select all matching\" behaviour  Reuses :meth:`MarkInvoicePaidView.apply_transaction_payment` so that line-level payment splitting, FX gain/loss realisation, and transaction cleanup are all respected.  A single ``DraftQueue`` is created when approval is required.
     * @summary Bulk Apply Transaction Payment to Selected Invoices
     * @param {AccountsReceivableApiCoaApiV1InvoiceBulkApplyPaymentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceBulkApplyPaymentCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceBulkApplyPaymentCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceBulkApplyPaymentCreate(requestParameters.bulkApplyInvoicePayment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for thousands of invoices by exact invoice number match in a single request. Optimized for performance.
     * @summary Bulk Search Invoices by Number
     * @param {AccountsReceivableApiCoaApiV1InvoiceBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceBulkSearchCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceBulkSearchCreate(requestParameters.bulkInvoiceSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculate the payment details for an invoice.          This endpoint calculates:         - Total amount due on the invoice         - Applied payments (existing + proposed)         - Applied credits (existing + proposed credit memos)         - Payment term discounts (based on payment dates) - ALL OR NOTHING: discount only applies if paying full invoice         - Remaining balance due          Supports payment terms with early payment discounts (all-or-nothing).         
     * @summary Calculate Invoice Payment
     * @param {AccountsReceivableApiCoaApiV1InvoiceCalculatePaymentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceCalculatePaymentCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceCalculatePaymentCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceCalculatePaymentCreate(requestParameters.invoiceId, requestParameters.calculatePaymentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Creates a new accounting invoice with line items and automatic journal entry generation.          This endpoint allows for comprehensive invoice creation with:         - Multiple line items with different products, rates, quantities, and tax handling         - Automatic accounts receivable journal entry creation         - Tax calculations and tax account handling         - Multi-currency support with exchange rate handling         - Product-based taxation rules         - Service date tracking for revenue recognition         - Contract and purchase order integration         - Stripe payment integration support          Key features:         - Credits revenue accounts for each line item amount         - Debits accounts receivable for the total amount         - Handles tax calculations with appropriate tax accounts         - Supports entity-specific currency conversions         - Creates proper double-entry accounting transactions         - Validates client, entity, and product relationships         - Integrates with Stripe for payment processing          Requirements:         - All referenced products, clients, and entities must exist and be active         - Client must be of type \'customer\'         - Line items must have valid amounts, quantities, and rates         - Currency must be valid for the entity         - Tax calculations must comply with configured tax rules         
     * @summary Create Invoice
     * @param {AccountsReceivableApiCoaApiV1InvoiceCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceCreate(requestParameters.accountingInvoice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the default payment amount for an invoice based on when payment is posted.          If the invoice has discount terms and the posted date is within the discount period,         the discounted amount is returned. Otherwise, the full amount is returned.         
     * @summary Get Default Payment Amount
     * @param {AccountsReceivableApiCoaApiV1InvoiceDefaultPaymentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceDefaultPaymentCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceDefaultPaymentCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceDefaultPaymentCreate(requestParameters.invoiceId, requestParameters.getDefaultPaymentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Permanently deletes an accounting invoice and its associated journal entry and related data.          This endpoint performs a complete deletion of the invoice including:         - Removal of all invoice line items and associated product data         - Deletion of the corresponding accounts receivable journal entry         - Removal of payment records and journal entries          **Important Notes:**         - This operation is irreversible and permanently removes the invoice from the system         - The associated journal entry will be automatically deleted to maintain accounting integrity          **Restrictions:**         - Invoices in closed accounting periods cannot be deleted         - Consider the impact on historical financial reporting         
     * @summary Delete Invoice
     * @param {AccountsReceivableApiCoaApiV1InvoiceDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceDestroy(requestParameters: AccountsReceivableApiCoaApiV1InvoiceDestroyRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a paginated list of invoices with comprehensive filtering, sorting, and download capabilities.          This endpoint provides powerful invoice listing with:         - Advanced filtering by date ranges, status, clients, and entities         - Full-text search across multiple fields         - Flexible sorting options including custom calculated fields         - Async CSV export functionality via email         - Optimized queries with prefetched relationships          **Filtering Options:**         - Date-based filtering (invoice_date, due_date ranges)         - Status-based filtering (payment status, sent status, aging buckets)         - Entity and client-based filtering (supports multiple selections)         - Contract and currency filtering         - Full-text search across invoice numbers, addresses, messages, and client names          **Sorting Capabilities:**         - Standard field sorting (invoice_date, total_amount, due_date, etc.)         - Custom calculated field sorting (amount_due, client_name, contract_name)         - Ascending/descending order with null handling          **Performance Features:**         - Efficient database queries with proper indexing         - Prefetched related objects (lines, payments, clients, entities)         - Pagination support for large datasets         - Optimized for high-volume invoice management          **Export Functionality:**         - Async CSV generation and email delivery         - Filtered export based on current query parameters         - Background processing to handle large datasets         
     * @summary List Invoices
     * @param {AccountsReceivableApiCoaApiV1InvoiceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceList(requestParameters: AccountsReceivableApiCoaApiV1InvoiceListRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceList(requestParameters.client, requestParameters.contract, requestParameters.currency, requestParameters.download, requestParameters.endDate, requestParameters.entity, requestParameters.invoiceNumber, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.refNumber, requestParameters.sentStatus, requestParameters.sort, requestParameters.startDate, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a partial update of an existing accounting invoice using PATCH semantics.          This endpoint allows selective modification of invoice fields without requiring         a complete invoice replacement. You can update specific aspects of the invoice while         leaving other fields unchanged.          **Updatable Fields:**         - Invoice metadata (dates, terms, descriptions, client, entity, currency)         - Line items (amounts, accounts, descriptions, departments, products)         - Payment terms and due dates         - Tax calculations and allocations         - Custom fields and tags         - Contract and purchase order associations         - Exchange rates and currency information         
     * @summary Partial Update Invoice
     * @param {AccountsReceivableApiCoaApiV1InvoicePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoicePartialUpdate(requestParameters: AccountsReceivableApiCoaApiV1InvoicePartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoicePartialUpdate(requestParameters.id, requestParameters.patchedAccountingInvoice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark an invoice as paid, allowing partial payments.          This endpoint supports multiple payment methods:         - Apply existing transactions as payments         - Apply credit memos to reduce the invoice balance         - Create manual payments without a transaction          The request body should contain at least one of:         - transactions: List of transaction payments to apply         - credit_memos: List of credit memos to apply         - empty_transactions: List of manual payments without transactions
     * @summary Mark Invoice as Paid
     * @param {AccountsReceivableApiCoaApiV1InvoicePayCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoicePayCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoicePayCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoicePayCreate(requestParameters.invoiceId, requestParameters.markPaid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void an existing invoice payment.          This creates a reversing journal entry to void the payment and updates the invoice status.         For Stripe payments, this will also process a refund through Stripe.          Optionally accepts a void_date in the request body to specify when the payment should be voided.         If not provided, defaults to today\'s date.
     * @summary Void Invoice Payment
     * @param {AccountsReceivableApiCoaApiV1InvoicePaymentVoidCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoicePaymentVoidCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoicePaymentVoidCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoicePaymentVoidCreate(requestParameters.invoiceId, requestParameters.paymentId, requestParameters.voidPayment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an invoice payment.          This removes the payment record and updates the transaction to uncategorized.         For Stripe payments, this will also process a refund through Stripe.
     * @summary Delete Invoice Payment
     * @param {AccountsReceivableApiCoaApiV1InvoicePaymentVoidDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoicePaymentVoidDestroy(requestParameters: AccountsReceivableApiCoaApiV1InvoicePaymentVoidDestroyRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoicePaymentVoidDestroy(requestParameters.invoiceId, requestParameters.paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reopen a voided invoice.          This removes the void date and void journal entry, and sets the invoice status back to open.         The voiding journal entry will be deleted to reverse the void operation.
     * @summary Reopen Voided Invoice
     * @param {AccountsReceivableApiCoaApiV1InvoiceReopenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceReopenCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceReopenCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceReopenCreate(requestParameters.invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieves a single accounting invoice with complete details including line items, payments, and accounting relationships.          This endpoint provides comprehensive invoice information with:         - Complete invoice metadata (dates, amounts, status, terms)         - All associated line items with product details and tax information         - Payment history with journal entry references and transaction details         
     * @summary Retrieve Invoice
     * @param {AccountsReceivableApiCoaApiV1InvoiceRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceRetrieve(requestParameters: AccountsReceivableApiCoaApiV1InvoiceRetrieveRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a complete update of an existing accounting invoice using PUT semantics.          This endpoint allows full replacement of invoice data including:         - Complete invoice metadata update (dates, amounts, terms, client, entity)         - Full line item replacement with new products, quantities, rates, and tax calculations         - Journal entry recalculation and update with new accounting transactions         - Exchange rate updates for multi-currency invoices          **Important Notes:**         - This is a full replacement operation - all invoice data will be updated         - Missing fields in the request will be set to null or default values         - Existing line items will be completely replaced with the new line items         - Journal entries will be updated to reflect all changes         
     * @summary Update Invoice
     * @param {AccountsReceivableApiCoaApiV1InvoiceUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceUpdate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceUpdate(requestParameters.id, requestParameters.accountingInvoice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void an existing invoice.          This creates a reversing journal entry to void the invoice by reversing all debit and credit amounts.         The invoice status will be updated to reflect the void.
     * @summary Void Invoice
     * @param {AccountsReceivableApiCoaApiV1InvoiceVoidCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceVoidCreate(requestParameters: AccountsReceivableApiCoaApiV1InvoiceVoidCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).coaApiV1InvoiceVoidCreate(requestParameters.invoiceId, requestParameters.voidInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new product
     * @summary Create Contract Product
     * @param {AccountsReceivableApiCreateProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProduct(requestParameters: AccountsReceivableApiCreateProductRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).createProduct(requestParameters.product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Contract Products
     * @param {AccountsReceivableApiListProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProducts(requestParameters: AccountsReceivableApiListProductsRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).listProducts(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Product
     * @param {AccountsReceivableApiRrApiV1ProductDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductDestroy(requestParameters: AccountsReceivableApiRrApiV1ProductDestroyRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).rrApiV1ProductDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Product
     * @param {AccountsReceivableApiRrApiV1ProductPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductPartialUpdate(requestParameters: AccountsReceivableApiRrApiV1ProductPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).rrApiV1ProductPartialUpdate(requestParameters.id, requestParameters.patchedProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Product
     * @param {AccountsReceivableApiRrApiV1ProductRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductRetrieve(requestParameters: AccountsReceivableApiRrApiV1ProductRetrieveRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).rrApiV1ProductRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Product
     * @param {AccountsReceivableApiRrApiV1ProductUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductUpdate(requestParameters: AccountsReceivableApiRrApiV1ProductUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountsReceivableApiFp(this.configuration).rrApiV1ProductUpdate(requestParameters.id, requestParameters.product, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CoaApiV1CreditMemoListSortEnum = {
    AmountUsed: '-amount_used',
    ClientName: '-client_name',
    CreditMemoDate: '-credit_memo_date',
    TotalAmount: '-total_amount',
    AmountUsed2: 'amount_used',
    ClientName2: 'client_name',
    CreditMemoDate2: 'credit_memo_date',
    TotalAmount2: 'total_amount'
} as const;
export type CoaApiV1CreditMemoListSortEnum = typeof CoaApiV1CreditMemoListSortEnum[keyof typeof CoaApiV1CreditMemoListSortEnum];
export const CoaApiV1CreditMemoListStatusEnum = {
    Open: 'open',
    PartiallyUsed: 'partially_used',
    Used: 'used',
    Voided: 'voided'
} as const;
export type CoaApiV1CreditMemoListStatusEnum = typeof CoaApiV1CreditMemoListStatusEnum[keyof typeof CoaApiV1CreditMemoListStatusEnum];
export const CoaApiV1InvoiceListSentStatusEnum = {
    NotSent: 'not_sent',
    Sent: 'sent'
} as const;
export type CoaApiV1InvoiceListSentStatusEnum = typeof CoaApiV1InvoiceListSentStatusEnum[keyof typeof CoaApiV1InvoiceListSentStatusEnum];
export const CoaApiV1InvoiceListStatusEnum = {
    _130: '1_30',
    _3160: '31_60',
    _6190: '61_90',
    _91120: '91_120',
    Current: 'current',
    Over120: 'over_120',
    Paid: 'paid',
    PartiallyPaid: 'partially_paid',
    PastDue: 'past_due',
    Sent: 'sent',
    Uncollectible: 'uncollectible',
    Unpaid: 'unpaid',
    Voided: 'voided'
} as const;
export type CoaApiV1InvoiceListStatusEnum = typeof CoaApiV1InvoiceListStatusEnum[keyof typeof CoaApiV1InvoiceListStatusEnum];


/**
 * BankReconciliationApi - axios parameter creator
 */
export const BankReconciliationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new bank reconciliation report for a specific account and date range. Cannot create overlapping date ranges for the same account and entity.
         * @summary Create Bank Reconciliation Report
         * @param {ReconciliationReportV2} reconciliationReportV2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationCreate: async (reconciliationReportV2: ReconciliationReportV2, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reconciliationReportV2' is not null or undefined
            assertParamExists('coaApiV2ReconciliationCreate', 'reconciliationReportV2', reconciliationReportV2)
            const localVarPath = `/coa/api/v2/reconciliation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reconciliationReportV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a bank reconciliation report and all associated data.
         * @summary Delete Bank Reconciliation Report
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV2ReconciliationDestroy', 'id', id)
            const localVarPath = `/coa/api/v2/reconciliation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of bank reconciliation reports. Supports filtering by start_date, end_date, entity, account, and search query (q). Default sort is by statement_ending_date descending.
         * @summary List Bank Reconciliation Reports
         * @param {number} [account] Filter by account ID
         * @param {string} [endDate] Filter by maximum statement ending date (YYYY-MM-DD)
         * @param {number} [entity] Filter by entity ID
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search term for account name, number, or reconciled_by name
         * @param {string} [sort] Sort field (prefix with - for descending)
         * @param {string} [startDate] Filter by minimum statement ending date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationList: async (account?: number, endDate?: string, entity?: number, limit?: number, offset?: number, q?: string, sort?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v2/reconciliation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a bank reconciliation report. Only provided fields are modified.
         * @summary Partial Update Bank Reconciliation Report
         * @param {number} id 
         * @param {PatchedReconciliationReportV2} [patchedReconciliationReportV2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationPartialUpdate: async (id: number, patchedReconciliationReportV2?: PatchedReconciliationReportV2, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV2ReconciliationPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/v2/reconciliation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedReconciliationReportV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific bank reconciliation report by ID. Includes report metadata, status, async task status for PDF processing, and attached files/CSV statements.
         * @summary Get Bank Reconciliation Report
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV2ReconciliationRetrieve', 'id', id)
            const localVarPath = `/coa/api/v2/reconciliation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List source (GL) transactions available for reconciliation. Supports filtering by date range, bank, vendor, department, tag, currency, and reconciliation status.
         * @summary List GL Transactions for Reconciliation
         * @param {number} id 
         * @param {number} [bank] Filter by bank account ID
         * @param {string} [currency] Filter by currency code (e.g., USD, EUR)
         * @param {number} [department] Filter by department ID
         * @param {string} [endDate] Filter by maximum posted date (YYYY-MM-DD)
         * @param {number} [group] Filter by tag group ID
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search term for bank description, journal memo, journal order, or amount
         * @param {string} [reconciledOnly] Set to \&#39;true\&#39; to show only reconciled transactions for this report
         * @param {string} [sort] Sort field(s), comma-separated (prefix with - for descending). Default: posted_at
         * @param {string} [startDate] Filter by minimum posted date (YYYY-MM-DD)
         * @param {number} [tag] Filter by tag ID
         * @param {string} [unreconciled] Set to \&#39;true\&#39; to show only unreconciled transactions
         * @param {number} [vendor] Filter by vendor/payee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationSourceTransactionsList: async (id: number, bank?: number, currency?: string, department?: number, endDate?: string, group?: number, limit?: number, offset?: number, q?: string, reconciledOnly?: string, sort?: string, startDate?: string, tag?: number, unreconciled?: string, vendor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV2ReconciliationSourceTransactionsList', 'id', id)
            const localVarPath = `/coa/api/v2/reconciliation/{id}/source-transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (bank !== undefined) {
                localVarQueryParameter['bank'] = bank;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (department !== undefined) {
                localVarQueryParameter['department'] = department;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (reconciledOnly !== undefined) {
                localVarQueryParameter['reconciled_only'] = reconciledOnly;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (unreconciled !== undefined) {
                localVarQueryParameter['unreconciled'] = unreconciled;
            }

            if (vendor !== undefined) {
                localVarQueryParameter['vendor'] = vendor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm the selection of GL transactions for reconciliation. Pass selected transaction IDs in the request body. Selected transactions are marked as RECONCILED; deselected transactions have their status as suggested matches to this reconciliation report cleared.
         * @summary Confirm Selection of Transactions to Reconcile
         * @param {number} id 
         * @param {ConfirmTransactionSelectionRequest} confirmTransactionSelectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationTransactionsConfirmCreate: async (id: number, confirmTransactionSelectionRequest: ConfirmTransactionSelectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV2ReconciliationTransactionsConfirmCreate', 'id', id)
            // verify required parameter 'confirmTransactionSelectionRequest' is not null or undefined
            assertParamExists('coaApiV2ReconciliationTransactionsConfirmCreate', 'confirmTransactionSelectionRequest', confirmTransactionSelectionRequest)
            const localVarPath = `/coa/api/v2/reconciliation/{id}/transactions/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmTransactionSelectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a bank reconciliation report. Supports partial updates via PATCH.
         * @summary Update Bank Reconciliation Report
         * @param {number} id 
         * @param {ReconciliationReportV2} reconciliationReportV2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationUpdate: async (id: number, reconciliationReportV2: ReconciliationReportV2, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV2ReconciliationUpdate', 'id', id)
            // verify required parameter 'reconciliationReportV2' is not null or undefined
            assertParamExists('coaApiV2ReconciliationUpdate', 'reconciliationReportV2', reconciliationReportV2)
            const localVarPath = `/coa/api/v2/reconciliation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reconciliationReportV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankReconciliationApi - functional programming interface
 */
export const BankReconciliationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankReconciliationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new bank reconciliation report for a specific account and date range. Cannot create overlapping date ranges for the same account and entity.
         * @summary Create Bank Reconciliation Report
         * @param {ReconciliationReportV2} reconciliationReportV2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationCreate(reconciliationReportV2: ReconciliationReportV2, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReconciliationReportV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationCreate(reconciliationReportV2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a bank reconciliation report and all associated data.
         * @summary Delete Bank Reconciliation Report
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of bank reconciliation reports. Supports filtering by start_date, end_date, entity, account, and search query (q). Default sort is by statement_ending_date descending.
         * @summary List Bank Reconciliation Reports
         * @param {number} [account] Filter by account ID
         * @param {string} [endDate] Filter by maximum statement ending date (YYYY-MM-DD)
         * @param {number} [entity] Filter by entity ID
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search term for account name, number, or reconciled_by name
         * @param {string} [sort] Sort field (prefix with - for descending)
         * @param {string} [startDate] Filter by minimum statement ending date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationList(account?: number, endDate?: string, entity?: number, limit?: number, offset?: number, q?: string, sort?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReconciliationReportV2List>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationList(account, endDate, entity, limit, offset, q, sort, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a bank reconciliation report. Only provided fields are modified.
         * @summary Partial Update Bank Reconciliation Report
         * @param {number} id 
         * @param {PatchedReconciliationReportV2} [patchedReconciliationReportV2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationPartialUpdate(id: number, patchedReconciliationReportV2?: PatchedReconciliationReportV2, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReconciliationReportV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationPartialUpdate(id, patchedReconciliationReportV2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific bank reconciliation report by ID. Includes report metadata, status, async task status for PDF processing, and attached files/CSV statements.
         * @summary Get Bank Reconciliation Report
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReconciliationReportV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List source (GL) transactions available for reconciliation. Supports filtering by date range, bank, vendor, department, tag, currency, and reconciliation status.
         * @summary List GL Transactions for Reconciliation
         * @param {number} id 
         * @param {number} [bank] Filter by bank account ID
         * @param {string} [currency] Filter by currency code (e.g., USD, EUR)
         * @param {number} [department] Filter by department ID
         * @param {string} [endDate] Filter by maximum posted date (YYYY-MM-DD)
         * @param {number} [group] Filter by tag group ID
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search term for bank description, journal memo, journal order, or amount
         * @param {string} [reconciledOnly] Set to \&#39;true\&#39; to show only reconciled transactions for this report
         * @param {string} [sort] Sort field(s), comma-separated (prefix with - for descending). Default: posted_at
         * @param {string} [startDate] Filter by minimum posted date (YYYY-MM-DD)
         * @param {number} [tag] Filter by tag ID
         * @param {string} [unreconciled] Set to \&#39;true\&#39; to show only unreconciled transactions
         * @param {number} [vendor] Filter by vendor/payee ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationSourceTransactionsList(id: number, bank?: number, currency?: string, department?: number, endDate?: string, group?: number, limit?: number, offset?: number, q?: string, reconciledOnly?: string, sort?: string, startDate?: string, tag?: number, unreconciled?: string, vendor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReconciliationReportV2SourceTransactionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationSourceTransactionsList(id, bank, currency, department, endDate, group, limit, offset, q, reconciledOnly, sort, startDate, tag, unreconciled, vendor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationSourceTransactionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Confirm the selection of GL transactions for reconciliation. Pass selected transaction IDs in the request body. Selected transactions are marked as RECONCILED; deselected transactions have their status as suggested matches to this reconciliation report cleared.
         * @summary Confirm Selection of Transactions to Reconcile
         * @param {number} id 
         * @param {ConfirmTransactionSelectionRequest} confirmTransactionSelectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationTransactionsConfirmCreate(id: number, confirmTransactionSelectionRequest: ConfirmTransactionSelectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationTransactionsConfirmCreate(id, confirmTransactionSelectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationTransactionsConfirmCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a bank reconciliation report. Supports partial updates via PATCH.
         * @summary Update Bank Reconciliation Report
         * @param {number} id 
         * @param {ReconciliationReportV2} reconciliationReportV2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV2ReconciliationUpdate(id: number, reconciliationReportV2: ReconciliationReportV2, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReconciliationReportV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV2ReconciliationUpdate(id, reconciliationReportV2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankReconciliationApi.coaApiV2ReconciliationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankReconciliationApi - factory interface
 */
export const BankReconciliationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankReconciliationApiFp(configuration)
    return {
        /**
         * Create a new bank reconciliation report for a specific account and date range. Cannot create overlapping date ranges for the same account and entity.
         * @summary Create Bank Reconciliation Report
         * @param {BankReconciliationApiCoaApiV2ReconciliationCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationCreate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReconciliationReportV2> {
            return localVarFp.coaApiV2ReconciliationCreate(requestParameters.reconciliationReportV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a bank reconciliation report and all associated data.
         * @summary Delete Bank Reconciliation Report
         * @param {BankReconciliationApiCoaApiV2ReconciliationDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationDestroy(requestParameters: BankReconciliationApiCoaApiV2ReconciliationDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV2ReconciliationDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of bank reconciliation reports. Supports filtering by start_date, end_date, entity, account, and search query (q). Default sort is by statement_ending_date descending.
         * @summary List Bank Reconciliation Reports
         * @param {BankReconciliationApiCoaApiV2ReconciliationListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationList(requestParameters: BankReconciliationApiCoaApiV2ReconciliationListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedReconciliationReportV2List> {
            return localVarFp.coaApiV2ReconciliationList(requestParameters.account, requestParameters.endDate, requestParameters.entity, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a bank reconciliation report. Only provided fields are modified.
         * @summary Partial Update Bank Reconciliation Report
         * @param {BankReconciliationApiCoaApiV2ReconciliationPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationPartialUpdate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReconciliationReportV2> {
            return localVarFp.coaApiV2ReconciliationPartialUpdate(requestParameters.id, requestParameters.patchedReconciliationReportV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific bank reconciliation report by ID. Includes report metadata, status, async task status for PDF processing, and attached files/CSV statements.
         * @summary Get Bank Reconciliation Report
         * @param {BankReconciliationApiCoaApiV2ReconciliationRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationRetrieve(requestParameters: BankReconciliationApiCoaApiV2ReconciliationRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReconciliationReportV2> {
            return localVarFp.coaApiV2ReconciliationRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List source (GL) transactions available for reconciliation. Supports filtering by date range, bank, vendor, department, tag, currency, and reconciliation status.
         * @summary List GL Transactions for Reconciliation
         * @param {BankReconciliationApiCoaApiV2ReconciliationSourceTransactionsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationSourceTransactionsList(requestParameters: BankReconciliationApiCoaApiV2ReconciliationSourceTransactionsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedReconciliationReportV2SourceTransactionList> {
            return localVarFp.coaApiV2ReconciliationSourceTransactionsList(requestParameters.id, requestParameters.bank, requestParameters.currency, requestParameters.department, requestParameters.endDate, requestParameters.group, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.reconciledOnly, requestParameters.sort, requestParameters.startDate, requestParameters.tag, requestParameters.unreconciled, requestParameters.vendor, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm the selection of GL transactions for reconciliation. Pass selected transaction IDs in the request body. Selected transactions are marked as RECONCILED; deselected transactions have their status as suggested matches to this reconciliation report cleared.
         * @summary Confirm Selection of Transactions to Reconcile
         * @param {BankReconciliationApiCoaApiV2ReconciliationTransactionsConfirmCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationTransactionsConfirmCreate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationTransactionsConfirmCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV2ReconciliationTransactionsConfirmCreate(requestParameters.id, requestParameters.confirmTransactionSelectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a bank reconciliation report. Supports partial updates via PATCH.
         * @summary Update Bank Reconciliation Report
         * @param {BankReconciliationApiCoaApiV2ReconciliationUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV2ReconciliationUpdate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReconciliationReportV2> {
            return localVarFp.coaApiV2ReconciliationUpdate(requestParameters.id, requestParameters.reconciliationReportV2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for coaApiV2ReconciliationCreate operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationCreateRequest {
    readonly reconciliationReportV2: ReconciliationReportV2
}

/**
 * Request parameters for coaApiV2ReconciliationDestroy operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV2ReconciliationList operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationListRequest {
    /**
     * Filter by account ID
     */
    readonly account?: number

    /**
     * Filter by maximum statement ending date (YYYY-MM-DD)
     */
    readonly endDate?: string

    /**
     * Filter by entity ID
     */
    readonly entity?: number

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search term for account name, number, or reconciled_by name
     */
    readonly q?: string

    /**
     * Sort field (prefix with - for descending)
     */
    readonly sort?: string

    /**
     * Filter by minimum statement ending date (YYYY-MM-DD)
     */
    readonly startDate?: string
}

/**
 * Request parameters for coaApiV2ReconciliationPartialUpdate operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationPartialUpdateRequest {
    readonly id: number

    readonly patchedReconciliationReportV2?: PatchedReconciliationReportV2
}

/**
 * Request parameters for coaApiV2ReconciliationRetrieve operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV2ReconciliationSourceTransactionsList operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationSourceTransactionsListRequest {
    readonly id: number

    /**
     * Filter by bank account ID
     */
    readonly bank?: number

    /**
     * Filter by currency code (e.g., USD, EUR)
     */
    readonly currency?: string

    /**
     * Filter by department ID
     */
    readonly department?: number

    /**
     * Filter by maximum posted date (YYYY-MM-DD)
     */
    readonly endDate?: string

    /**
     * Filter by tag group ID
     */
    readonly group?: number

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search term for bank description, journal memo, journal order, or amount
     */
    readonly q?: string

    /**
     * Set to \&#39;true\&#39; to show only reconciled transactions for this report
     */
    readonly reconciledOnly?: string

    /**
     * Sort field(s), comma-separated (prefix with - for descending). Default: posted_at
     */
    readonly sort?: string

    /**
     * Filter by minimum posted date (YYYY-MM-DD)
     */
    readonly startDate?: string

    /**
     * Filter by tag ID
     */
    readonly tag?: number

    /**
     * Set to \&#39;true\&#39; to show only unreconciled transactions
     */
    readonly unreconciled?: string

    /**
     * Filter by vendor/payee ID
     */
    readonly vendor?: number
}

/**
 * Request parameters for coaApiV2ReconciliationTransactionsConfirmCreate operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationTransactionsConfirmCreateRequest {
    readonly id: number

    readonly confirmTransactionSelectionRequest: ConfirmTransactionSelectionRequest
}

/**
 * Request parameters for coaApiV2ReconciliationUpdate operation in BankReconciliationApi.
 */
export interface BankReconciliationApiCoaApiV2ReconciliationUpdateRequest {
    readonly id: number

    readonly reconciliationReportV2: ReconciliationReportV2
}

/**
 * BankReconciliationApi - object-oriented interface
 */
export class BankReconciliationApi extends BaseAPI {
    /**
     * Create a new bank reconciliation report for a specific account and date range. Cannot create overlapping date ranges for the same account and entity.
     * @summary Create Bank Reconciliation Report
     * @param {BankReconciliationApiCoaApiV2ReconciliationCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationCreate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationCreateRequest, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationCreate(requestParameters.reconciliationReportV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a bank reconciliation report and all associated data.
     * @summary Delete Bank Reconciliation Report
     * @param {BankReconciliationApiCoaApiV2ReconciliationDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationDestroy(requestParameters: BankReconciliationApiCoaApiV2ReconciliationDestroyRequest, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of bank reconciliation reports. Supports filtering by start_date, end_date, entity, account, and search query (q). Default sort is by statement_ending_date descending.
     * @summary List Bank Reconciliation Reports
     * @param {BankReconciliationApiCoaApiV2ReconciliationListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationList(requestParameters: BankReconciliationApiCoaApiV2ReconciliationListRequest = {}, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationList(requestParameters.account, requestParameters.endDate, requestParameters.entity, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a bank reconciliation report. Only provided fields are modified.
     * @summary Partial Update Bank Reconciliation Report
     * @param {BankReconciliationApiCoaApiV2ReconciliationPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationPartialUpdate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationPartialUpdate(requestParameters.id, requestParameters.patchedReconciliationReportV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific bank reconciliation report by ID. Includes report metadata, status, async task status for PDF processing, and attached files/CSV statements.
     * @summary Get Bank Reconciliation Report
     * @param {BankReconciliationApiCoaApiV2ReconciliationRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationRetrieve(requestParameters: BankReconciliationApiCoaApiV2ReconciliationRetrieveRequest, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List source (GL) transactions available for reconciliation. Supports filtering by date range, bank, vendor, department, tag, currency, and reconciliation status.
     * @summary List GL Transactions for Reconciliation
     * @param {BankReconciliationApiCoaApiV2ReconciliationSourceTransactionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationSourceTransactionsList(requestParameters: BankReconciliationApiCoaApiV2ReconciliationSourceTransactionsListRequest, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationSourceTransactionsList(requestParameters.id, requestParameters.bank, requestParameters.currency, requestParameters.department, requestParameters.endDate, requestParameters.group, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.reconciledOnly, requestParameters.sort, requestParameters.startDate, requestParameters.tag, requestParameters.unreconciled, requestParameters.vendor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm the selection of GL transactions for reconciliation. Pass selected transaction IDs in the request body. Selected transactions are marked as RECONCILED; deselected transactions have their status as suggested matches to this reconciliation report cleared.
     * @summary Confirm Selection of Transactions to Reconcile
     * @param {BankReconciliationApiCoaApiV2ReconciliationTransactionsConfirmCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationTransactionsConfirmCreate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationTransactionsConfirmCreateRequest, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationTransactionsConfirmCreate(requestParameters.id, requestParameters.confirmTransactionSelectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a bank reconciliation report. Supports partial updates via PATCH.
     * @summary Update Bank Reconciliation Report
     * @param {BankReconciliationApiCoaApiV2ReconciliationUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV2ReconciliationUpdate(requestParameters: BankReconciliationApiCoaApiV2ReconciliationUpdateRequest, options?: RawAxiosRequestConfig) {
        return BankReconciliationApiFp(this.configuration).coaApiV2ReconciliationUpdate(requestParameters.id, requestParameters.reconciliationReportV2, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CashManagementApi - axios parameter creator
 */
export const CashManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Bank Account
         * @param {number} id 
         * @param {number} [newAccount] ID of the bank account to reassign transactions to before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountDestroy: async (id: number, newAccount?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiAccountDestroy', 'id', id)
            const localVarPath = `/ca/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (newAccount !== undefined) {
                localVarQueryParameter['new_account'] = newAccount;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Bank Account
         * @param {number} id 
         * @param {PatchedBankAccount} [patchedBankAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountPartialUpdate: async (id: number, patchedBankAccount?: PatchedBankAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiAccountPartialUpdate', 'id', id)
            const localVarPath = `/ca/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBankAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Bank Account
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiAccountRetrieve', 'id', id)
            const localVarPath = `/ca/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Bank Account
         * @param {number} id 
         * @param {BankAccount} bankAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountUpdate: async (id: number, bankAccount: BankAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiAccountUpdate', 'id', id)
            // verify required parameter 'bankAccount' is not null or undefined
            assertParamExists('caApiAccountUpdate', 'bankAccount', bankAccount)
            const localVarPath = `/ca/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Bank Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiTransactionDestroy', 'id', id)
            const localVarPath = `/ca/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Bank Transaction
         * @param {number} id 
         * @param {PatchedBankTransaction} [patchedBankTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionPartialUpdate: async (id: number, patchedBankTransaction?: PatchedBankTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiTransactionPartialUpdate', 'id', id)
            const localVarPath = `/ca/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBankTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Bank Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiTransactionRetrieve', 'id', id)
            const localVarPath = `/ca/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Bank Transaction
         * @param {number} id 
         * @param {BankTransaction} bankTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionUpdate: async (id: number, bankTransaction: BankTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiTransactionUpdate', 'id', id)
            // verify required parameter 'bankTransaction' is not null or undefined
            assertParamExists('caApiTransactionUpdate', 'bankTransaction', bankTransaction)
            const localVarPath = `/ca/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new bank account
         * @summary Create Bank Account
         * @param {BankAccount} bankAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (bankAccount: BankAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccount' is not null or undefined
            assertParamExists('createAccount', 'bankAccount', bankAccount)
            const localVarPath = `/ca/api/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new bank transaction
         * @summary Create Bank Transaction
         * @param {BankTransaction} bankTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankTransaction: async (bankTransaction: BankTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankTransaction' is not null or undefined
            assertParamExists('createBankTransaction', 'bankTransaction', bankTransaction)
            const localVarPath = `/ca/api/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a paginated list of bank accounts.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).          Supports sorting by all returned fields:         - name, -name (account name)         - nickname, -nickname (account nickname)         - type, -type (account type)         - status, -status (account status)         - currency, -currency (account currency)         - external_account_id, -external_account_id (external account ID)         - institution_id, -institution_id (institution ID)         - source, -source (account source)         - current_balance, -current_balance (current balance)         - available_balance, -available_balance (available balance)         - created_at, -created_at (creation date)         - last_modified_at, -last_modified_at (last modified date)         - account_type, -account_type (chart account type)         - account_subtype, -account_subtype (chart account subtype)         - account_cashflow_classification, -account_cashflow_classification (cashflow classification)         - type_name, -type_name (human-readable account type)         - subtype_name, -subtype_name (human-readable account subtype)         - cashflow_classification_name, -cashflow_classification_name (human-readable cashflow classification)         - entity_name, -entity_name (entity name)         - department, -department (department name)         - id, -id (account ID)         - account_id, -account_id (UUID account ID)         
         * @summary List Bank Accounts
         * @param {number} [chartOfAccountsAccount] Filter bank accounts by their linked chart of accounts account ID
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (chartOfAccountsAccount?: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (chartOfAccountsAccount !== undefined) {
                localVarQueryParameter['chart_of_accounts_account'] = chartOfAccountsAccount;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a paginated list of bank transactions with optional filtering.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).         
         * @summary List Bank Transactions
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBankTransactions: async (includeDeleted?: boolean, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashManagementApi - functional programming interface
 */
export const CashManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Bank Account
         * @param {number} id 
         * @param {number} [newAccount] ID of the bank account to reassign transactions to before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiAccountDestroy(id: number, newAccount?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiAccountDestroy(id, newAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiAccountDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Bank Account
         * @param {number} id 
         * @param {PatchedBankAccount} [patchedBankAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiAccountPartialUpdate(id: number, patchedBankAccount?: PatchedBankAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiAccountPartialUpdate(id, patchedBankAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiAccountPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Bank Account
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiAccountRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiAccountRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiAccountRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Bank Account
         * @param {number} id 
         * @param {BankAccount} bankAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiAccountUpdate(id: number, bankAccount: BankAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiAccountUpdate(id, bankAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiAccountUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Bank Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiTransactionDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiTransactionDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiTransactionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Bank Transaction
         * @param {number} id 
         * @param {PatchedBankTransaction} [patchedBankTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiTransactionPartialUpdate(id: number, patchedBankTransaction?: PatchedBankTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiTransactionPartialUpdate(id, patchedBankTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiTransactionPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Bank Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiTransactionRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiTransactionRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiTransactionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Bank Transaction
         * @param {number} id 
         * @param {BankTransaction} bankTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiTransactionUpdate(id: number, bankTransaction: BankTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiTransactionUpdate(id, bankTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.caApiTransactionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new bank account
         * @summary Create Bank Account
         * @param {BankAccount} bankAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(bankAccount: BankAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(bankAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new bank transaction
         * @summary Create Bank Transaction
         * @param {BankTransaction} bankTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBankTransaction(bankTransaction: BankTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBankTransaction(bankTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.createBankTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a paginated list of bank accounts.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).          Supports sorting by all returned fields:         - name, -name (account name)         - nickname, -nickname (account nickname)         - type, -type (account type)         - status, -status (account status)         - currency, -currency (account currency)         - external_account_id, -external_account_id (external account ID)         - institution_id, -institution_id (institution ID)         - source, -source (account source)         - current_balance, -current_balance (current balance)         - available_balance, -available_balance (available balance)         - created_at, -created_at (creation date)         - last_modified_at, -last_modified_at (last modified date)         - account_type, -account_type (chart account type)         - account_subtype, -account_subtype (chart account subtype)         - account_cashflow_classification, -account_cashflow_classification (cashflow classification)         - type_name, -type_name (human-readable account type)         - subtype_name, -subtype_name (human-readable account subtype)         - cashflow_classification_name, -cashflow_classification_name (human-readable cashflow classification)         - entity_name, -entity_name (entity name)         - department, -department (department name)         - id, -id (account ID)         - account_id, -account_id (UUID account ID)         
         * @summary List Bank Accounts
         * @param {number} [chartOfAccountsAccount] Filter bank accounts by their linked chart of accounts account ID
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(chartOfAccountsAccount?: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBankAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(chartOfAccountsAccount, includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a paginated list of bank transactions with optional filtering.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).         
         * @summary List Bank Transactions
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBankTransactions(includeDeleted?: boolean, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBankTransactionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBankTransactions(includeDeleted, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashManagementApi.listBankTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CashManagementApi - factory interface
 */
export const CashManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Bank Account
         * @param {CashManagementApiCaApiAccountDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountDestroy(requestParameters: CashManagementApiCaApiAccountDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiAccountDestroy(requestParameters.id, requestParameters.newAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Bank Account
         * @param {CashManagementApiCaApiAccountPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountPartialUpdate(requestParameters: CashManagementApiCaApiAccountPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankAccount> {
            return localVarFp.caApiAccountPartialUpdate(requestParameters.id, requestParameters.patchedBankAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Bank Account
         * @param {CashManagementApiCaApiAccountRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountRetrieve(requestParameters: CashManagementApiCaApiAccountRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankAccount> {
            return localVarFp.caApiAccountRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Bank Account
         * @param {CashManagementApiCaApiAccountUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiAccountUpdate(requestParameters: CashManagementApiCaApiAccountUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankAccount> {
            return localVarFp.caApiAccountUpdate(requestParameters.id, requestParameters.bankAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Bank Transaction
         * @param {CashManagementApiCaApiTransactionDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionDestroy(requestParameters: CashManagementApiCaApiTransactionDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiTransactionDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Bank Transaction
         * @param {CashManagementApiCaApiTransactionPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionPartialUpdate(requestParameters: CashManagementApiCaApiTransactionPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankTransaction> {
            return localVarFp.caApiTransactionPartialUpdate(requestParameters.id, requestParameters.patchedBankTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Bank Transaction
         * @param {CashManagementApiCaApiTransactionRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionRetrieve(requestParameters: CashManagementApiCaApiTransactionRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankTransaction> {
            return localVarFp.caApiTransactionRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Bank Transaction
         * @param {CashManagementApiCaApiTransactionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiTransactionUpdate(requestParameters: CashManagementApiCaApiTransactionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankTransaction> {
            return localVarFp.caApiTransactionUpdate(requestParameters.id, requestParameters.bankTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new bank account
         * @summary Create Bank Account
         * @param {CashManagementApiCreateAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(requestParameters: CashManagementApiCreateAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankAccount> {
            return localVarFp.createAccount(requestParameters.bankAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new bank transaction
         * @summary Create Bank Transaction
         * @param {CashManagementApiCreateBankTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankTransaction(requestParameters: CashManagementApiCreateBankTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<BankTransaction> {
            return localVarFp.createBankTransaction(requestParameters.bankTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a paginated list of bank accounts.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).          Supports sorting by all returned fields:         - name, -name (account name)         - nickname, -nickname (account nickname)         - type, -type (account type)         - status, -status (account status)         - currency, -currency (account currency)         - external_account_id, -external_account_id (external account ID)         - institution_id, -institution_id (institution ID)         - source, -source (account source)         - current_balance, -current_balance (current balance)         - available_balance, -available_balance (available balance)         - created_at, -created_at (creation date)         - last_modified_at, -last_modified_at (last modified date)         - account_type, -account_type (chart account type)         - account_subtype, -account_subtype (chart account subtype)         - account_cashflow_classification, -account_cashflow_classification (cashflow classification)         - type_name, -type_name (human-readable account type)         - subtype_name, -subtype_name (human-readable account subtype)         - cashflow_classification_name, -cashflow_classification_name (human-readable cashflow classification)         - entity_name, -entity_name (entity name)         - department, -department (department name)         - id, -id (account ID)         - account_id, -account_id (UUID account ID)         
         * @summary List Bank Accounts
         * @param {CashManagementApiListAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(requestParameters: CashManagementApiListAccountsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBankAccountList> {
            return localVarFp.listAccounts(requestParameters.chartOfAccountsAccount, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a paginated list of bank transactions with optional filtering.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).         
         * @summary List Bank Transactions
         * @param {CashManagementApiListBankTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBankTransactions(requestParameters: CashManagementApiListBankTransactionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBankTransactionList> {
            return localVarFp.listBankTransactions(requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for caApiAccountDestroy operation in CashManagementApi.
 */
export interface CashManagementApiCaApiAccountDestroyRequest {
    readonly id: number

    /**
     * ID of the bank account to reassign transactions to before deletion
     */
    readonly newAccount?: number
}

/**
 * Request parameters for caApiAccountPartialUpdate operation in CashManagementApi.
 */
export interface CashManagementApiCaApiAccountPartialUpdateRequest {
    readonly id: number

    readonly patchedBankAccount?: PatchedBankAccount
}

/**
 * Request parameters for caApiAccountRetrieve operation in CashManagementApi.
 */
export interface CashManagementApiCaApiAccountRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for caApiAccountUpdate operation in CashManagementApi.
 */
export interface CashManagementApiCaApiAccountUpdateRequest {
    readonly id: number

    readonly bankAccount: BankAccount
}

/**
 * Request parameters for caApiTransactionDestroy operation in CashManagementApi.
 */
export interface CashManagementApiCaApiTransactionDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for caApiTransactionPartialUpdate operation in CashManagementApi.
 */
export interface CashManagementApiCaApiTransactionPartialUpdateRequest {
    readonly id: number

    readonly patchedBankTransaction?: PatchedBankTransaction
}

/**
 * Request parameters for caApiTransactionRetrieve operation in CashManagementApi.
 */
export interface CashManagementApiCaApiTransactionRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for caApiTransactionUpdate operation in CashManagementApi.
 */
export interface CashManagementApiCaApiTransactionUpdateRequest {
    readonly id: number

    readonly bankTransaction: BankTransaction
}

/**
 * Request parameters for createAccount operation in CashManagementApi.
 */
export interface CashManagementApiCreateAccountRequest {
    readonly bankAccount: BankAccount
}

/**
 * Request parameters for createBankTransaction operation in CashManagementApi.
 */
export interface CashManagementApiCreateBankTransactionRequest {
    readonly bankTransaction: BankTransaction
}

/**
 * Request parameters for listAccounts operation in CashManagementApi.
 */
export interface CashManagementApiListAccountsRequest {
    /**
     * Filter bank accounts by their linked chart of accounts account ID
     */
    readonly chartOfAccountsAccount?: number

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for listBankTransactions operation in CashManagementApi.
 */
export interface CashManagementApiListBankTransactionsRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * CashManagementApi - object-oriented interface
 */
export class CashManagementApi extends BaseAPI {
    /**
     * 
     * @summary Delete Bank Account
     * @param {CashManagementApiCaApiAccountDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiAccountDestroy(requestParameters: CashManagementApiCaApiAccountDestroyRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiAccountDestroy(requestParameters.id, requestParameters.newAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Bank Account
     * @param {CashManagementApiCaApiAccountPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiAccountPartialUpdate(requestParameters: CashManagementApiCaApiAccountPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiAccountPartialUpdate(requestParameters.id, requestParameters.patchedBankAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Bank Account
     * @param {CashManagementApiCaApiAccountRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiAccountRetrieve(requestParameters: CashManagementApiCaApiAccountRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiAccountRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Bank Account
     * @param {CashManagementApiCaApiAccountUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiAccountUpdate(requestParameters: CashManagementApiCaApiAccountUpdateRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiAccountUpdate(requestParameters.id, requestParameters.bankAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Bank Transaction
     * @param {CashManagementApiCaApiTransactionDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiTransactionDestroy(requestParameters: CashManagementApiCaApiTransactionDestroyRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiTransactionDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Bank Transaction
     * @param {CashManagementApiCaApiTransactionPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiTransactionPartialUpdate(requestParameters: CashManagementApiCaApiTransactionPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiTransactionPartialUpdate(requestParameters.id, requestParameters.patchedBankTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Bank Transaction
     * @param {CashManagementApiCaApiTransactionRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiTransactionRetrieve(requestParameters: CashManagementApiCaApiTransactionRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiTransactionRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Bank Transaction
     * @param {CashManagementApiCaApiTransactionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiTransactionUpdate(requestParameters: CashManagementApiCaApiTransactionUpdateRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).caApiTransactionUpdate(requestParameters.id, requestParameters.bankTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new bank account
     * @summary Create Bank Account
     * @param {CashManagementApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAccount(requestParameters: CashManagementApiCreateAccountRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).createAccount(requestParameters.bankAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new bank transaction
     * @summary Create Bank Transaction
     * @param {CashManagementApiCreateBankTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBankTransaction(requestParameters: CashManagementApiCreateBankTransactionRequest, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).createBankTransaction(requestParameters.bankTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a paginated list of bank accounts.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).          Supports sorting by all returned fields:         - name, -name (account name)         - nickname, -nickname (account nickname)         - type, -type (account type)         - status, -status (account status)         - currency, -currency (account currency)         - external_account_id, -external_account_id (external account ID)         - institution_id, -institution_id (institution ID)         - source, -source (account source)         - current_balance, -current_balance (current balance)         - available_balance, -available_balance (available balance)         - created_at, -created_at (creation date)         - last_modified_at, -last_modified_at (last modified date)         - account_type, -account_type (chart account type)         - account_subtype, -account_subtype (chart account subtype)         - account_cashflow_classification, -account_cashflow_classification (cashflow classification)         - type_name, -type_name (human-readable account type)         - subtype_name, -subtype_name (human-readable account subtype)         - cashflow_classification_name, -cashflow_classification_name (human-readable cashflow classification)         - entity_name, -entity_name (entity name)         - department, -department (department name)         - id, -id (account ID)         - account_id, -account_id (UUID account ID)         
     * @summary List Bank Accounts
     * @param {CashManagementApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAccounts(requestParameters: CashManagementApiListAccountsRequest = {}, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).listAccounts(requestParameters.chartOfAccountsAccount, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a paginated list of bank transactions with optional filtering.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, deleted records will have is_deleted=true         and include deletion metadata (deleted_at timestamp).         
     * @summary List Bank Transactions
     * @param {CashManagementApiListBankTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listBankTransactions(requestParameters: CashManagementApiListBankTransactionsRequest = {}, options?: RawAxiosRequestConfig) {
        return CashManagementApiFp(this.configuration).listBankTransactions(requestParameters.includeDeleted, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoaApi - axios parameter creator
 */
export const CoaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload invoice email attachment with proper permissions
         * @summary Upload Entity Invoice Email Attachment
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityAttachmentCreate: async (entityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('coaApiEntityAttachmentCreate', 'entityId', entityId)
            const localVarPath = `/coa/api/entity/{entity_id}/attachment`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List accounts that are of type FIXED_ASSET for use in automation rule creation. GET /api/fixed-asset-automation/accounts  This endpoint returns only accounts with account_subtype=\'FIXED_ASSET\' to ensure automation rules are created with appropriate accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationAccountsRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/fixed-asset-automation/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List fixed asset classes that match a specific account. GET /api/fixed-asset-automation/asset-classes?account_id=<id>  Filters asset classes to only those where asset_account matches the provided account_id. This ensures users can only select compatible asset classes for the chosen account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationAssetClassesRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/fixed-asset-automation/asset-classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
         * @param {FixedAssetAutomationRule} fixedAssetAutomationRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationCreate: async (fixedAssetAutomationRule: FixedAssetAutomationRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fixedAssetAutomationRule' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationCreate', 'fixedAssetAutomationRule', fixedAssetAutomationRule)
            const localVarPath = `/coa/api/fixed-asset-automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixedAssetAutomationRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationDestroy', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationList: async (limit?: number, offset?: number, ordering?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/fixed-asset-automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {number} id 
         * @param {PatchedFixedAssetAutomationMatch} [patchedFixedAssetAutomationMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchPartialUpdate: async (id: number, patchedFixedAssetAutomationMatch?: PatchedFixedAssetAutomationMatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationMatchPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-automation-match/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFixedAssetAutomationMatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationMatchRetrieve', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-automation-match/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {number} id 
         * @param {FixedAssetAutomationMatch} fixedAssetAutomationMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchUpdate: async (id: number, fixedAssetAutomationMatch: FixedAssetAutomationMatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationMatchUpdate', 'id', id)
            // verify required parameter 'fixedAssetAutomationMatch' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationMatchUpdate', 'fixedAssetAutomationMatch', fixedAssetAutomationMatch)
            const localVarPath = `/coa/api/fixed-asset-automation-match/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixedAssetAutomationMatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List pending asset matches for review. GET /api/fixed-asset-automation/matches
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchesList: async (limit?: number, offset?: number, ordering?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/fixed-asset-automation/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {PatchedFixedAssetAutomationRule} [patchedFixedAssetAutomationRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationPartialUpdate: async (id: number, patchedFixedAssetAutomationRule?: PatchedFixedAssetAutomationRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFixedAssetAutomationRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationRetrieve', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger automation processing. POST /api/fixed-asset-automation/run  Optional body: {\"rule_id\": 123}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationRunCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/fixed-asset-automation/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {FixedAssetAutomationRule} fixedAssetAutomationRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationUpdate: async (id: number, fixedAssetAutomationRule: FixedAssetAutomationRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationUpdate', 'id', id)
            // verify required parameter 'fixedAssetAutomationRule' is not null or undefined
            assertParamExists('coaApiFixedAssetAutomationUpdate', 'fixedAssetAutomationRule', fixedAssetAutomationRule)
            const localVarPath = `/coa/api/fixed-asset-automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixedAssetAutomationRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple chart transactions in a single request.
         * @summary Bulk Update Chart Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionBulkUpdateCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/transaction/bulk-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the transaction matching process for bank reconciliation.
         * @summary Process Transaction Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchProcessCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/transaction-match-process`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the count of pending transaction matches.
         * @summary Get Transaction Matches Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesCountRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/transaction-matches-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a transaction match record.
         * @summary Delete Transaction Match
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionMatchesDestroy', 'id', id)
            const localVarPath = `/coa/api/transaction-matches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of transaction matches for bank reconciliation review.
         * @summary List Transaction Matches
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/transaction-matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a transaction match record.
         * @summary Partial Update Transaction Match
         * @param {number} id 
         * @param {PatchedTransactionMatch} [patchedTransactionMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesPartialUpdate: async (id: number, patchedTransactionMatch?: PatchedTransactionMatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionMatchesPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/transaction-matches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTransactionMatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject a proposed transaction match.
         * @summary Reject Transaction Match
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesRejectCreate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionMatchesRejectCreate', 'id', id)
            const localVarPath = `/coa/api/transaction-matches/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific transaction match by ID.
         * @summary Retrieve Transaction Match
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionMatchesRetrieve', 'id', id)
            const localVarPath = `/coa/api/transaction-matches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle POST requests with \'action\' parameter (accept/reject)
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesStatusCreate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionMatchesStatusCreate', 'id', id)
            const localVarPath = `/coa/api/transaction-matches/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of a transaction match (accept or reject).
         * @summary Update Transaction Match Status
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesStatusUpdate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionMatchesStatusUpdate', 'id', id)
            const localVarPath = `/coa/api/transaction-matches/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a transaction match record.
         * @summary Update Transaction Match
         * @param {number} id 
         * @param {TransactionMatch} transactionMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesUpdate: async (id: number, transactionMatch: TransactionMatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionMatchesUpdate', 'id', id)
            // verify required parameter 'transactionMatch' is not null or undefined
            assertParamExists('coaApiTransactionMatchesUpdate', 'transactionMatch', transactionMatch)
            const localVarPath = `/coa/api/transaction-matches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionMatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Merge two offsetting chart transactions from different journals.          This endpoint consolidates journals containing offsetting transactions by removing         the specified transactions and combining the remaining transactions into a single journal entry.          **Request Body:**         - `transaction_ids` (array, required): Array of exactly two transaction IDs to merge          **Returns:**         The merged journal entry with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity          **Result:**         - The two specified transactions are deleted         - Other transactions from both journals are consolidated into a single journal         - A draft queue record is created for audit purposes and auto-approved         
         * @summary Merge Chart Transactions
         * @param {CoaApiTransactionMergeCreateRequest} [coaApiTransactionMergeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMergeCreate: async (coaApiTransactionMergeCreateRequest?: CoaApiTransactionMergeCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/transaction/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coaApiTransactionMergeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Preview the result of merging two chart transactions.          This endpoint shows what the merged journal entry will look like, allowing you to verify         the merge before committing. The preview includes the journal that will be retained and         the transactions that will remain after the merge.          **Parameters:**         - `transaction_ids` (query, required): Comma-separated list of exactly two transaction IDs          **Returns:**         A journal entry object containing the merged result with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity         
         * @summary Preview Chart Transaction Merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMergeRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/transaction/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a bill amortization schedule.
         * @summary Create Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/amortization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an amortization schedule for a specific bill.
         * @summary Create Bill Amortization
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationCreate2: async (billId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillAmortizationCreate2', 'billId', billId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/amortization`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a bill amortization schedule.
         * @summary Delete Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationDestroy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/amortization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the amortization schedule for a specific bill.
         * @summary Delete Bill Amortization
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationDestroy2: async (billId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillAmortizationDestroy2', 'billId', billId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/amortization`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a preview of the amortization schedule without persisting it.
         * @summary Preview Amortization Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationGenerateScheduleRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/amortization/generate-schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate and persist an amortization schedule for a bill.
         * @summary Generate Amortization Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationGenerateScheduleUpdate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/amortization/generate-schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve bill amortization data across all bills.
         * @summary Get Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/v1/bill/amortization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the amortization schedule for a specific bill.
         * @summary Get Bill Amortization
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationRetrieve2: async (billId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billId' is not null or undefined
            assertParamExists('coaApiV1BillAmortizationRetrieve2', 'billId', billId)
            const localVarPath = `/coa/api/v1/bill/{bill_id}/amortization`
                .replace(`{${"bill_id"}}`, encodeURIComponent(String(billId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate and download a PDF of the credit memo.
         * @summary Get Credit Memo PDF
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoPdfRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1CreditMemoPdfRetrieve', 'id', id)
            const localVarPath = `/coa/api/v1/credit-memo/{id}/pdf/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a single credit memo via email.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoSendUpdate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiV1CreditMemoSendUpdate', 'id', id)
            const localVarPath = `/coa/api/v1/credit-memo/{id}/send/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a customer statement PDF for a specific client.  This creates a professional, customer-facing statement showing: - All outstanding invoices as of the specified date - Running balance - Total balance due - Payment advice slip
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceStatementClientPdfRetrieve: async (clientId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('coaApiV1InvoiceStatementClientPdfRetrieve', 'clientId', clientId)
            const localVarPath = `/coa/api/v1/invoice/statement/client/{client_id}/pdf/`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new vendor custom field value.
         * @summary Create Vendor Custom Field
         * @param {VendorCustomField1} [vendorCustomField1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Create: async (vendorCustomField1?: VendorCustomField1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/vendor_custom_field_1/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorCustomField1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a vendor custom field value.
         * @summary Delete Vendor Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Destroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorCustomField1Destroy', 'id', id)
            const localVarPath = `/coa/api/vendor_custom_field_1/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of vendor custom field values.
         * @summary List Vendor Custom Fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1List: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/vendor_custom_field_1/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a vendor custom field value.
         * @summary Partial Update Vendor Custom Field
         * @param {number} id 
         * @param {PatchedVendorCustomField1} [patchedVendorCustomField1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1PartialUpdate: async (id: number, patchedVendorCustomField1?: PatchedVendorCustomField1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorCustomField1PartialUpdate', 'id', id)
            const localVarPath = `/coa/api/vendor_custom_field_1/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedVendorCustomField1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific vendor custom field value by ID.
         * @summary Retrieve Vendor Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Retrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorCustomField1Retrieve', 'id', id)
            const localVarPath = `/coa/api/vendor_custom_field_1/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a vendor custom field value.
         * @summary Update Vendor Custom Field
         * @param {number} id 
         * @param {VendorCustomField1} [vendorCustomField1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Update: async (id: number, vendorCustomField1?: VendorCustomField1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorCustomField1Update', 'id', id)
            const localVarPath = `/coa/api/vendor_custom_field_1/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorCustomField1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve summary information for all vendors including spend totals and payment status.
         * @summary List Vendor Summaries
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorSummaryList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/vendor/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoaApi - functional programming interface
 */
export const CoaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoaApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload invoice email attachment with proper permissions
         * @summary Upload Entity Invoice Email Attachment
         * @param {number} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityAttachmentCreate(entityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityAttachmentCreate(entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiEntityAttachmentCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List accounts that are of type FIXED_ASSET for use in automation rule creation. GET /api/fixed-asset-automation/accounts  This endpoint returns only accounts with account_subtype=\'FIXED_ASSET\' to ensure automation rules are created with appropriate accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationAccountsRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationAccountsRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationAccountsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List fixed asset classes that match a specific account. GET /api/fixed-asset-automation/asset-classes?account_id=<id>  Filters asset classes to only those where asset_account matches the provided account_id. This ensures users can only select compatible asset classes for the chosen account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationAssetClassesRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationAssetClassesRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationAssetClassesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
         * @param {FixedAssetAutomationRule} fixedAssetAutomationRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationCreate(fixedAssetAutomationRule: FixedAssetAutomationRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetAutomationRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationCreate(fixedAssetAutomationRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationList(limit?: number, offset?: number, ordering?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFixedAssetAutomationRuleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationList(limit, offset, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {number} id 
         * @param {PatchedFixedAssetAutomationMatch} [patchedFixedAssetAutomationMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationMatchPartialUpdate(id: number, patchedFixedAssetAutomationMatch?: PatchedFixedAssetAutomationMatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetAutomationMatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationMatchPartialUpdate(id, patchedFixedAssetAutomationMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationMatchPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationMatchRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetAutomationMatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationMatchRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationMatchRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {number} id 
         * @param {FixedAssetAutomationMatch} fixedAssetAutomationMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationMatchUpdate(id: number, fixedAssetAutomationMatch: FixedAssetAutomationMatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetAutomationMatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationMatchUpdate(id, fixedAssetAutomationMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationMatchUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List pending asset matches for review. GET /api/fixed-asset-automation/matches
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationMatchesList(limit?: number, offset?: number, ordering?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFixedAssetAutomationMatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationMatchesList(limit, offset, ordering, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationMatchesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {PatchedFixedAssetAutomationRule} [patchedFixedAssetAutomationRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationPartialUpdate(id: number, patchedFixedAssetAutomationRule?: PatchedFixedAssetAutomationRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetAutomationRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationPartialUpdate(id, patchedFixedAssetAutomationRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetAutomationRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger automation processing. POST /api/fixed-asset-automation/run  Optional body: {\"rule_id\": 123}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationRunCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationRunCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationRunCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {number} id 
         * @param {FixedAssetAutomationRule} fixedAssetAutomationRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetAutomationUpdate(id: number, fixedAssetAutomationRule: FixedAssetAutomationRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetAutomationRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetAutomationUpdate(id, fixedAssetAutomationRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiFixedAssetAutomationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple chart transactions in a single request.
         * @summary Bulk Update Chart Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionBulkUpdateCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionBulkUpdateCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionBulkUpdateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger the transaction matching process for bank reconciliation.
         * @summary Process Transaction Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchProcessCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchProcessCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchProcessCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the count of pending transaction matches.
         * @summary Get Transaction Matches Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesCountRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesCountRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesCountRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a transaction match record.
         * @summary Delete Transaction Match
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of transaction matches for bank reconciliation review.
         * @summary List Transaction Matches
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransactionMatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesList(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a transaction match record.
         * @summary Partial Update Transaction Match
         * @param {number} id 
         * @param {PatchedTransactionMatch} [patchedTransactionMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesPartialUpdate(id: number, patchedTransactionMatch?: PatchedTransactionMatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionMatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesPartialUpdate(id, patchedTransactionMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reject a proposed transaction match.
         * @summary Reject Transaction Match
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesRejectCreate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesRejectCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesRejectCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific transaction match by ID.
         * @summary Retrieve Transaction Match
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionMatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle POST requests with \'action\' parameter (accept/reject)
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesStatusCreate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesStatusCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesStatusCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of a transaction match (accept or reject).
         * @summary Update Transaction Match Status
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesStatusUpdate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesStatusUpdate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesStatusUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a transaction match record.
         * @summary Update Transaction Match
         * @param {number} id 
         * @param {TransactionMatch} transactionMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMatchesUpdate(id: number, transactionMatch: TransactionMatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionMatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMatchesUpdate(id, transactionMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMatchesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Merge two offsetting chart transactions from different journals.          This endpoint consolidates journals containing offsetting transactions by removing         the specified transactions and combining the remaining transactions into a single journal entry.          **Request Body:**         - `transaction_ids` (array, required): Array of exactly two transaction IDs to merge          **Returns:**         The merged journal entry with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity          **Result:**         - The two specified transactions are deleted         - Other transactions from both journals are consolidated into a single journal         - A draft queue record is created for audit purposes and auto-approved         
         * @summary Merge Chart Transactions
         * @param {CoaApiTransactionMergeCreateRequest} [coaApiTransactionMergeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMergeCreate(coaApiTransactionMergeCreateRequest?: CoaApiTransactionMergeCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMergeCreate(coaApiTransactionMergeCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMergeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Preview the result of merging two chart transactions.          This endpoint shows what the merged journal entry will look like, allowing you to verify         the merge before committing. The preview includes the journal that will be retained and         the transactions that will remain after the merge.          **Parameters:**         - `transaction_ids` (query, required): Comma-separated list of exactly two transaction IDs          **Returns:**         A journal entry object containing the merged result with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity         
         * @summary Preview Chart Transaction Merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionMergeRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionMergeRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiTransactionMergeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a bill amortization schedule.
         * @summary Create Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an amortization schedule for a specific bill.
         * @summary Create Bill Amortization
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationCreate2(billId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationCreate2(billId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationCreate2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a bill amortization schedule.
         * @summary Delete Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationDestroy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationDestroy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the amortization schedule for a specific bill.
         * @summary Delete Bill Amortization
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationDestroy2(billId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationDestroy2(billId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationDestroy2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a preview of the amortization schedule without persisting it.
         * @summary Preview Amortization Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationGenerateScheduleRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationGenerateScheduleRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationGenerateScheduleRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate and persist an amortization schedule for a bill.
         * @summary Generate Amortization Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationGenerateScheduleUpdate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationGenerateScheduleUpdate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationGenerateScheduleUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve bill amortization data across all bills.
         * @summary Get Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the amortization schedule for a specific bill.
         * @summary Get Bill Amortization
         * @param {number} billId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1BillAmortizationRetrieve2(billId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1BillAmortizationRetrieve2(billId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1BillAmortizationRetrieve2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate and download a PDF of the credit memo.
         * @summary Get Credit Memo PDF
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoPdfRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoPdfRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1CreditMemoPdfRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a single credit memo via email.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1CreditMemoSendUpdate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1CreditMemoSendUpdate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1CreditMemoSendUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a customer statement PDF for a specific client.  This creates a professional, customer-facing statement showing: - All outstanding invoices as of the specified date - Running balance - Total balance due - Payment advice slip
         * @param {number} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiV1InvoiceStatementClientPdfRetrieve(clientId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiV1InvoiceStatementClientPdfRetrieve(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiV1InvoiceStatementClientPdfRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new vendor custom field value.
         * @summary Create Vendor Custom Field
         * @param {VendorCustomField1} [vendorCustomField1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorCustomField1Create(vendorCustomField1?: VendorCustomField1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorCustomField1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorCustomField1Create(vendorCustomField1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiVendorCustomField1Create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a vendor custom field value.
         * @summary Delete Vendor Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorCustomField1Destroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorCustomField1Destroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiVendorCustomField1Destroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of vendor custom field values.
         * @summary List Vendor Custom Fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorCustomField1List(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorCustomField1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorCustomField1List(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiVendorCustomField1List']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a vendor custom field value.
         * @summary Partial Update Vendor Custom Field
         * @param {number} id 
         * @param {PatchedVendorCustomField1} [patchedVendorCustomField1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorCustomField1PartialUpdate(id: number, patchedVendorCustomField1?: PatchedVendorCustomField1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorCustomField1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorCustomField1PartialUpdate(id, patchedVendorCustomField1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiVendorCustomField1PartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific vendor custom field value by ID.
         * @summary Retrieve Vendor Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorCustomField1Retrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorCustomField1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorCustomField1Retrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiVendorCustomField1Retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a vendor custom field value.
         * @summary Update Vendor Custom Field
         * @param {number} id 
         * @param {VendorCustomField1} [vendorCustomField1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorCustomField1Update(id: number, vendorCustomField1?: VendorCustomField1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorCustomField1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorCustomField1Update(id, vendorCustomField1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiVendorCustomField1Update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve summary information for all vendors including spend totals and payment status.
         * @summary List Vendor Summaries
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorSummaryList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendorSummaryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorSummaryList(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoaApi.coaApiVendorSummaryList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoaApi - factory interface
 */
export const CoaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoaApiFp(configuration)
    return {
        /**
         * Upload invoice email attachment with proper permissions
         * @summary Upload Entity Invoice Email Attachment
         * @param {CoaApiCoaApiEntityAttachmentCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityAttachmentCreate(requestParameters: CoaApiCoaApiEntityAttachmentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiEntityAttachmentCreate(requestParameters.entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * List accounts that are of type FIXED_ASSET for use in automation rule creation. GET /api/fixed-asset-automation/accounts  This endpoint returns only accounts with account_subtype=\'FIXED_ASSET\' to ensure automation rules are created with appropriate accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationAccountsRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiFixedAssetAutomationAccountsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * List fixed asset classes that match a specific account. GET /api/fixed-asset-automation/asset-classes?account_id=<id>  Filters asset classes to only those where asset_account matches the provided account_id. This ensures users can only select compatible asset classes for the chosen account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationAssetClassesRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiFixedAssetAutomationAssetClassesRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
         * @param {CoaApiCoaApiFixedAssetAutomationCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationCreate(requestParameters: CoaApiCoaApiFixedAssetAutomationCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetAutomationRule> {
            return localVarFp.coaApiFixedAssetAutomationCreate(requestParameters.fixedAssetAutomationRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {CoaApiCoaApiFixedAssetAutomationDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationDestroy(requestParameters: CoaApiCoaApiFixedAssetAutomationDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiFixedAssetAutomationDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
         * @param {CoaApiCoaApiFixedAssetAutomationListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationList(requestParameters: CoaApiCoaApiFixedAssetAutomationListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFixedAssetAutomationRuleList> {
            return localVarFp.coaApiFixedAssetAutomationList(requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {CoaApiCoaApiFixedAssetAutomationMatchPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchPartialUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetAutomationMatch> {
            return localVarFp.coaApiFixedAssetAutomationMatchPartialUpdate(requestParameters.id, requestParameters.patchedFixedAssetAutomationMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {CoaApiCoaApiFixedAssetAutomationMatchRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchRetrieve(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetAutomationMatch> {
            return localVarFp.coaApiFixedAssetAutomationMatchRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
         * @param {CoaApiCoaApiFixedAssetAutomationMatchUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetAutomationMatch> {
            return localVarFp.coaApiFixedAssetAutomationMatchUpdate(requestParameters.id, requestParameters.fixedAssetAutomationMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * List pending asset matches for review. GET /api/fixed-asset-automation/matches
         * @param {CoaApiCoaApiFixedAssetAutomationMatchesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationMatchesList(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchesListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFixedAssetAutomationMatchList> {
            return localVarFp.coaApiFixedAssetAutomationMatchesList(requestParameters.limit, requestParameters.offset, requestParameters.ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {CoaApiCoaApiFixedAssetAutomationPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationPartialUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetAutomationRule> {
            return localVarFp.coaApiFixedAssetAutomationPartialUpdate(requestParameters.id, requestParameters.patchedFixedAssetAutomationRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {CoaApiCoaApiFixedAssetAutomationRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationRetrieve(requestParameters: CoaApiCoaApiFixedAssetAutomationRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetAutomationRule> {
            return localVarFp.coaApiFixedAssetAutomationRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger automation processing. POST /api/fixed-asset-automation/run  Optional body: {\"rule_id\": 123}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationRunCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiFixedAssetAutomationRunCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
         * @param {CoaApiCoaApiFixedAssetAutomationUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetAutomationUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetAutomationRule> {
            return localVarFp.coaApiFixedAssetAutomationUpdate(requestParameters.id, requestParameters.fixedAssetAutomationRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple chart transactions in a single request.
         * @summary Bulk Update Chart Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionBulkUpdateCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionBulkUpdateCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger the transaction matching process for bank reconciliation.
         * @summary Process Transaction Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchProcessCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionMatchProcessCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the count of pending transaction matches.
         * @summary Get Transaction Matches Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesCountRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionMatchesCountRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a transaction match record.
         * @summary Delete Transaction Match
         * @param {CoaApiCoaApiTransactionMatchesDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesDestroy(requestParameters: CoaApiCoaApiTransactionMatchesDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionMatchesDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of transaction matches for bank reconciliation review.
         * @summary List Transaction Matches
         * @param {CoaApiCoaApiTransactionMatchesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesList(requestParameters: CoaApiCoaApiTransactionMatchesListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTransactionMatchList> {
            return localVarFp.coaApiTransactionMatchesList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a transaction match record.
         * @summary Partial Update Transaction Match
         * @param {CoaApiCoaApiTransactionMatchesPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesPartialUpdate(requestParameters: CoaApiCoaApiTransactionMatchesPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionMatch> {
            return localVarFp.coaApiTransactionMatchesPartialUpdate(requestParameters.id, requestParameters.patchedTransactionMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject a proposed transaction match.
         * @summary Reject Transaction Match
         * @param {CoaApiCoaApiTransactionMatchesRejectCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesRejectCreate(requestParameters: CoaApiCoaApiTransactionMatchesRejectCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionMatchesRejectCreate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific transaction match by ID.
         * @summary Retrieve Transaction Match
         * @param {CoaApiCoaApiTransactionMatchesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesRetrieve(requestParameters: CoaApiCoaApiTransactionMatchesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionMatch> {
            return localVarFp.coaApiTransactionMatchesRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle POST requests with \'action\' parameter (accept/reject)
         * @param {CoaApiCoaApiTransactionMatchesStatusCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesStatusCreate(requestParameters: CoaApiCoaApiTransactionMatchesStatusCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionMatchesStatusCreate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a transaction match (accept or reject).
         * @summary Update Transaction Match Status
         * @param {CoaApiCoaApiTransactionMatchesStatusUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesStatusUpdate(requestParameters: CoaApiCoaApiTransactionMatchesStatusUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionMatchesStatusUpdate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a transaction match record.
         * @summary Update Transaction Match
         * @param {CoaApiCoaApiTransactionMatchesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMatchesUpdate(requestParameters: CoaApiCoaApiTransactionMatchesUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionMatch> {
            return localVarFp.coaApiTransactionMatchesUpdate(requestParameters.id, requestParameters.transactionMatch, options).then((request) => request(axios, basePath));
        },
        /**
         *          Merge two offsetting chart transactions from different journals.          This endpoint consolidates journals containing offsetting transactions by removing         the specified transactions and combining the remaining transactions into a single journal entry.          **Request Body:**         - `transaction_ids` (array, required): Array of exactly two transaction IDs to merge          **Returns:**         The merged journal entry with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity          **Result:**         - The two specified transactions are deleted         - Other transactions from both journals are consolidated into a single journal         - A draft queue record is created for audit purposes and auto-approved         
         * @summary Merge Chart Transactions
         * @param {CoaApiCoaApiTransactionMergeCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMergeCreate(requestParameters: CoaApiCoaApiTransactionMergeCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntry> {
            return localVarFp.coaApiTransactionMergeCreate(requestParameters.coaApiTransactionMergeCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *          Preview the result of merging two chart transactions.          This endpoint shows what the merged journal entry will look like, allowing you to verify         the merge before committing. The preview includes the journal that will be retained and         the transactions that will remain after the merge.          **Parameters:**         - `transaction_ids` (query, required): Comma-separated list of exactly two transaction IDs          **Returns:**         A journal entry object containing the merged result with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity         
         * @summary Preview Chart Transaction Merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionMergeRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<JournalEntry> {
            return localVarFp.coaApiTransactionMergeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a bill amortization schedule.
         * @summary Create Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Create an amortization schedule for a specific bill.
         * @summary Create Bill Amortization
         * @param {CoaApiCoaApiV1BillAmortizationCreate2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationCreate2(requestParameters: CoaApiCoaApiV1BillAmortizationCreate2Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationCreate2(requestParameters.billId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a bill amortization schedule.
         * @summary Delete Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationDestroy(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationDestroy(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the amortization schedule for a specific bill.
         * @summary Delete Bill Amortization
         * @param {CoaApiCoaApiV1BillAmortizationDestroy2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationDestroy2(requestParameters: CoaApiCoaApiV1BillAmortizationDestroy2Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationDestroy2(requestParameters.billId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a preview of the amortization schedule without persisting it.
         * @summary Preview Amortization Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationGenerateScheduleRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationGenerateScheduleRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate and persist an amortization schedule for a bill.
         * @summary Generate Amortization Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationGenerateScheduleUpdate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationGenerateScheduleUpdate(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve bill amortization data across all bills.
         * @summary Get Bill Amortization (Global)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the amortization schedule for a specific bill.
         * @summary Get Bill Amortization
         * @param {CoaApiCoaApiV1BillAmortizationRetrieve2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1BillAmortizationRetrieve2(requestParameters: CoaApiCoaApiV1BillAmortizationRetrieve2Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1BillAmortizationRetrieve2(requestParameters.billId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate and download a PDF of the credit memo.
         * @summary Get Credit Memo PDF
         * @param {CoaApiCoaApiV1CreditMemoPdfRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoPdfRetrieve(requestParameters: CoaApiCoaApiV1CreditMemoPdfRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1CreditMemoPdfRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a single credit memo via email.
         * @param {CoaApiCoaApiV1CreditMemoSendUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1CreditMemoSendUpdate(requestParameters: CoaApiCoaApiV1CreditMemoSendUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1CreditMemoSendUpdate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a customer statement PDF for a specific client.  This creates a professional, customer-facing statement showing: - All outstanding invoices as of the specified date - Running balance - Total balance due - Payment advice slip
         * @param {CoaApiCoaApiV1InvoiceStatementClientPdfRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiV1InvoiceStatementClientPdfRetrieve(requestParameters: CoaApiCoaApiV1InvoiceStatementClientPdfRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiV1InvoiceStatementClientPdfRetrieve(requestParameters.clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new vendor custom field value.
         * @summary Create Vendor Custom Field
         * @param {CoaApiCoaApiVendorCustomField1CreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Create(requestParameters: CoaApiCoaApiVendorCustomField1CreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<VendorCustomField1> {
            return localVarFp.coaApiVendorCustomField1Create(requestParameters.vendorCustomField1, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a vendor custom field value.
         * @summary Delete Vendor Custom Field
         * @param {CoaApiCoaApiVendorCustomField1DestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Destroy(requestParameters: CoaApiCoaApiVendorCustomField1DestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiVendorCustomField1Destroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of vendor custom field values.
         * @summary List Vendor Custom Fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1List(options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorCustomField1>> {
            return localVarFp.coaApiVendorCustomField1List(options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a vendor custom field value.
         * @summary Partial Update Vendor Custom Field
         * @param {CoaApiCoaApiVendorCustomField1PartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1PartialUpdate(requestParameters: CoaApiCoaApiVendorCustomField1PartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VendorCustomField1> {
            return localVarFp.coaApiVendorCustomField1PartialUpdate(requestParameters.id, requestParameters.patchedVendorCustomField1, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific vendor custom field value by ID.
         * @summary Retrieve Vendor Custom Field
         * @param {CoaApiCoaApiVendorCustomField1RetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Retrieve(requestParameters: CoaApiCoaApiVendorCustomField1RetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<VendorCustomField1> {
            return localVarFp.coaApiVendorCustomField1Retrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a vendor custom field value.
         * @summary Update Vendor Custom Field
         * @param {CoaApiCoaApiVendorCustomField1UpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCustomField1Update(requestParameters: CoaApiCoaApiVendorCustomField1UpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VendorCustomField1> {
            return localVarFp.coaApiVendorCustomField1Update(requestParameters.id, requestParameters.vendorCustomField1, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve summary information for all vendors including spend totals and payment status.
         * @summary List Vendor Summaries
         * @param {CoaApiCoaApiVendorSummaryListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorSummaryList(requestParameters: CoaApiCoaApiVendorSummaryListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendorSummaryList> {
            return localVarFp.coaApiVendorSummaryList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for coaApiEntityAttachmentCreate operation in CoaApi.
 */
export interface CoaApiCoaApiEntityAttachmentCreateRequest {
    readonly entityId: number
}

/**
 * Request parameters for coaApiFixedAssetAutomationCreate operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationCreateRequest {
    readonly fixedAssetAutomationRule: FixedAssetAutomationRule
}

/**
 * Request parameters for coaApiFixedAssetAutomationDestroy operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiFixedAssetAutomationList operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationListRequest {
    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Which field to use when ordering the results.
     */
    readonly ordering?: string

    /**
     * A search term.
     */
    readonly search?: string
}

/**
 * Request parameters for coaApiFixedAssetAutomationMatchPartialUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationMatchPartialUpdateRequest {
    readonly id: number

    readonly patchedFixedAssetAutomationMatch?: PatchedFixedAssetAutomationMatch
}

/**
 * Request parameters for coaApiFixedAssetAutomationMatchRetrieve operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationMatchRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiFixedAssetAutomationMatchUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationMatchUpdateRequest {
    readonly id: number

    readonly fixedAssetAutomationMatch: FixedAssetAutomationMatch
}

/**
 * Request parameters for coaApiFixedAssetAutomationMatchesList operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationMatchesListRequest {
    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Which field to use when ordering the results.
     */
    readonly ordering?: string
}

/**
 * Request parameters for coaApiFixedAssetAutomationPartialUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationPartialUpdateRequest {
    readonly id: number

    readonly patchedFixedAssetAutomationRule?: PatchedFixedAssetAutomationRule
}

/**
 * Request parameters for coaApiFixedAssetAutomationRetrieve operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiFixedAssetAutomationUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiFixedAssetAutomationUpdateRequest {
    readonly id: number

    readonly fixedAssetAutomationRule: FixedAssetAutomationRule
}

/**
 * Request parameters for coaApiTransactionMatchesDestroy operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTransactionMatchesList operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesListRequest {
    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiTransactionMatchesPartialUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesPartialUpdateRequest {
    readonly id: number

    readonly patchedTransactionMatch?: PatchedTransactionMatch
}

/**
 * Request parameters for coaApiTransactionMatchesRejectCreate operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesRejectCreateRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTransactionMatchesRetrieve operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTransactionMatchesStatusCreate operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesStatusCreateRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTransactionMatchesStatusUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesStatusUpdateRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTransactionMatchesUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMatchesUpdateRequest {
    readonly id: number

    readonly transactionMatch: TransactionMatch
}

/**
 * Request parameters for coaApiTransactionMergeCreate operation in CoaApi.
 */
export interface CoaApiCoaApiTransactionMergeCreateRequest {
    readonly coaApiTransactionMergeCreateRequest?: CoaApiTransactionMergeCreateRequest
}

/**
 * Request parameters for coaApiV1BillAmortizationCreate2 operation in CoaApi.
 */
export interface CoaApiCoaApiV1BillAmortizationCreate2Request {
    readonly billId: number
}

/**
 * Request parameters for coaApiV1BillAmortizationDestroy2 operation in CoaApi.
 */
export interface CoaApiCoaApiV1BillAmortizationDestroy2Request {
    readonly billId: number
}

/**
 * Request parameters for coaApiV1BillAmortizationRetrieve2 operation in CoaApi.
 */
export interface CoaApiCoaApiV1BillAmortizationRetrieve2Request {
    readonly billId: number
}

/**
 * Request parameters for coaApiV1CreditMemoPdfRetrieve operation in CoaApi.
 */
export interface CoaApiCoaApiV1CreditMemoPdfRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1CreditMemoSendUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiV1CreditMemoSendUpdateRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiV1InvoiceStatementClientPdfRetrieve operation in CoaApi.
 */
export interface CoaApiCoaApiV1InvoiceStatementClientPdfRetrieveRequest {
    readonly clientId: number
}

/**
 * Request parameters for coaApiVendorCustomField1Create operation in CoaApi.
 */
export interface CoaApiCoaApiVendorCustomField1CreateRequest {
    readonly vendorCustomField1?: VendorCustomField1
}

/**
 * Request parameters for coaApiVendorCustomField1Destroy operation in CoaApi.
 */
export interface CoaApiCoaApiVendorCustomField1DestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiVendorCustomField1PartialUpdate operation in CoaApi.
 */
export interface CoaApiCoaApiVendorCustomField1PartialUpdateRequest {
    readonly id: number

    readonly patchedVendorCustomField1?: PatchedVendorCustomField1
}

/**
 * Request parameters for coaApiVendorCustomField1Retrieve operation in CoaApi.
 */
export interface CoaApiCoaApiVendorCustomField1RetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiVendorCustomField1Update operation in CoaApi.
 */
export interface CoaApiCoaApiVendorCustomField1UpdateRequest {
    readonly id: number

    readonly vendorCustomField1?: VendorCustomField1
}

/**
 * Request parameters for coaApiVendorSummaryList operation in CoaApi.
 */
export interface CoaApiCoaApiVendorSummaryListRequest {
    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * CoaApi - object-oriented interface
 */
export class CoaApi extends BaseAPI {
    /**
     * Upload invoice email attachment with proper permissions
     * @summary Upload Entity Invoice Email Attachment
     * @param {CoaApiCoaApiEntityAttachmentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityAttachmentCreate(requestParameters: CoaApiCoaApiEntityAttachmentCreateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiEntityAttachmentCreate(requestParameters.entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List accounts that are of type FIXED_ASSET for use in automation rule creation. GET /api/fixed-asset-automation/accounts  This endpoint returns only accounts with account_subtype=\'FIXED_ASSET\' to ensure automation rules are created with appropriate accounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationAccountsRetrieve(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationAccountsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List fixed asset classes that match a specific account. GET /api/fixed-asset-automation/asset-classes?account_id=<id>  Filters asset classes to only those where asset_account matches the provided account_id. This ensures users can only select compatible asset classes for the chosen account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationAssetClassesRetrieve(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationAssetClassesRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
     * @param {CoaApiCoaApiFixedAssetAutomationCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationCreate(requestParameters: CoaApiCoaApiFixedAssetAutomationCreateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationCreate(requestParameters.fixedAssetAutomationRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
     * @param {CoaApiCoaApiFixedAssetAutomationDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationDestroy(requestParameters: CoaApiCoaApiFixedAssetAutomationDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all automation rules or create a new one. GET /api/fixed-asset-automation/ POST /api/fixed-asset-automation/
     * @param {CoaApiCoaApiFixedAssetAutomationListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationList(requestParameters: CoaApiCoaApiFixedAssetAutomationListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationList(requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
     * @param {CoaApiCoaApiFixedAssetAutomationMatchPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationMatchPartialUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationMatchPartialUpdate(requestParameters.id, requestParameters.patchedFixedAssetAutomationMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
     * @param {CoaApiCoaApiFixedAssetAutomationMatchRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationMatchRetrieve(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationMatchRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve or update an automation match (for editing proposed values before acceptance). GET/PATCH /api/fixed-asset-automation-match/<id>/
     * @param {CoaApiCoaApiFixedAssetAutomationMatchUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationMatchUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationMatchUpdate(requestParameters.id, requestParameters.fixedAssetAutomationMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List pending asset matches for review. GET /api/fixed-asset-automation/matches
     * @param {CoaApiCoaApiFixedAssetAutomationMatchesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationMatchesList(requestParameters: CoaApiCoaApiFixedAssetAutomationMatchesListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationMatchesList(requestParameters.limit, requestParameters.offset, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
     * @param {CoaApiCoaApiFixedAssetAutomationPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationPartialUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationPartialUpdate(requestParameters.id, requestParameters.patchedFixedAssetAutomationRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
     * @param {CoaApiCoaApiFixedAssetAutomationRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationRetrieve(requestParameters: CoaApiCoaApiFixedAssetAutomationRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger automation processing. POST /api/fixed-asset-automation/run  Optional body: {\"rule_id\": 123}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationRunCreate(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationRunCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, or delete an automation rule. GET/PUT/PATCH/DELETE /api/fixed-asset-automation/<id>/
     * @param {CoaApiCoaApiFixedAssetAutomationUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetAutomationUpdate(requestParameters: CoaApiCoaApiFixedAssetAutomationUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiFixedAssetAutomationUpdate(requestParameters.id, requestParameters.fixedAssetAutomationRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple chart transactions in a single request.
     * @summary Bulk Update Chart Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionBulkUpdateCreate(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionBulkUpdateCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger the transaction matching process for bank reconciliation.
     * @summary Process Transaction Matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchProcessCreate(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchProcessCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the count of pending transaction matches.
     * @summary Get Transaction Matches Count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesCountRetrieve(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesCountRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a transaction match record.
     * @summary Delete Transaction Match
     * @param {CoaApiCoaApiTransactionMatchesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesDestroy(requestParameters: CoaApiCoaApiTransactionMatchesDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of transaction matches for bank reconciliation review.
     * @summary List Transaction Matches
     * @param {CoaApiCoaApiTransactionMatchesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesList(requestParameters: CoaApiCoaApiTransactionMatchesListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a transaction match record.
     * @summary Partial Update Transaction Match
     * @param {CoaApiCoaApiTransactionMatchesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesPartialUpdate(requestParameters: CoaApiCoaApiTransactionMatchesPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesPartialUpdate(requestParameters.id, requestParameters.patchedTransactionMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject a proposed transaction match.
     * @summary Reject Transaction Match
     * @param {CoaApiCoaApiTransactionMatchesRejectCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesRejectCreate(requestParameters: CoaApiCoaApiTransactionMatchesRejectCreateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesRejectCreate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific transaction match by ID.
     * @summary Retrieve Transaction Match
     * @param {CoaApiCoaApiTransactionMatchesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesRetrieve(requestParameters: CoaApiCoaApiTransactionMatchesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle POST requests with \'action\' parameter (accept/reject)
     * @param {CoaApiCoaApiTransactionMatchesStatusCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesStatusCreate(requestParameters: CoaApiCoaApiTransactionMatchesStatusCreateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesStatusCreate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of a transaction match (accept or reject).
     * @summary Update Transaction Match Status
     * @param {CoaApiCoaApiTransactionMatchesStatusUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesStatusUpdate(requestParameters: CoaApiCoaApiTransactionMatchesStatusUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesStatusUpdate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a transaction match record.
     * @summary Update Transaction Match
     * @param {CoaApiCoaApiTransactionMatchesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMatchesUpdate(requestParameters: CoaApiCoaApiTransactionMatchesUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMatchesUpdate(requestParameters.id, requestParameters.transactionMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Merge two offsetting chart transactions from different journals.          This endpoint consolidates journals containing offsetting transactions by removing         the specified transactions and combining the remaining transactions into a single journal entry.          **Request Body:**         - `transaction_ids` (array, required): Array of exactly two transaction IDs to merge          **Returns:**         The merged journal entry with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity          **Result:**         - The two specified transactions are deleted         - Other transactions from both journals are consolidated into a single journal         - A draft queue record is created for audit purposes and auto-approved         
     * @summary Merge Chart Transactions
     * @param {CoaApiCoaApiTransactionMergeCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMergeCreate(requestParameters: CoaApiCoaApiTransactionMergeCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMergeCreate(requestParameters.coaApiTransactionMergeCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Preview the result of merging two chart transactions.          This endpoint shows what the merged journal entry will look like, allowing you to verify         the merge before committing. The preview includes the journal that will be retained and         the transactions that will remain after the merge.          **Parameters:**         - `transaction_ids` (query, required): Comma-separated list of exactly two transaction IDs          **Returns:**         A journal entry object containing the merged result with all remaining transactions.          **Requirements:**         - Must provide exactly two transaction IDs         - Transactions must be from different journals         - Transactions must have matching amounts         - Transactions must belong to the same entity         
     * @summary Preview Chart Transaction Merge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionMergeRetrieve(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiTransactionMergeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a bill amortization schedule.
     * @summary Create Bill Amortization (Global)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationCreate(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an amortization schedule for a specific bill.
     * @summary Create Bill Amortization
     * @param {CoaApiCoaApiV1BillAmortizationCreate2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationCreate2(requestParameters: CoaApiCoaApiV1BillAmortizationCreate2Request, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationCreate2(requestParameters.billId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a bill amortization schedule.
     * @summary Delete Bill Amortization (Global)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationDestroy(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationDestroy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the amortization schedule for a specific bill.
     * @summary Delete Bill Amortization
     * @param {CoaApiCoaApiV1BillAmortizationDestroy2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationDestroy2(requestParameters: CoaApiCoaApiV1BillAmortizationDestroy2Request, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationDestroy2(requestParameters.billId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a preview of the amortization schedule without persisting it.
     * @summary Preview Amortization Schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationGenerateScheduleRetrieve(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationGenerateScheduleRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate and persist an amortization schedule for a bill.
     * @summary Generate Amortization Schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationGenerateScheduleUpdate(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationGenerateScheduleUpdate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve bill amortization data across all bills.
     * @summary Get Bill Amortization (Global)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationRetrieve(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the amortization schedule for a specific bill.
     * @summary Get Bill Amortization
     * @param {CoaApiCoaApiV1BillAmortizationRetrieve2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1BillAmortizationRetrieve2(requestParameters: CoaApiCoaApiV1BillAmortizationRetrieve2Request, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1BillAmortizationRetrieve2(requestParameters.billId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate and download a PDF of the credit memo.
     * @summary Get Credit Memo PDF
     * @param {CoaApiCoaApiV1CreditMemoPdfRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoPdfRetrieve(requestParameters: CoaApiCoaApiV1CreditMemoPdfRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1CreditMemoPdfRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a single credit memo via email.
     * @param {CoaApiCoaApiV1CreditMemoSendUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1CreditMemoSendUpdate(requestParameters: CoaApiCoaApiV1CreditMemoSendUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1CreditMemoSendUpdate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a customer statement PDF for a specific client.  This creates a professional, customer-facing statement showing: - All outstanding invoices as of the specified date - Running balance - Total balance due - Payment advice slip
     * @param {CoaApiCoaApiV1InvoiceStatementClientPdfRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiV1InvoiceStatementClientPdfRetrieve(requestParameters: CoaApiCoaApiV1InvoiceStatementClientPdfRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiV1InvoiceStatementClientPdfRetrieve(requestParameters.clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new vendor custom field value.
     * @summary Create Vendor Custom Field
     * @param {CoaApiCoaApiVendorCustomField1CreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorCustomField1Create(requestParameters: CoaApiCoaApiVendorCustomField1CreateRequest = {}, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiVendorCustomField1Create(requestParameters.vendorCustomField1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a vendor custom field value.
     * @summary Delete Vendor Custom Field
     * @param {CoaApiCoaApiVendorCustomField1DestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorCustomField1Destroy(requestParameters: CoaApiCoaApiVendorCustomField1DestroyRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiVendorCustomField1Destroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of vendor custom field values.
     * @summary List Vendor Custom Fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorCustomField1List(options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiVendorCustomField1List(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a vendor custom field value.
     * @summary Partial Update Vendor Custom Field
     * @param {CoaApiCoaApiVendorCustomField1PartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorCustomField1PartialUpdate(requestParameters: CoaApiCoaApiVendorCustomField1PartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiVendorCustomField1PartialUpdate(requestParameters.id, requestParameters.patchedVendorCustomField1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific vendor custom field value by ID.
     * @summary Retrieve Vendor Custom Field
     * @param {CoaApiCoaApiVendorCustomField1RetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorCustomField1Retrieve(requestParameters: CoaApiCoaApiVendorCustomField1RetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiVendorCustomField1Retrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a vendor custom field value.
     * @summary Update Vendor Custom Field
     * @param {CoaApiCoaApiVendorCustomField1UpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorCustomField1Update(requestParameters: CoaApiCoaApiVendorCustomField1UpdateRequest, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiVendorCustomField1Update(requestParameters.id, requestParameters.vendorCustomField1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve summary information for all vendors including spend totals and payment status.
     * @summary List Vendor Summaries
     * @param {CoaApiCoaApiVendorSummaryListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorSummaryList(requestParameters: CoaApiCoaApiVendorSummaryListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoaApiFp(this.configuration).coaApiVendorSummaryList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompanyObjectsApi - axios parameter creator
 */
export const CompanyObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new custom field for a given app and model
         * @summary Create Custom Field
         * @param {CustomField} customField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsCreate: async (customField: CustomField, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customField' is not null or undefined
            assertParamExists('caApiV1CustomFieldsCreate', 'customField', customField)
            const localVarPath = `/ca/api/v1/custom-fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customField, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiV1CustomFieldsDestroy', 'id', id)
            const localVarPath = `/ca/api/v1/custom-fields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          List all custom fields for a given app and model.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Custom Fields
         * @param {string} [app] App name
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [isActive] Filter by active status
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [model] Model name
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsList: async (app?: string, includeDeleted?: boolean, isActive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, model?: string, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/v1/custom-fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Custom Field
         * @param {number} id 
         * @param {PatchedCustomField} [patchedCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsPartialUpdate: async (id: number, patchedCustomField?: PatchedCustomField, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiV1CustomFieldsPartialUpdate', 'id', id)
            const localVarPath = `/ca/api/v1/custom-fields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomField, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiV1CustomFieldsRetrieve', 'id', id)
            const localVarPath = `/ca/api/v1/custom-fields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Custom Field
         * @param {number} id 
         * @param {CustomField} customField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsUpdate: async (id: number, customField: CustomField, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiV1CustomFieldsUpdate', 'id', id)
            // verify required parameter 'customField' is not null or undefined
            assertParamExists('caApiV1CustomFieldsUpdate', 'customField', customField)
            const localVarPath = `/ca/api/v1/custom-fields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customField, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List balance sheet accounts. Reuses AccountListCreate with account_type filter.
         * @summary Create Chart Account
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountBalanceSheetCreate: async (chartAccount: ChartAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartAccount' is not null or undefined
            assertParamExists('coaApiAccountBalanceSheetCreate', 'chartAccount', chartAccount)
            const localVarPath = `/coa/api/account/balance-sheet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of chart accounts with optional filtering and sorting
         * @summary List Chart Accounts
         * @param {number} [account] Filter by account ID. Can be specified multiple times for multiple accounts
         * @param {string} [accountSubtype] Filter by account subtype. Can be specified multiple times for multiple subtypes
         * @param {string} [accountType] Filter by account type. Can be specified multiple times for multiple types
         * @param {boolean} [includeCostAllocation] Include accounts with cost allocation
         * @param {boolean} [includeInactive] Include inactive accounts in results
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by account name or number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountBalanceSheetList: async (account?: number, accountSubtype?: string, accountType?: string, includeCostAllocation?: boolean, includeInactive?: boolean, limit?: number, offset?: number, q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/account/balance-sheet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (accountSubtype !== undefined) {
                localVarQueryParameter['account_subtype'] = accountSubtype;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['account_type'] = accountType;
            }

            if (includeCostAllocation !== undefined) {
                localVarQueryParameter['include_cost_allocation'] = includeCostAllocation;
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = includeInactive;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Chart Account
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountCreate: async (chartAccount: ChartAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartAccount' is not null or undefined
            assertParamExists('coaApiAccountCreate', 'chartAccount', chartAccount)
            const localVarPath = `/coa/api/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Chart Account
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiAccountDestroy', 'id', id)
            const localVarPath = `/coa/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List income statement accounts. Reuses AccountListCreate with account_type filter.
         * @summary Create Chart Account
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountIncomeStatementCreate: async (chartAccount: ChartAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chartAccount' is not null or undefined
            assertParamExists('coaApiAccountIncomeStatementCreate', 'chartAccount', chartAccount)
            const localVarPath = `/coa/api/account/income-statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List income statement accounts. Reuses AccountListCreate with account_type filter.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountIncomeStatementList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/account/income-statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountList: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Chart Account
         * @param {number} id 
         * @param {PatchedChartAccount} [patchedChartAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountPartialUpdate: async (id: number, patchedChartAccount?: PatchedChartAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiAccountPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedChartAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Chart Account
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiAccountRetrieve', 'id', id)
            const localVarPath = `/coa/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Chart Account
         * @param {number} id 
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountUpdate: async (id: number, chartAccount: ChartAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiAccountUpdate', 'id', id)
            // verify required parameter 'chartAccount' is not null or undefined
            assertParamExists('coaApiAccountUpdate', 'chartAccount', chartAccount)
            const localVarPath = `/coa/api/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Cost Allocation
         * @param {CostAllocation} costAllocation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsCreate: async (costAllocation: CostAllocation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'costAllocation' is not null or undefined
            assertParamExists('coaApiCostAllocationsCreate', 'costAllocation', costAllocation)
            const localVarPath = `/coa/api/cost-allocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(costAllocation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Cost Allocation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiCostAllocationsDestroy', 'id', id)
            const localVarPath = `/coa/api/cost-allocations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of cost allocations with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Cost Allocation
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsList: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/cost-allocations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Cost Allocation
         * @param {number} id 
         * @param {PatchedCostAllocation} [patchedCostAllocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsPartialUpdate: async (id: number, patchedCostAllocation?: PatchedCostAllocation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiCostAllocationsPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/cost-allocations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCostAllocation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cost Allocation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiCostAllocationsRetrieve', 'id', id)
            const localVarPath = `/coa/api/cost-allocations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Cost Allocation
         * @param {number} id 
         * @param {CostAllocation} costAllocation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsUpdate: async (id: number, costAllocation: CostAllocation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiCostAllocationsUpdate', 'id', id)
            // verify required parameter 'costAllocation' is not null or undefined
            assertParamExists('coaApiCostAllocationsUpdate', 'costAllocation', costAllocation)
            const localVarPath = `/coa/api/cost-allocations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(costAllocation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Department
         * @param {Department} department 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentCreate: async (department: Department, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'department' is not null or undefined
            assertParamExists('coaApiDepartmentCreate', 'department', department)
            const localVarPath = `/coa/api/department`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(department, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a department and optionally reassign all related records to another department
         * @summary Delete Department
         * @param {number} id 
         * @param {number} [newDepartment] ID of the department to reassign all related records to before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentDestroy: async (id: number, newDepartment?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiDepartmentDestroy', 'id', id)
            const localVarPath = `/coa/api/department/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (newDepartment !== undefined) {
                localVarQueryParameter['new_department'] = newDepartment;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of departments with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Departments
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [includeInactive] Include inactive departments in results
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by department name or code
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentList: async (includeDeleted?: boolean, includeInactive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/department`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = includeInactive;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Department
         * @param {number} id 
         * @param {PatchedDepartment} [patchedDepartment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentPartialUpdate: async (id: number, patchedDepartment?: PatchedDepartment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiDepartmentPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/department/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDepartment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Department
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiDepartmentRetrieve', 'id', id)
            const localVarPath = `/coa/api/department/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Department
         * @param {number} id 
         * @param {Department} department 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentUpdate: async (id: number, department: Department, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiDepartmentUpdate', 'id', id)
            // verify required parameter 'department' is not null or undefined
            assertParamExists('coaApiDepartmentUpdate', 'department', department)
            const localVarPath = `/coa/api/department/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(department, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Fixed Asset Class
         * @param {FixedAssetClass} fixedAssetClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassCreate: async (fixedAssetClass: FixedAssetClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fixedAssetClass' is not null or undefined
            assertParamExists('coaApiFixedAssetClassCreate', 'fixedAssetClass', fixedAssetClass)
            const localVarPath = `/coa/api/fixed-asset-class`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixedAssetClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Fixed Asset Class
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetClassDestroy', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-class/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of fixed asset classes with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Fixed Asset Classes
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassList: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/fixed-asset-class`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Fixed Asset Class
         * @param {number} id 
         * @param {PatchedFixedAssetClass} [patchedFixedAssetClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassPartialUpdate: async (id: number, patchedFixedAssetClass?: PatchedFixedAssetClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetClassPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-class/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFixedAssetClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Fixed Asset Class
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetClassRetrieve', 'id', id)
            const localVarPath = `/coa/api/fixed-asset-class/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Fixed Asset Class
         * @param {number} id 
         * @param {FixedAssetClass} fixedAssetClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassUpdate: async (id: number, fixedAssetClass: FixedAssetClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetClassUpdate', 'id', id)
            // verify required parameter 'fixedAssetClass' is not null or undefined
            assertParamExists('coaApiFixedAssetClassUpdate', 'fixedAssetClass', fixedAssetClass)
            const localVarPath = `/coa/api/fixed-asset-class/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixedAssetClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Custom Dimension
         * @param {TransactionTag} transactionTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagCreate: async (transactionTag: TransactionTag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionTag' is not null or undefined
            assertParamExists('coaApiTagCreate', 'transactionTag', transactionTag)
            const localVarPath = `/coa/api/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a transaction tag and optionally merge it with another tag
         * @summary Delete Custom Dimension
         * @param {number} id 
         * @param {number} [newTag] ID of the tag to merge with before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagDestroy: async (id: number, newTag?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagDestroy', 'id', id)
            const localVarPath = `/coa/api/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (newTag !== undefined) {
                localVarQueryParameter['new_tag'] = newTag;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide consistent last_modified_at filtering and sorting functionality for List APIs with comprehensive timestamp computation.
         * @summary Create Custom Dimension Group
         * @param {TransactionTagGroup} transactionTagGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupCreate: async (transactionTagGroup: TransactionTagGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionTagGroup' is not null or undefined
            assertParamExists('coaApiTagGroupCreate', 'transactionTagGroup', transactionTagGroup)
            const localVarPath = `/coa/api/tag-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionTagGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Custom Dimension Group
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagGroupDestroy', 'id', id)
            const localVarPath = `/coa/api/tag-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of transaction tag groups with optional filtering and sorting.          Supports timestamp-based filtering for synchronization and audit purposes.         
         * @summary List Custom Dimension Groups
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by group name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupList: async (lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/tag-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Custom Dimension Group
         * @param {number} id 
         * @param {PatchedTransactionTagGroup} [patchedTransactionTagGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupPartialUpdate: async (id: number, patchedTransactionTagGroup?: PatchedTransactionTagGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagGroupPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/tag-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTransactionTagGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Custom Dimension Group
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagGroupRetrieve', 'id', id)
            const localVarPath = `/coa/api/tag-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Custom Dimension Group
         * @param {number} id 
         * @param {TransactionTagGroup} transactionTagGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupUpdate: async (id: number, transactionTagGroup: TransactionTagGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagGroupUpdate', 'id', id)
            // verify required parameter 'transactionTagGroup' is not null or undefined
            assertParamExists('coaApiTagGroupUpdate', 'transactionTagGroup', transactionTagGroup)
            const localVarPath = `/coa/api/tag-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionTagGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of transaction tags (custom dimensions) with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Custom Dimensions
         * @param {string} [excludeTags] Comma-separated list of tag IDs to exclude
         * @param {number} [group] Filter by tag group ID
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [includeInactive] If true, include inactive tags
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [noGroup] If true, only return tags without a group
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by tag name or group name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Special field: group_name. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagList: async (excludeTags?: string, group?: number, includeDeleted?: boolean, includeInactive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, noGroup?: boolean, offset?: number, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (excludeTags !== undefined) {
                localVarQueryParameter['exclude_tags'] = excludeTags;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = includeInactive;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (noGroup !== undefined) {
                localVarQueryParameter['no_group'] = noGroup;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Custom Dimension
         * @param {number} id 
         * @param {PatchedTransactionTag} [patchedTransactionTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagPartialUpdate: async (id: number, patchedTransactionTag?: PatchedTransactionTag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTransactionTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Custom Dimension
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagRetrieve', 'id', id)
            const localVarPath = `/coa/api/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Custom Dimension
         * @param {number} id 
         * @param {TransactionTag} transactionTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagUpdate: async (id: number, transactionTag: TransactionTag, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTagUpdate', 'id', id)
            // verify required parameter 'transactionTag' is not null or undefined
            assertParamExists('coaApiTagUpdate', 'transactionTag', transactionTag)
            const localVarPath = `/coa/api/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new vendor or customer in the system
         * @summary Create Vendor
         * @param {Vendor} vendor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCreate: async (vendor: Vendor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendor' is not null or undefined
            assertParamExists('coaApiVendorCreate', 'vendor', vendor)
            const localVarPath = `/coa/api/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a vendor and optionally reassign all related records to another vendor
         * @summary Delete Vendor
         * @param {number} id 
         * @param {number} [newVendor] ID of the vendor to reassign all related records to before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorDestroy: async (id: number, newVendor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorDestroy', 'id', id)
            const localVarPath = `/coa/api/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (newVendor !== undefined) {
                localVarQueryParameter['new_vendor'] = newVendor;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of vendors/customers with optional filtering and sorting.          Supports retrieving deleted records for audit purposes. When include_deleted=true,         returns ONLY deleted records with minimal data (id, is_deleted, deleted_at, last_modified_at).         When false or omitted, returns ONLY active records.         
         * @summary List Vendors
         * @param {string} [externalId] Filter by external ID
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [includeInactive] Include inactive vendors in results
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by name, DBA, email, or company name. If numeric, also searches by ID
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
         * @param {CoaApiVendorListVendorTypeEnum} [vendorType] Filter by vendor type. Can be specified multiple times for multiple types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorList: async (externalId?: string, includeDeleted?: boolean, includeInactive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, vendorType?: CoaApiVendorListVendorTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/vendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = includeInactive;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (vendorType !== undefined) {
                localVarQueryParameter['vendor_type'] = vendorType;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Vendor
         * @param {number} id 
         * @param {PatchedVendor} [patchedVendor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorPartialUpdate: async (id: number, patchedVendor?: PatchedVendor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedVendor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Vendor
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorRetrieve', 'id', id)
            const localVarPath = `/coa/api/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Vendor
         * @param {number} id 
         * @param {Vendor} vendor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorUpdate: async (id: number, vendor: Vendor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorUpdate', 'id', id)
            // verify required parameter 'vendor' is not null or undefined
            assertParamExists('coaApiVendorUpdate', 'vendor', vendor)
            const localVarPath = `/coa/api/vendor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyObjectsApi - functional programming interface
 */
export const CompanyObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new custom field for a given app and model
         * @summary Create Custom Field
         * @param {CustomField} customField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiV1CustomFieldsCreate(customField: CustomField, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiV1CustomFieldsCreate(customField, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.caApiV1CustomFieldsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiV1CustomFieldsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiV1CustomFieldsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.caApiV1CustomFieldsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          List all custom fields for a given app and model.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Custom Fields
         * @param {string} [app] App name
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [isActive] Filter by active status
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [model] Model name
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiV1CustomFieldsList(app?: string, includeDeleted?: boolean, isActive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, model?: string, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCustomFieldList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiV1CustomFieldsList(app, includeDeleted, isActive, lastModifiedAtGte, lastModifiedAtLte, limit, model, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.caApiV1CustomFieldsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Custom Field
         * @param {number} id 
         * @param {PatchedCustomField} [patchedCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiV1CustomFieldsPartialUpdate(id: number, patchedCustomField?: PatchedCustomField, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiV1CustomFieldsPartialUpdate(id, patchedCustomField, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.caApiV1CustomFieldsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Custom Field
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiV1CustomFieldsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiV1CustomFieldsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.caApiV1CustomFieldsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Custom Field
         * @param {number} id 
         * @param {CustomField} customField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiV1CustomFieldsUpdate(id: number, customField: CustomField, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiV1CustomFieldsUpdate(id, customField, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.caApiV1CustomFieldsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List balance sheet accounts. Reuses AccountListCreate with account_type filter.
         * @summary Create Chart Account
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountBalanceSheetCreate(chartAccount: ChartAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountBalanceSheetCreate(chartAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountBalanceSheetCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of chart accounts with optional filtering and sorting
         * @summary List Chart Accounts
         * @param {number} [account] Filter by account ID. Can be specified multiple times for multiple accounts
         * @param {string} [accountSubtype] Filter by account subtype. Can be specified multiple times for multiple subtypes
         * @param {string} [accountType] Filter by account type. Can be specified multiple times for multiple types
         * @param {boolean} [includeCostAllocation] Include accounts with cost allocation
         * @param {boolean} [includeInactive] Include inactive accounts in results
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by account name or number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountBalanceSheetList(account?: number, accountSubtype?: string, accountType?: string, includeCostAllocation?: boolean, includeInactive?: boolean, limit?: number, offset?: number, q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChartAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountBalanceSheetList(account, accountSubtype, accountType, includeCostAllocation, includeInactive, limit, offset, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountBalanceSheetList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Chart Account
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountCreate(chartAccount: ChartAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountCreate(chartAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Chart Account
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List income statement accounts. Reuses AccountListCreate with account_type filter.
         * @summary Create Chart Account
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountIncomeStatementCreate(chartAccount: ChartAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountIncomeStatementCreate(chartAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountIncomeStatementCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List income statement accounts. Reuses AccountListCreate with account_type filter.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountIncomeStatementList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChartAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountIncomeStatementList(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountIncomeStatementList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountList(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChartAccountList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountList(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Chart Account
         * @param {number} id 
         * @param {PatchedChartAccount} [patchedChartAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountPartialUpdate(id: number, patchedChartAccount?: PatchedChartAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountPartialUpdate(id, patchedChartAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Chart Account
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Chart Account
         * @param {number} id 
         * @param {ChartAccount} chartAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiAccountUpdate(id: number, chartAccount: ChartAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiAccountUpdate(id, chartAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiAccountUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Cost Allocation
         * @param {CostAllocation} costAllocation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiCostAllocationsCreate(costAllocation: CostAllocation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostAllocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiCostAllocationsCreate(costAllocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiCostAllocationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Cost Allocation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiCostAllocationsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiCostAllocationsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiCostAllocationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of cost allocations with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Cost Allocation
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiCostAllocationsList(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCostAllocationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiCostAllocationsList(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiCostAllocationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Cost Allocation
         * @param {number} id 
         * @param {PatchedCostAllocation} [patchedCostAllocation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiCostAllocationsPartialUpdate(id: number, patchedCostAllocation?: PatchedCostAllocation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostAllocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiCostAllocationsPartialUpdate(id, patchedCostAllocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiCostAllocationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cost Allocation
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiCostAllocationsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostAllocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiCostAllocationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiCostAllocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Cost Allocation
         * @param {number} id 
         * @param {CostAllocation} costAllocation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiCostAllocationsUpdate(id: number, costAllocation: CostAllocation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostAllocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiCostAllocationsUpdate(id, costAllocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiCostAllocationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Department
         * @param {Department} department 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiDepartmentCreate(department: Department, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiDepartmentCreate(department, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiDepartmentCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a department and optionally reassign all related records to another department
         * @summary Delete Department
         * @param {number} id 
         * @param {number} [newDepartment] ID of the department to reassign all related records to before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiDepartmentDestroy(id: number, newDepartment?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiDepartmentDestroy(id, newDepartment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiDepartmentDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of departments with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Departments
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [includeInactive] Include inactive departments in results
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by department name or code
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiDepartmentList(includeDeleted?: boolean, includeInactive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDepartmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiDepartmentList(includeDeleted, includeInactive, lastModifiedAtGte, lastModifiedAtLte, limit, offset, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiDepartmentList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Department
         * @param {number} id 
         * @param {PatchedDepartment} [patchedDepartment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiDepartmentPartialUpdate(id: number, patchedDepartment?: PatchedDepartment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiDepartmentPartialUpdate(id, patchedDepartment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiDepartmentPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Department
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiDepartmentRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiDepartmentRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiDepartmentRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Department
         * @param {number} id 
         * @param {Department} department 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiDepartmentUpdate(id: number, department: Department, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Department>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiDepartmentUpdate(id, department, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiDepartmentUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Fixed Asset Class
         * @param {FixedAssetClass} fixedAssetClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetClassCreate(fixedAssetClass: FixedAssetClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetClassCreate(fixedAssetClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiFixedAssetClassCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Fixed Asset Class
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetClassDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetClassDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiFixedAssetClassDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of fixed asset classes with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Fixed Asset Classes
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetClassList(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFixedAssetClassList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetClassList(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiFixedAssetClassList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Fixed Asset Class
         * @param {number} id 
         * @param {PatchedFixedAssetClass} [patchedFixedAssetClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetClassPartialUpdate(id: number, patchedFixedAssetClass?: PatchedFixedAssetClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetClassPartialUpdate(id, patchedFixedAssetClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiFixedAssetClassPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Fixed Asset Class
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetClassRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetClassRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiFixedAssetClassRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Fixed Asset Class
         * @param {number} id 
         * @param {FixedAssetClass} fixedAssetClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetClassUpdate(id: number, fixedAssetClass: FixedAssetClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAssetClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetClassUpdate(id, fixedAssetClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiFixedAssetClassUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Custom Dimension
         * @param {TransactionTag} transactionTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagCreate(transactionTag: TransactionTag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagCreate(transactionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a transaction tag and optionally merge it with another tag
         * @summary Delete Custom Dimension
         * @param {number} id 
         * @param {number} [newTag] ID of the tag to merge with before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagDestroy(id: number, newTag?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagDestroy(id, newTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mixin to provide consistent last_modified_at filtering and sorting functionality for List APIs with comprehensive timestamp computation.
         * @summary Create Custom Dimension Group
         * @param {TransactionTagGroup} transactionTagGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagGroupCreate(transactionTagGroup: TransactionTagGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTagGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagGroupCreate(transactionTagGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagGroupCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Custom Dimension Group
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagGroupDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagGroupDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagGroupDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of transaction tag groups with optional filtering and sorting.          Supports timestamp-based filtering for synchronization and audit purposes.         
         * @summary List Custom Dimension Groups
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by group name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagGroupList(lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransactionTagGroupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagGroupList(lastModifiedAtGte, lastModifiedAtLte, limit, offset, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagGroupList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Custom Dimension Group
         * @param {number} id 
         * @param {PatchedTransactionTagGroup} [patchedTransactionTagGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagGroupPartialUpdate(id: number, patchedTransactionTagGroup?: PatchedTransactionTagGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTagGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagGroupPartialUpdate(id, patchedTransactionTagGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagGroupPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Custom Dimension Group
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagGroupRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTagGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagGroupRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagGroupRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Custom Dimension Group
         * @param {number} id 
         * @param {TransactionTagGroup} transactionTagGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagGroupUpdate(id: number, transactionTagGroup: TransactionTagGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTagGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagGroupUpdate(id, transactionTagGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagGroupUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of transaction tags (custom dimensions) with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Custom Dimensions
         * @param {string} [excludeTags] Comma-separated list of tag IDs to exclude
         * @param {number} [group] Filter by tag group ID
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [includeInactive] If true, include inactive tags
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [noGroup] If true, only return tags without a group
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by tag name or group name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Special field: group_name. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagList(excludeTags?: string, group?: number, includeDeleted?: boolean, includeInactive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, noGroup?: boolean, offset?: number, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransactionTagList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagList(excludeTags, group, includeDeleted, includeInactive, lastModifiedAtGte, lastModifiedAtLte, limit, noGroup, offset, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Custom Dimension
         * @param {number} id 
         * @param {PatchedTransactionTag} [patchedTransactionTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagPartialUpdate(id: number, patchedTransactionTag?: PatchedTransactionTag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagPartialUpdate(id, patchedTransactionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Custom Dimension
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Custom Dimension
         * @param {number} id 
         * @param {TransactionTag} transactionTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagUpdate(id: number, transactionTag: TransactionTag, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagUpdate(id, transactionTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiTagUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new vendor or customer in the system
         * @summary Create Vendor
         * @param {Vendor} vendor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorCreate(vendor: Vendor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorCreate(vendor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiVendorCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a vendor and optionally reassign all related records to another vendor
         * @summary Delete Vendor
         * @param {number} id 
         * @param {number} [newVendor] ID of the vendor to reassign all related records to before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorDestroy(id: number, newVendor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorDestroy(id, newVendor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiVendorDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of vendors/customers with optional filtering and sorting.          Supports retrieving deleted records for audit purposes. When include_deleted=true,         returns ONLY deleted records with minimal data (id, is_deleted, deleted_at, last_modified_at).         When false or omitted, returns ONLY active records.         
         * @summary List Vendors
         * @param {string} [externalId] Filter by external ID
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {boolean} [includeInactive] Include inactive vendors in results
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by name, DBA, email, or company name. If numeric, also searches by ID
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
         * @param {CoaApiVendorListVendorTypeEnum} [vendorType] Filter by vendor type. Can be specified multiple times for multiple types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorList(externalId?: string, includeDeleted?: boolean, includeInactive?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, vendorType?: CoaApiVendorListVendorTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorList(externalId, includeDeleted, includeInactive, lastModifiedAtGte, lastModifiedAtLte, limit, offset, q, sort, vendorType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiVendorList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Vendor
         * @param {number} id 
         * @param {PatchedVendor} [patchedVendor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorPartialUpdate(id: number, patchedVendor?: PatchedVendor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorPartialUpdate(id, patchedVendor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiVendorPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Vendor
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiVendorRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Vendor
         * @param {number} id 
         * @param {Vendor} vendor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorUpdate(id: number, vendor: Vendor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorUpdate(id, vendor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyObjectsApi.coaApiVendorUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompanyObjectsApi - factory interface
 */
export const CompanyObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyObjectsApiFp(configuration)
    return {
        /**
         * Create a new custom field for a given app and model
         * @summary Create Custom Field
         * @param {CompanyObjectsApiCaApiV1CustomFieldsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsCreate(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomField> {
            return localVarFp.caApiV1CustomFieldsCreate(requestParameters.customField, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Custom Field
         * @param {CompanyObjectsApiCaApiV1CustomFieldsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsDestroy(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiV1CustomFieldsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          List all custom fields for a given app and model.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Custom Fields
         * @param {CompanyObjectsApiCaApiV1CustomFieldsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsList(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCustomFieldList> {
            return localVarFp.caApiV1CustomFieldsList(requestParameters.app, requestParameters.includeDeleted, requestParameters.isActive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.model, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Custom Field
         * @param {CompanyObjectsApiCaApiV1CustomFieldsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsPartialUpdate(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomField> {
            return localVarFp.caApiV1CustomFieldsPartialUpdate(requestParameters.id, requestParameters.patchedCustomField, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Custom Field
         * @param {CompanyObjectsApiCaApiV1CustomFieldsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsRetrieve(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomField> {
            return localVarFp.caApiV1CustomFieldsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Custom Field
         * @param {CompanyObjectsApiCaApiV1CustomFieldsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsUpdate(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomField> {
            return localVarFp.caApiV1CustomFieldsUpdate(requestParameters.id, requestParameters.customField, options).then((request) => request(axios, basePath));
        },
        /**
         * List balance sheet accounts. Reuses AccountListCreate with account_type filter.
         * @summary Create Chart Account
         * @param {CompanyObjectsApiCoaApiAccountBalanceSheetCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountBalanceSheetCreate(requestParameters: CompanyObjectsApiCoaApiAccountBalanceSheetCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccount> {
            return localVarFp.coaApiAccountBalanceSheetCreate(requestParameters.chartAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of chart accounts with optional filtering and sorting
         * @summary List Chart Accounts
         * @param {CompanyObjectsApiCoaApiAccountBalanceSheetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountBalanceSheetList(requestParameters: CompanyObjectsApiCoaApiAccountBalanceSheetListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChartAccountList> {
            return localVarFp.coaApiAccountBalanceSheetList(requestParameters.account, requestParameters.accountSubtype, requestParameters.accountType, requestParameters.includeCostAllocation, requestParameters.includeInactive, requestParameters.limit, requestParameters.offset, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Chart Account
         * @param {CompanyObjectsApiCoaApiAccountCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountCreate(requestParameters: CompanyObjectsApiCoaApiAccountCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccount> {
            return localVarFp.coaApiAccountCreate(requestParameters.chartAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Chart Account
         * @param {CompanyObjectsApiCoaApiAccountDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountDestroy(requestParameters: CompanyObjectsApiCoaApiAccountDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiAccountDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List income statement accounts. Reuses AccountListCreate with account_type filter.
         * @summary Create Chart Account
         * @param {CompanyObjectsApiCoaApiAccountIncomeStatementCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountIncomeStatementCreate(requestParameters: CompanyObjectsApiCoaApiAccountIncomeStatementCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccount> {
            return localVarFp.coaApiAccountIncomeStatementCreate(requestParameters.chartAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * List income statement accounts. Reuses AccountListCreate with account_type filter.
         * @param {CompanyObjectsApiCoaApiAccountIncomeStatementListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountIncomeStatementList(requestParameters: CompanyObjectsApiCoaApiAccountIncomeStatementListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChartAccountList> {
            return localVarFp.coaApiAccountIncomeStatementList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @param {CompanyObjectsApiCoaApiAccountListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountList(requestParameters: CompanyObjectsApiCoaApiAccountListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedChartAccountList> {
            return localVarFp.coaApiAccountList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Chart Account
         * @param {CompanyObjectsApiCoaApiAccountPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountPartialUpdate(requestParameters: CompanyObjectsApiCoaApiAccountPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccount> {
            return localVarFp.coaApiAccountPartialUpdate(requestParameters.id, requestParameters.patchedChartAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Chart Account
         * @param {CompanyObjectsApiCoaApiAccountRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountRetrieve(requestParameters: CompanyObjectsApiCoaApiAccountRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccount> {
            return localVarFp.coaApiAccountRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Chart Account
         * @param {CompanyObjectsApiCoaApiAccountUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiAccountUpdate(requestParameters: CompanyObjectsApiCoaApiAccountUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccount> {
            return localVarFp.coaApiAccountUpdate(requestParameters.id, requestParameters.chartAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Cost Allocation
         * @param {CompanyObjectsApiCoaApiCostAllocationsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsCreate(requestParameters: CompanyObjectsApiCoaApiCostAllocationsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CostAllocation> {
            return localVarFp.coaApiCostAllocationsCreate(requestParameters.costAllocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Cost Allocation
         * @param {CompanyObjectsApiCoaApiCostAllocationsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsDestroy(requestParameters: CompanyObjectsApiCoaApiCostAllocationsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiCostAllocationsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of cost allocations with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Cost Allocation
         * @param {CompanyObjectsApiCoaApiCostAllocationsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsList(requestParameters: CompanyObjectsApiCoaApiCostAllocationsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCostAllocationList> {
            return localVarFp.coaApiCostAllocationsList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Cost Allocation
         * @param {CompanyObjectsApiCoaApiCostAllocationsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsPartialUpdate(requestParameters: CompanyObjectsApiCoaApiCostAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CostAllocation> {
            return localVarFp.coaApiCostAllocationsPartialUpdate(requestParameters.id, requestParameters.patchedCostAllocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cost Allocation
         * @param {CompanyObjectsApiCoaApiCostAllocationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsRetrieve(requestParameters: CompanyObjectsApiCoaApiCostAllocationsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<CostAllocation> {
            return localVarFp.coaApiCostAllocationsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Cost Allocation
         * @param {CompanyObjectsApiCoaApiCostAllocationsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiCostAllocationsUpdate(requestParameters: CompanyObjectsApiCoaApiCostAllocationsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CostAllocation> {
            return localVarFp.coaApiCostAllocationsUpdate(requestParameters.id, requestParameters.costAllocation, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Department
         * @param {CompanyObjectsApiCoaApiDepartmentCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentCreate(requestParameters: CompanyObjectsApiCoaApiDepartmentCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Department> {
            return localVarFp.coaApiDepartmentCreate(requestParameters.department, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a department and optionally reassign all related records to another department
         * @summary Delete Department
         * @param {CompanyObjectsApiCoaApiDepartmentDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentDestroy(requestParameters: CompanyObjectsApiCoaApiDepartmentDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiDepartmentDestroy(requestParameters.id, requestParameters.newDepartment, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of departments with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Departments
         * @param {CompanyObjectsApiCoaApiDepartmentListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentList(requestParameters: CompanyObjectsApiCoaApiDepartmentListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedDepartmentList> {
            return localVarFp.coaApiDepartmentList(requestParameters.includeDeleted, requestParameters.includeInactive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Department
         * @param {CompanyObjectsApiCoaApiDepartmentPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentPartialUpdate(requestParameters: CompanyObjectsApiCoaApiDepartmentPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Department> {
            return localVarFp.coaApiDepartmentPartialUpdate(requestParameters.id, requestParameters.patchedDepartment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Department
         * @param {CompanyObjectsApiCoaApiDepartmentRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentRetrieve(requestParameters: CompanyObjectsApiCoaApiDepartmentRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Department> {
            return localVarFp.coaApiDepartmentRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Department
         * @param {CompanyObjectsApiCoaApiDepartmentUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentUpdate(requestParameters: CompanyObjectsApiCoaApiDepartmentUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Department> {
            return localVarFp.coaApiDepartmentUpdate(requestParameters.id, requestParameters.department, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Fixed Asset Class
         * @param {CompanyObjectsApiCoaApiFixedAssetClassCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassCreate(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetClass> {
            return localVarFp.coaApiFixedAssetClassCreate(requestParameters.fixedAssetClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Fixed Asset Class
         * @param {CompanyObjectsApiCoaApiFixedAssetClassDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassDestroy(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiFixedAssetClassDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of fixed asset classes with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Fixed Asset Classes
         * @param {CompanyObjectsApiCoaApiFixedAssetClassListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassList(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFixedAssetClassList> {
            return localVarFp.coaApiFixedAssetClassList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Fixed Asset Class
         * @param {CompanyObjectsApiCoaApiFixedAssetClassPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassPartialUpdate(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetClass> {
            return localVarFp.coaApiFixedAssetClassPartialUpdate(requestParameters.id, requestParameters.patchedFixedAssetClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Fixed Asset Class
         * @param {CompanyObjectsApiCoaApiFixedAssetClassRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassRetrieve(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetClass> {
            return localVarFp.coaApiFixedAssetClassRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Fixed Asset Class
         * @param {CompanyObjectsApiCoaApiFixedAssetClassUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetClassUpdate(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAssetClass> {
            return localVarFp.coaApiFixedAssetClassUpdate(requestParameters.id, requestParameters.fixedAssetClass, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Custom Dimension
         * @param {CompanyObjectsApiCoaApiTagCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagCreate(requestParameters: CompanyObjectsApiCoaApiTagCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTag> {
            return localVarFp.coaApiTagCreate(requestParameters.transactionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a transaction tag and optionally merge it with another tag
         * @summary Delete Custom Dimension
         * @param {CompanyObjectsApiCoaApiTagDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagDestroy(requestParameters: CompanyObjectsApiCoaApiTagDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTagDestroy(requestParameters.id, requestParameters.newTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide consistent last_modified_at filtering and sorting functionality for List APIs with comprehensive timestamp computation.
         * @summary Create Custom Dimension Group
         * @param {CompanyObjectsApiCoaApiTagGroupCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupCreate(requestParameters: CompanyObjectsApiCoaApiTagGroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTagGroup> {
            return localVarFp.coaApiTagGroupCreate(requestParameters.transactionTagGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Custom Dimension Group
         * @param {CompanyObjectsApiCoaApiTagGroupDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupDestroy(requestParameters: CompanyObjectsApiCoaApiTagGroupDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTagGroupDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of transaction tag groups with optional filtering and sorting.          Supports timestamp-based filtering for synchronization and audit purposes.         
         * @summary List Custom Dimension Groups
         * @param {CompanyObjectsApiCoaApiTagGroupListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupList(requestParameters: CompanyObjectsApiCoaApiTagGroupListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTransactionTagGroupList> {
            return localVarFp.coaApiTagGroupList(requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Custom Dimension Group
         * @param {CompanyObjectsApiCoaApiTagGroupPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupPartialUpdate(requestParameters: CompanyObjectsApiCoaApiTagGroupPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTagGroup> {
            return localVarFp.coaApiTagGroupPartialUpdate(requestParameters.id, requestParameters.patchedTransactionTagGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Custom Dimension Group
         * @param {CompanyObjectsApiCoaApiTagGroupRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupRetrieve(requestParameters: CompanyObjectsApiCoaApiTagGroupRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTagGroup> {
            return localVarFp.coaApiTagGroupRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Custom Dimension Group
         * @param {CompanyObjectsApiCoaApiTagGroupUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagGroupUpdate(requestParameters: CompanyObjectsApiCoaApiTagGroupUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTagGroup> {
            return localVarFp.coaApiTagGroupUpdate(requestParameters.id, requestParameters.transactionTagGroup, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of transaction tags (custom dimensions) with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Custom Dimensions
         * @param {CompanyObjectsApiCoaApiTagListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagList(requestParameters: CompanyObjectsApiCoaApiTagListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTransactionTagList> {
            return localVarFp.coaApiTagList(requestParameters.excludeTags, requestParameters.group, requestParameters.includeDeleted, requestParameters.includeInactive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.noGroup, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Custom Dimension
         * @param {CompanyObjectsApiCoaApiTagPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagPartialUpdate(requestParameters: CompanyObjectsApiCoaApiTagPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTag> {
            return localVarFp.coaApiTagPartialUpdate(requestParameters.id, requestParameters.patchedTransactionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Custom Dimension
         * @param {CompanyObjectsApiCoaApiTagRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagRetrieve(requestParameters: CompanyObjectsApiCoaApiTagRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTag> {
            return localVarFp.coaApiTagRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Custom Dimension
         * @param {CompanyObjectsApiCoaApiTagUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagUpdate(requestParameters: CompanyObjectsApiCoaApiTagUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionTag> {
            return localVarFp.coaApiTagUpdate(requestParameters.id, requestParameters.transactionTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new vendor or customer in the system
         * @summary Create Vendor
         * @param {CompanyObjectsApiCoaApiVendorCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorCreate(requestParameters: CompanyObjectsApiCoaApiVendorCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.coaApiVendorCreate(requestParameters.vendor, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a vendor and optionally reassign all related records to another vendor
         * @summary Delete Vendor
         * @param {CompanyObjectsApiCoaApiVendorDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorDestroy(requestParameters: CompanyObjectsApiCoaApiVendorDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiVendorDestroy(requestParameters.id, requestParameters.newVendor, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of vendors/customers with optional filtering and sorting.          Supports retrieving deleted records for audit purposes. When include_deleted=true,         returns ONLY deleted records with minimal data (id, is_deleted, deleted_at, last_modified_at).         When false or omitted, returns ONLY active records.         
         * @summary List Vendors
         * @param {CompanyObjectsApiCoaApiVendorListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorList(requestParameters: CompanyObjectsApiCoaApiVendorListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendorList> {
            return localVarFp.coaApiVendorList(requestParameters.externalId, requestParameters.includeDeleted, requestParameters.includeInactive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.vendorType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Vendor
         * @param {CompanyObjectsApiCoaApiVendorPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorPartialUpdate(requestParameters: CompanyObjectsApiCoaApiVendorPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.coaApiVendorPartialUpdate(requestParameters.id, requestParameters.patchedVendor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Vendor
         * @param {CompanyObjectsApiCoaApiVendorRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorRetrieve(requestParameters: CompanyObjectsApiCoaApiVendorRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.coaApiVendorRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Vendor
         * @param {CompanyObjectsApiCoaApiVendorUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorUpdate(requestParameters: CompanyObjectsApiCoaApiVendorUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Vendor> {
            return localVarFp.coaApiVendorUpdate(requestParameters.id, requestParameters.vendor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for caApiV1CustomFieldsCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCaApiV1CustomFieldsCreateRequest {
    readonly customField: CustomField
}

/**
 * Request parameters for caApiV1CustomFieldsDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCaApiV1CustomFieldsDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for caApiV1CustomFieldsList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCaApiV1CustomFieldsListRequest {
    /**
     * App name
     */
    readonly app?: string

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter by active status
     */
    readonly isActive?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * Model name
     */
    readonly model?: string

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for caApiV1CustomFieldsPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCaApiV1CustomFieldsPartialUpdateRequest {
    readonly id: number

    readonly patchedCustomField?: PatchedCustomField
}

/**
 * Request parameters for caApiV1CustomFieldsRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCaApiV1CustomFieldsRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for caApiV1CustomFieldsUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCaApiV1CustomFieldsUpdateRequest {
    readonly id: number

    readonly customField: CustomField
}

/**
 * Request parameters for coaApiAccountBalanceSheetCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountBalanceSheetCreateRequest {
    readonly chartAccount: ChartAccount
}

/**
 * Request parameters for coaApiAccountBalanceSheetList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountBalanceSheetListRequest {
    /**
     * Filter by account ID. Can be specified multiple times for multiple accounts
     */
    readonly account?: number

    /**
     * Filter by account subtype. Can be specified multiple times for multiple subtypes
     */
    readonly accountSubtype?: string

    /**
     * Filter by account type. Can be specified multiple times for multiple types
     */
    readonly accountType?: string

    /**
     * Include accounts with cost allocation
     */
    readonly includeCostAllocation?: boolean

    /**
     * Include inactive accounts in results
     */
    readonly includeInactive?: boolean

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search query - searches by account name or number
     */
    readonly q?: string
}

/**
 * Request parameters for coaApiAccountCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountCreateRequest {
    readonly chartAccount: ChartAccount
}

/**
 * Request parameters for coaApiAccountDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiAccountIncomeStatementCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountIncomeStatementCreateRequest {
    readonly chartAccount: ChartAccount
}

/**
 * Request parameters for coaApiAccountIncomeStatementList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountIncomeStatementListRequest {
    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiAccountList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountListRequest {
    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiAccountPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountPartialUpdateRequest {
    readonly id: number

    readonly patchedChartAccount?: PatchedChartAccount
}

/**
 * Request parameters for coaApiAccountRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiAccountUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiAccountUpdateRequest {
    readonly id: number

    readonly chartAccount: ChartAccount
}

/**
 * Request parameters for coaApiCostAllocationsCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiCostAllocationsCreateRequest {
    readonly costAllocation: CostAllocation
}

/**
 * Request parameters for coaApiCostAllocationsDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiCostAllocationsDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiCostAllocationsList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiCostAllocationsListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiCostAllocationsPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiCostAllocationsPartialUpdateRequest {
    readonly id: number

    readonly patchedCostAllocation?: PatchedCostAllocation
}

/**
 * Request parameters for coaApiCostAllocationsRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiCostAllocationsRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiCostAllocationsUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiCostAllocationsUpdateRequest {
    readonly id: number

    readonly costAllocation: CostAllocation
}

/**
 * Request parameters for coaApiDepartmentCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiDepartmentCreateRequest {
    readonly department: Department
}

/**
 * Request parameters for coaApiDepartmentDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiDepartmentDestroyRequest {
    readonly id: number

    /**
     * ID of the department to reassign all related records to before deletion
     */
    readonly newDepartment?: number
}

/**
 * Request parameters for coaApiDepartmentList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiDepartmentListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Include inactive departments in results
     */
    readonly includeInactive?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search query - searches by department name or code
     */
    readonly q?: string

    /**
     * Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
     */
    readonly sort?: string
}

/**
 * Request parameters for coaApiDepartmentPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiDepartmentPartialUpdateRequest {
    readonly id: number

    readonly patchedDepartment?: PatchedDepartment
}

/**
 * Request parameters for coaApiDepartmentRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiDepartmentRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiDepartmentUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiDepartmentUpdateRequest {
    readonly id: number

    readonly department: Department
}

/**
 * Request parameters for coaApiFixedAssetClassCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiFixedAssetClassCreateRequest {
    readonly fixedAssetClass: FixedAssetClass
}

/**
 * Request parameters for coaApiFixedAssetClassDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiFixedAssetClassDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiFixedAssetClassList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiFixedAssetClassListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiFixedAssetClassPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiFixedAssetClassPartialUpdateRequest {
    readonly id: number

    readonly patchedFixedAssetClass?: PatchedFixedAssetClass
}

/**
 * Request parameters for coaApiFixedAssetClassRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiFixedAssetClassRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiFixedAssetClassUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiFixedAssetClassUpdateRequest {
    readonly id: number

    readonly fixedAssetClass: FixedAssetClass
}

/**
 * Request parameters for coaApiTagCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagCreateRequest {
    readonly transactionTag: TransactionTag
}

/**
 * Request parameters for coaApiTagDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagDestroyRequest {
    readonly id: number

    /**
     * ID of the tag to merge with before deletion
     */
    readonly newTag?: number
}

/**
 * Request parameters for coaApiTagGroupCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagGroupCreateRequest {
    readonly transactionTagGroup: TransactionTagGroup
}

/**
 * Request parameters for coaApiTagGroupDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagGroupDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTagGroupList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagGroupListRequest {
    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search query - searches by group name
     */
    readonly q?: string

    /**
     * Sort order. Use field name for ascending, -field for descending. Default: name
     */
    readonly sort?: string
}

/**
 * Request parameters for coaApiTagGroupPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagGroupPartialUpdateRequest {
    readonly id: number

    readonly patchedTransactionTagGroup?: PatchedTransactionTagGroup
}

/**
 * Request parameters for coaApiTagGroupRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagGroupRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTagGroupUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagGroupUpdateRequest {
    readonly id: number

    readonly transactionTagGroup: TransactionTagGroup
}

/**
 * Request parameters for coaApiTagList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagListRequest {
    /**
     * Comma-separated list of tag IDs to exclude
     */
    readonly excludeTags?: string

    /**
     * Filter by tag group ID
     */
    readonly group?: number

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * If true, include inactive tags
     */
    readonly includeInactive?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * If true, only return tags without a group
     */
    readonly noGroup?: boolean

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search query - searches by tag name or group name
     */
    readonly q?: string

    /**
     * Sort order. Use field name for ascending, -field for descending. Special field: group_name. Default: name
     */
    readonly sort?: string
}

/**
 * Request parameters for coaApiTagPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagPartialUpdateRequest {
    readonly id: number

    readonly patchedTransactionTag?: PatchedTransactionTag
}

/**
 * Request parameters for coaApiTagRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTagUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiTagUpdateRequest {
    readonly id: number

    readonly transactionTag: TransactionTag
}

/**
 * Request parameters for coaApiVendorCreate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiVendorCreateRequest {
    readonly vendor: Vendor
}

/**
 * Request parameters for coaApiVendorDestroy operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiVendorDestroyRequest {
    readonly id: number

    /**
     * ID of the vendor to reassign all related records to before deletion
     */
    readonly newVendor?: number
}

/**
 * Request parameters for coaApiVendorList operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiVendorListRequest {
    /**
     * Filter by external ID
     */
    readonly externalId?: string

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Include inactive vendors in results
     */
    readonly includeInactive?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search query - searches by name, DBA, email, or company name. If numeric, also searches by ID
     */
    readonly q?: string

    /**
     * Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
     */
    readonly sort?: string

    /**
     * Filter by vendor type. Can be specified multiple times for multiple types
     */
    readonly vendorType?: CoaApiVendorListVendorTypeEnum
}

/**
 * Request parameters for coaApiVendorPartialUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiVendorPartialUpdateRequest {
    readonly id: number

    readonly patchedVendor?: PatchedVendor
}

/**
 * Request parameters for coaApiVendorRetrieve operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiVendorRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiVendorUpdate operation in CompanyObjectsApi.
 */
export interface CompanyObjectsApiCoaApiVendorUpdateRequest {
    readonly id: number

    readonly vendor: Vendor
}

/**
 * CompanyObjectsApi - object-oriented interface
 */
export class CompanyObjectsApi extends BaseAPI {
    /**
     * Create a new custom field for a given app and model
     * @summary Create Custom Field
     * @param {CompanyObjectsApiCaApiV1CustomFieldsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiV1CustomFieldsCreate(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).caApiV1CustomFieldsCreate(requestParameters.customField, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Custom Field
     * @param {CompanyObjectsApiCaApiV1CustomFieldsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiV1CustomFieldsDestroy(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).caApiV1CustomFieldsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          List all custom fields for a given app and model.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Custom Fields
     * @param {CompanyObjectsApiCaApiV1CustomFieldsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiV1CustomFieldsList(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).caApiV1CustomFieldsList(requestParameters.app, requestParameters.includeDeleted, requestParameters.isActive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.model, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Custom Field
     * @param {CompanyObjectsApiCaApiV1CustomFieldsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiV1CustomFieldsPartialUpdate(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).caApiV1CustomFieldsPartialUpdate(requestParameters.id, requestParameters.patchedCustomField, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Custom Field
     * @param {CompanyObjectsApiCaApiV1CustomFieldsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiV1CustomFieldsRetrieve(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).caApiV1CustomFieldsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Custom Field
     * @param {CompanyObjectsApiCaApiV1CustomFieldsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiV1CustomFieldsUpdate(requestParameters: CompanyObjectsApiCaApiV1CustomFieldsUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).caApiV1CustomFieldsUpdate(requestParameters.id, requestParameters.customField, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List balance sheet accounts. Reuses AccountListCreate with account_type filter.
     * @summary Create Chart Account
     * @param {CompanyObjectsApiCoaApiAccountBalanceSheetCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountBalanceSheetCreate(requestParameters: CompanyObjectsApiCoaApiAccountBalanceSheetCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountBalanceSheetCreate(requestParameters.chartAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of chart accounts with optional filtering and sorting
     * @summary List Chart Accounts
     * @param {CompanyObjectsApiCoaApiAccountBalanceSheetListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountBalanceSheetList(requestParameters: CompanyObjectsApiCoaApiAccountBalanceSheetListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountBalanceSheetList(requestParameters.account, requestParameters.accountSubtype, requestParameters.accountType, requestParameters.includeCostAllocation, requestParameters.includeInactive, requestParameters.limit, requestParameters.offset, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Chart Account
     * @param {CompanyObjectsApiCoaApiAccountCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountCreate(requestParameters: CompanyObjectsApiCoaApiAccountCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountCreate(requestParameters.chartAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Chart Account
     * @param {CompanyObjectsApiCoaApiAccountDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountDestroy(requestParameters: CompanyObjectsApiCoaApiAccountDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List income statement accounts. Reuses AccountListCreate with account_type filter.
     * @summary Create Chart Account
     * @param {CompanyObjectsApiCoaApiAccountIncomeStatementCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountIncomeStatementCreate(requestParameters: CompanyObjectsApiCoaApiAccountIncomeStatementCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountIncomeStatementCreate(requestParameters.chartAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List income statement accounts. Reuses AccountListCreate with account_type filter.
     * @param {CompanyObjectsApiCoaApiAccountIncomeStatementListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountIncomeStatementList(requestParameters: CompanyObjectsApiCoaApiAccountIncomeStatementListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountIncomeStatementList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @param {CompanyObjectsApiCoaApiAccountListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountList(requestParameters: CompanyObjectsApiCoaApiAccountListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Chart Account
     * @param {CompanyObjectsApiCoaApiAccountPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountPartialUpdate(requestParameters: CompanyObjectsApiCoaApiAccountPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountPartialUpdate(requestParameters.id, requestParameters.patchedChartAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Chart Account
     * @param {CompanyObjectsApiCoaApiAccountRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountRetrieve(requestParameters: CompanyObjectsApiCoaApiAccountRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Chart Account
     * @param {CompanyObjectsApiCoaApiAccountUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiAccountUpdate(requestParameters: CompanyObjectsApiCoaApiAccountUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiAccountUpdate(requestParameters.id, requestParameters.chartAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Cost Allocation
     * @param {CompanyObjectsApiCoaApiCostAllocationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiCostAllocationsCreate(requestParameters: CompanyObjectsApiCoaApiCostAllocationsCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiCostAllocationsCreate(requestParameters.costAllocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Cost Allocation
     * @param {CompanyObjectsApiCoaApiCostAllocationsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiCostAllocationsDestroy(requestParameters: CompanyObjectsApiCoaApiCostAllocationsDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiCostAllocationsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of cost allocations with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Cost Allocation
     * @param {CompanyObjectsApiCoaApiCostAllocationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiCostAllocationsList(requestParameters: CompanyObjectsApiCoaApiCostAllocationsListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiCostAllocationsList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Cost Allocation
     * @param {CompanyObjectsApiCoaApiCostAllocationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiCostAllocationsPartialUpdate(requestParameters: CompanyObjectsApiCoaApiCostAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiCostAllocationsPartialUpdate(requestParameters.id, requestParameters.patchedCostAllocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cost Allocation
     * @param {CompanyObjectsApiCoaApiCostAllocationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiCostAllocationsRetrieve(requestParameters: CompanyObjectsApiCoaApiCostAllocationsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiCostAllocationsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Cost Allocation
     * @param {CompanyObjectsApiCoaApiCostAllocationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiCostAllocationsUpdate(requestParameters: CompanyObjectsApiCoaApiCostAllocationsUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiCostAllocationsUpdate(requestParameters.id, requestParameters.costAllocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Department
     * @param {CompanyObjectsApiCoaApiDepartmentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiDepartmentCreate(requestParameters: CompanyObjectsApiCoaApiDepartmentCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiDepartmentCreate(requestParameters.department, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a department and optionally reassign all related records to another department
     * @summary Delete Department
     * @param {CompanyObjectsApiCoaApiDepartmentDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiDepartmentDestroy(requestParameters: CompanyObjectsApiCoaApiDepartmentDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiDepartmentDestroy(requestParameters.id, requestParameters.newDepartment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of departments with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Departments
     * @param {CompanyObjectsApiCoaApiDepartmentListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiDepartmentList(requestParameters: CompanyObjectsApiCoaApiDepartmentListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiDepartmentList(requestParameters.includeDeleted, requestParameters.includeInactive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Department
     * @param {CompanyObjectsApiCoaApiDepartmentPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiDepartmentPartialUpdate(requestParameters: CompanyObjectsApiCoaApiDepartmentPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiDepartmentPartialUpdate(requestParameters.id, requestParameters.patchedDepartment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Department
     * @param {CompanyObjectsApiCoaApiDepartmentRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiDepartmentRetrieve(requestParameters: CompanyObjectsApiCoaApiDepartmentRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiDepartmentRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Department
     * @param {CompanyObjectsApiCoaApiDepartmentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiDepartmentUpdate(requestParameters: CompanyObjectsApiCoaApiDepartmentUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiDepartmentUpdate(requestParameters.id, requestParameters.department, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Fixed Asset Class
     * @param {CompanyObjectsApiCoaApiFixedAssetClassCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetClassCreate(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiFixedAssetClassCreate(requestParameters.fixedAssetClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Fixed Asset Class
     * @param {CompanyObjectsApiCoaApiFixedAssetClassDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetClassDestroy(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiFixedAssetClassDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of fixed asset classes with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Fixed Asset Classes
     * @param {CompanyObjectsApiCoaApiFixedAssetClassListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetClassList(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiFixedAssetClassList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Fixed Asset Class
     * @param {CompanyObjectsApiCoaApiFixedAssetClassPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetClassPartialUpdate(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiFixedAssetClassPartialUpdate(requestParameters.id, requestParameters.patchedFixedAssetClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Fixed Asset Class
     * @param {CompanyObjectsApiCoaApiFixedAssetClassRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetClassRetrieve(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiFixedAssetClassRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Fixed Asset Class
     * @param {CompanyObjectsApiCoaApiFixedAssetClassUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetClassUpdate(requestParameters: CompanyObjectsApiCoaApiFixedAssetClassUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiFixedAssetClassUpdate(requestParameters.id, requestParameters.fixedAssetClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Custom Dimension
     * @param {CompanyObjectsApiCoaApiTagCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagCreate(requestParameters: CompanyObjectsApiCoaApiTagCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagCreate(requestParameters.transactionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a transaction tag and optionally merge it with another tag
     * @summary Delete Custom Dimension
     * @param {CompanyObjectsApiCoaApiTagDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagDestroy(requestParameters: CompanyObjectsApiCoaApiTagDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagDestroy(requestParameters.id, requestParameters.newTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide consistent last_modified_at filtering and sorting functionality for List APIs with comprehensive timestamp computation.
     * @summary Create Custom Dimension Group
     * @param {CompanyObjectsApiCoaApiTagGroupCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagGroupCreate(requestParameters: CompanyObjectsApiCoaApiTagGroupCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagGroupCreate(requestParameters.transactionTagGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Custom Dimension Group
     * @param {CompanyObjectsApiCoaApiTagGroupDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagGroupDestroy(requestParameters: CompanyObjectsApiCoaApiTagGroupDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagGroupDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of transaction tag groups with optional filtering and sorting.          Supports timestamp-based filtering for synchronization and audit purposes.         
     * @summary List Custom Dimension Groups
     * @param {CompanyObjectsApiCoaApiTagGroupListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagGroupList(requestParameters: CompanyObjectsApiCoaApiTagGroupListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagGroupList(requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Custom Dimension Group
     * @param {CompanyObjectsApiCoaApiTagGroupPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagGroupPartialUpdate(requestParameters: CompanyObjectsApiCoaApiTagGroupPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagGroupPartialUpdate(requestParameters.id, requestParameters.patchedTransactionTagGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Custom Dimension Group
     * @param {CompanyObjectsApiCoaApiTagGroupRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagGroupRetrieve(requestParameters: CompanyObjectsApiCoaApiTagGroupRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagGroupRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Custom Dimension Group
     * @param {CompanyObjectsApiCoaApiTagGroupUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagGroupUpdate(requestParameters: CompanyObjectsApiCoaApiTagGroupUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagGroupUpdate(requestParameters.id, requestParameters.transactionTagGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of transaction tags (custom dimensions) with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Custom Dimensions
     * @param {CompanyObjectsApiCoaApiTagListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagList(requestParameters: CompanyObjectsApiCoaApiTagListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagList(requestParameters.excludeTags, requestParameters.group, requestParameters.includeDeleted, requestParameters.includeInactive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.noGroup, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Custom Dimension
     * @param {CompanyObjectsApiCoaApiTagPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagPartialUpdate(requestParameters: CompanyObjectsApiCoaApiTagPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagPartialUpdate(requestParameters.id, requestParameters.patchedTransactionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Custom Dimension
     * @param {CompanyObjectsApiCoaApiTagRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagRetrieve(requestParameters: CompanyObjectsApiCoaApiTagRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Custom Dimension
     * @param {CompanyObjectsApiCoaApiTagUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagUpdate(requestParameters: CompanyObjectsApiCoaApiTagUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiTagUpdate(requestParameters.id, requestParameters.transactionTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new vendor or customer in the system
     * @summary Create Vendor
     * @param {CompanyObjectsApiCoaApiVendorCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorCreate(requestParameters: CompanyObjectsApiCoaApiVendorCreateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiVendorCreate(requestParameters.vendor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a vendor and optionally reassign all related records to another vendor
     * @summary Delete Vendor
     * @param {CompanyObjectsApiCoaApiVendorDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorDestroy(requestParameters: CompanyObjectsApiCoaApiVendorDestroyRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiVendorDestroy(requestParameters.id, requestParameters.newVendor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of vendors/customers with optional filtering and sorting.          Supports retrieving deleted records for audit purposes. When include_deleted=true,         returns ONLY deleted records with minimal data (id, is_deleted, deleted_at, last_modified_at).         When false or omitted, returns ONLY active records.         
     * @summary List Vendors
     * @param {CompanyObjectsApiCoaApiVendorListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorList(requestParameters: CompanyObjectsApiCoaApiVendorListRequest = {}, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiVendorList(requestParameters.externalId, requestParameters.includeDeleted, requestParameters.includeInactive, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, requestParameters.vendorType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Vendor
     * @param {CompanyObjectsApiCoaApiVendorPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorPartialUpdate(requestParameters: CompanyObjectsApiCoaApiVendorPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiVendorPartialUpdate(requestParameters.id, requestParameters.patchedVendor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Vendor
     * @param {CompanyObjectsApiCoaApiVendorRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorRetrieve(requestParameters: CompanyObjectsApiCoaApiVendorRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiVendorRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Vendor
     * @param {CompanyObjectsApiCoaApiVendorUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorUpdate(requestParameters: CompanyObjectsApiCoaApiVendorUpdateRequest, options?: RawAxiosRequestConfig) {
        return CompanyObjectsApiFp(this.configuration).coaApiVendorUpdate(requestParameters.id, requestParameters.vendor, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CoaApiVendorListVendorTypeEnum = {
    Customer: 'customer',
    Vendor: 'vendor'
} as const;
export type CoaApiVendorListVendorTypeEnum = typeof CoaApiVendorListVendorTypeEnum[keyof typeof CoaApiVendorListVendorTypeEnum];


/**
 * CoreAccountingApi - axios parameter creator
 */
export const CoreAccountingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Budget
         * @param {number} budgetPk 
         * @param {BudgetAccount} [budgetAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsCreate: async (budgetPk: number, budgetAccount?: BudgetAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetPk' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsCreate', 'budgetPk', budgetPk)
            const localVarPath = `/coa/api/budgets/{budget_pk}/accounts`
                .replace(`{${"budget_pk"}}`, encodeURIComponent(String(budgetPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsDestroy: async (budgetPk: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetPk' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsDestroy', 'budgetPk', budgetPk)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsDestroy', 'id', id)
            const localVarPath = `/coa/api/budgets/{budget_pk}/accounts/{id}`
                .replace(`{${"budget_pk"}}`, encodeURIComponent(String(budgetPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of budget accounts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Budget Accounts
         * @param {number} budgetPk 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsList: async (budgetPk: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetPk' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsList', 'budgetPk', budgetPk)
            const localVarPath = `/coa/api/budgets/{budget_pk}/accounts`
                .replace(`{${"budget_pk"}}`, encodeURIComponent(String(budgetPk)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {PatchedBudgetAccount} [patchedBudgetAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsPartialUpdate: async (budgetPk: number, id: number, patchedBudgetAccount?: PatchedBudgetAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetPk' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsPartialUpdate', 'budgetPk', budgetPk)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/budgets/{budget_pk}/accounts/{id}`
                .replace(`{${"budget_pk"}}`, encodeURIComponent(String(budgetPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBudgetAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsRetrieve: async (budgetPk: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetPk' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsRetrieve', 'budgetPk', budgetPk)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsRetrieve', 'id', id)
            const localVarPath = `/coa/api/budgets/{budget_pk}/accounts/{id}`
                .replace(`{${"budget_pk"}}`, encodeURIComponent(String(budgetPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {BudgetAccount} [budgetAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsUpdate: async (budgetPk: number, id: number, budgetAccount?: BudgetAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetPk' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsUpdate', 'budgetPk', budgetPk)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsAccountsUpdate', 'id', id)
            const localVarPath = `/coa/api/budgets/{budget_pk}/accounts/{id}`
                .replace(`{${"budget_pk"}}`, encodeURIComponent(String(budgetPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Budget
         * @param {Budget} budget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsCreate: async (budget: Budget, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budget' is not null or undefined
            assertParamExists('coaApiBudgetsCreate', 'budget', budget)
            const localVarPath = `/coa/api/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budget, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Budget
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsDestroy', 'id', id)
            const localVarPath = `/coa/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of budgets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Budgets
         * @param {number} [entity] Filter by entity ID
         * @param {string} [entityName] Filter by entity name (partial match)
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by budget name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsList: async (entity?: number, entityName?: string, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (entityName !== undefined) {
                localVarQueryParameter['entity_name'] = entityName;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Budget
         * @param {number} id 
         * @param {PatchedBudget} [patchedBudget] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsPartialUpdate: async (id: number, patchedBudget?: PatchedBudget, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBudget, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Budget
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsRetrieve', 'id', id)
            const localVarPath = `/coa/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Budget
         * @param {number} id 
         * @param {Budget} budget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsUpdate: async (id: number, budget: Budget, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiBudgetsUpdate', 'id', id)
            // verify required parameter 'budget' is not null or undefined
            assertParamExists('coaApiBudgetsUpdate', 'budget', budget)
            const localVarPath = `/coa/api/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budget, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for thousands of departments by exact name match in a single request. Optimized for performance. Supports upsert to create missing departments.
         * @summary Bulk Search Departments by Name
         * @param {BulkDepartmentSearch} bulkDepartmentSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentBulkSearchCreate: async (bulkDepartmentSearch: BulkDepartmentSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDepartmentSearch' is not null or undefined
            assertParamExists('coaApiDepartmentBulkSearchCreate', 'bulkDepartmentSearch', bulkDepartmentSearch)
            const localVarPath = `/coa/api/department/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDepartmentSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Fixed Asset
         * @param {FixedAsset} fixedAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetCreate: async (fixedAsset: FixedAsset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fixedAsset' is not null or undefined
            assertParamExists('coaApiFixedAssetCreate', 'fixedAsset', fixedAsset)
            const localVarPath = `/coa/api/fixed-asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixedAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Fixed Asset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetDestroy', 'id', id)
            const localVarPath = `/coa/api/fixed-asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of fixed assets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Fixed Assets
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetList: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/fixed-asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Fixed Asset
         * @param {number} id 
         * @param {PatchedFixedAsset} [patchedFixedAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetPartialUpdate: async (id: number, patchedFixedAsset?: PatchedFixedAsset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/fixed-asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFixedAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Fixed Asset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetRetrieve', 'id', id)
            const localVarPath = `/coa/api/fixed-asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Fixed Asset
         * @param {number} id 
         * @param {FixedAsset} fixedAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetUpdate: async (id: number, fixedAsset: FixedAsset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiFixedAssetUpdate', 'id', id)
            // verify required parameter 'fixedAsset' is not null or undefined
            assertParamExists('coaApiFixedAssetUpdate', 'fixedAsset', fixedAsset)
            const localVarPath = `/coa/api/fixed-asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixedAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Creates a new intercompany journal entry          This endpoint allows for complex multi-entity transactions where:         - Transactions are balanced across different entities         - Exchange rates are handled for multi-currency transactions          Key requirements:         - Total debits must equal total credits for each entity (debit_amount_native must equal credit_amount_native)         - Cannot create entries before closed book dates         - All referenced accounts must be active         
         * @summary Create Intercompany Journal Entry
         * @param {IntercompanyJournalEntry} [intercompanyJournalEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryCreate: async (intercompanyJournalEntry?: IntercompanyJournalEntry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/intercompany-journal-entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(intercompanyJournalEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Permanently deletes an intercompany journal entry and all related transactions.          This endpoint performs a comprehensive cleanup when deleting an intercompany journal entry:         - Validates that the entry can be deleted (not in closed period)         - Removes all associated journal entries across entities         - Updates summary tables and account balances         - Handles cascade deletion of related transactions         - Ensures data integrity across the accounting system          Deletion restrictions:         - Cannot delete entries in closed accounting periods          Error conditions:         - 400 Bad Request: Entry date is in a closed period         - 409 Conflict: Entry has protected relationships (e.g., close checklist tasks)         - 404 Not Found: Entry does not exist or user lacks access          On successful deletion, all related journal entries are removed and accounting summaries are recalculated.         
         * @summary Delete Intercompany Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiIntercompanyJournalEntryDestroy', 'id', id)
            const localVarPath = `/coa/api/intercompany-journal-entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieves a paginated list of intercompany journal entries for the authenticated user\'s customer.          This endpoint returns:         - Summary information for each intercompany journal entry         - Basic transaction details (simplified view for list performance)         - Entity and exchange rate information         - Pagination metadata (count, next, previous)         - Reversal relationships and attachment counts          The response includes:         - Intercompany journal entry metadata         - Associated transaction summaries         - Entity exchange rate information         - Links to related reversals         - Attachment information          Results can be sorted using the \'sort\' query parameter with field names like \'date\', \'id\', etc.         Prefix with \'-\' for descending order (e.g., \'-date\').         
         * @summary List Intercompany Journal Entries
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryList: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/intercompany-journal-entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Performs a partial update of an intercompany journal entry, allowing modification of specific fields without replacing the entire entry.          This endpoint supports partial updates to:         - Journal entry metadata (memo, date, currency, reference number)         - Individual transaction modifications         - Entity exchange rate adjustments         - Vendor, department, and tag assignments         - Account categorizations and amounts          Key differences from PUT:         - Only specified fields are updated (vs. full replacement)         - Maintains existing data for unspecified fields         - Supports granular transaction modifications         - Preserves audit trail and timestamps         - Allows incremental changes without full transaction rebuilds          Validation requirements:         - Modified transactions must maintain entity balance (debits = credits)         - Cannot modify entries in closed accounting periods         - All referenced accounts, vendors, departments must be active         - Exchange rates must be valid for multi-currency transactions         - Account assignments must be appropriate for transaction types         
         * @summary Partial Update Intercompany Journal Entry
         * @param {number} id 
         * @param {PatchedIntercompanyJournalEntry} [patchedIntercompanyJournalEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryPartialUpdate: async (id: number, patchedIntercompanyJournalEntry?: PatchedIntercompanyJournalEntry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiIntercompanyJournalEntryPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/intercompany-journal-entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIntercompanyJournalEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieves a single intercompany journal entry by its ID with complete details.          This endpoint returns:         - Complete intercompany journal entry information         - Full transaction details with all accounting fields         - Entity information and exchange rates         - Attachment and reversal information         - Comprehensive transaction metadata          The response includes:         - All transaction details with account information         - Entity exchange rate data         - Vendor, department, and tag information         - Balance calculations and transaction history         - File attachments and reversal relationships         - Complete audit trail information          This is the detailed view used for editing and complete transaction analysis.         
         * @summary Get Intercompany Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiIntercompanyJournalEntryRetrieve', 'id', id)
            const localVarPath = `/coa/api/intercompany-journal-entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Updates an existing intercompany journal entry with new transaction details.          This endpoint allows for:         - Modifying transaction amounts and details         - Updating entity assignments and exchange rates         - Changing account assignments and categorizations         - Updating vendor, department, and tag information         - Maintaining balance validation across all entities          Key requirements:         - Total debits must equal total credits for each entity         - All account balances must be valid in all currencies         - Cannot modify entries in closed periods         - All referenced accounts must be active         - Existing transactions are replaced with new transaction set          The update process atomically replaces all transactions while preserving the journal entry ID and audit trail.         
         * @summary Update Intercompany Journal Entry
         * @param {number} id 
         * @param {IntercompanyJournalEntry} [intercompanyJournalEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryUpdate: async (id: number, intercompanyJournalEntry?: IntercompanyJournalEntry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiIntercompanyJournalEntryUpdate', 'id', id)
            const localVarPath = `/coa/api/intercompany-journal-entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(intercompanyJournalEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Create a new journal entry with transactions. Journal entries must balance - total debits must equal total credits.          **Key Features:**         - Automatic currency conversion using exchange rates         - Vendor, Department and Custom Dimension assignment         - Optional reversal date for automatic reversal entries         - Validation against closed book periods          **Validation Rules:**         - Debits must equal credits in transaction currency (debit_native and credit_native)         - Cannot create entries before closed book dates         - Accounts must be active         - Exchange rates are auto-calculated if not provided         
         * @summary Create Journal Entry
         * @param {JournalEntryPostResponse} [journalEntryPostResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryCreate: async (journalEntryPostResponse?: JournalEntryPostResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/journal_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(journalEntryPostResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Delete a journal entry and all its associated transactions.          **Restrictions:**         - Cannot delete entries before closed book dates          **Response Codes:**         - 204: Successfully deleted         - 400: Cannot delete (books closed for this date)         - 409: Cannot delete (associated with other objects)         
         * @summary Delete Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiJournalEntryDestroy', 'id', id)
            const localVarPath = `/coa/api/journal_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a paginated list of journal entries with optional filtering and sorting.          **Query Parameters:**         - `start_date`, `end_date`: Filter by date range (defaults to last 6 months)         - `account`: Filter by account ID(s) - supports multiple values         - `source`: Filter by journal entry source         - `journal_id`: Filter by specific journal ID         - `all_time`: Include all entries regardless of date (true/false)         - `sort`: Sort field (default: \"date\")          **Response includes:**         - Complete journal entry details with all transactions         - Account information with names and numbers         - Vendor and department details         - Tag associations with groups         - Attachment information         - Exchange rate data for multi-currency entries         
         * @summary List Journal Entries
         * @param {string} [account] Filter by account ID(s). Can specify multiple values.
         * @param {boolean} [allTime] Include all entries regardless of date range
         * @param {string} [endDate] End date for filtering (YYYY-MM-DD format)
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [source] Filter by journal entry source (e.g., \&#39;manual\&#39;, \&#39;CSV Upload\&#39;)
         * @param {string} [startDate] Start date for filtering (YYYY-MM-DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryList: async (account?: string, allTime?: boolean, endDate?: string, limit?: number, offset?: number, source?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/journal_entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (allTime !== undefined) {
                localVarQueryParameter['all_time'] = allTime;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Partially update a journal entry. Only provided fields will be updated.          **Common Use Cases:**         - Update memo or reference number         - Change journal entry date         - Modify specific transaction amounts         - Add or remove tags from transactions          **Validation Rules:**         - Journal entry must still balance after updates         - Cannot modify entries in closed periods         - Account changes must maintain chart of accounts rules         
         * @summary Partial Update Journal Entry
         * @param {number} id 
         * @param {PatchedJournalEntryPostResponse} [patchedJournalEntryPostResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryPartialUpdate: async (id: number, patchedJournalEntryPostResponse?: PatchedJournalEntryPostResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiJournalEntryPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/journal_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedJournalEntryPostResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a specific journal entry by ID with all transaction details.          **Response includes:**         - Complete journal entry with all transactions         - Account names, numbers, and types         - Vendor and department information         - Tag associations with groups         - Exchange rate data for multi-currency entries         - Attachment information         - Reversal information if applicable         
         * @summary Retrieve Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiJournalEntryRetrieve', 'id', id)
            const localVarPath = `/coa/api/journal_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Update a journal entry completely. All transactions will be replaced with the new ones provided.          **Important Notes:**         - Cannot update entries before closed book dates         - Must maintain double-entry bookkeeping (debits = credits)         - All existing transactions will be replaced         - Exchange rates will be recalculated if not provided          **Validation Rules:**         - Journal entry must balance in all currencies         - Accounts must be active         - Cannot modify entries in closed periods         
         * @summary Update Journal Entry
         * @param {number} id 
         * @param {JournalEntryPostResponse} [journalEntryPostResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryUpdate: async (id: number, journalEntryPostResponse?: JournalEntryPostResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiJournalEntryUpdate', 'id', id)
            const localVarPath = `/coa/api/journal_entry/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(journalEntryPostResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for tags by exact name match in a single request. Supports upsert to create missing tags.
         * @summary Bulk Search Custom Dimensions by Name
         * @param {BulkTagSearch} bulkTagSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagBulkSearchCreate: async (bulkTagSearch: BulkTagSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkTagSearch' is not null or undefined
            assertParamExists('coaApiTagBulkSearchCreate', 'bulkTagSearch', bulkTagSearch)
            const localVarPath = `/coa/api/tag/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkTagSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply bill payments to a bank transaction, linking the transaction to one or more bills.
         * @summary Apply Bill Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionBillPaymentsCreate: async (transactionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('coaApiTransactionBillPaymentsCreate', 'transactionId', transactionId)
            const localVarPath = `/coa/api/transaction/{transaction_id}/bill_payments`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply credit memo payments to a bank transaction.
         * @summary Apply Credit Memo Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionCreditMemoPaymentsCreate: async (transactionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('coaApiTransactionCreditMemoPaymentsCreate', 'transactionId', transactionId)
            const localVarPath = `/coa/api/transaction/{transaction_id}/credit_memo_payments`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply debit memo payments to a bank transaction.
         * @summary Apply Debit Memo Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionDebitMemoPaymentsCreate: async (transactionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('coaApiTransactionDebitMemoPaymentsCreate', 'transactionId', transactionId)
            const localVarPath = `/coa/api/transaction/{transaction_id}/debit_memo_payments`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a chart transaction. Cannot delete transactions in closed accounting periods.
         * @summary Delete Chart Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionDestroy', 'id', id)
            const localVarPath = `/coa/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply invoice payments to a bank transaction, linking the transaction to one or more invoices.
         * @summary Apply Invoice Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionInvoicePaymentsCreate: async (transactionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('coaApiTransactionInvoicePaymentsCreate', 'transactionId', transactionId)
            const localVarPath = `/coa/api/transaction/{transaction_id}/invoice_payments`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Chart Transaction
         * @param {number} id 
         * @param {PatchedChartTransaction} [patchedChartTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionPartialUpdate: async (id: number, patchedChartTransaction?: PatchedChartTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedChartTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve chart transactions with advanced filtering options
         * @summary List Chart Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Chart Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionRetrieve2: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionRetrieve2', 'id', id)
            const localVarPath = `/coa/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Chart Transaction
         * @param {number} id 
         * @param {ChartTransaction} chartTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionUpdate: async (id: number, chartTransaction: ChartTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiTransactionUpdate', 'id', id)
            // verify required parameter 'chartTransaction' is not null or undefined
            assertParamExists('coaApiTransactionUpdate', 'chartTransaction', chartTransaction)
            const localVarPath = `/coa/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for thousands of vendors by external_id (priority) or name in a single request. Optimized for performance. Supports upsert to create missing vendors.
         * @summary Bulk Search Vendors by External ID or Name
         * @param {BulkVendorSearch} bulkVendorSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorBulkSearchCreate: async (bulkVendorSearch: BulkVendorSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkVendorSearch' is not null or undefined
            assertParamExists('coaApiVendorBulkSearchCreate', 'bulkVendorSearch', bulkVendorSearch)
            const localVarPath = `/coa/api/vendor/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkVendorSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Vendor Contact
         * @param {number} id 
         * @param {VendorContact} [vendorContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorContactsCreate: async (id: number, vendorContact?: VendorContact, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorContactsCreate', 'id', id)
            const localVarPath = `/coa/api/vendor/{id}/contacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vendorContact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary List Vendor Contacts
         * @param {number} id 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorContactsList: async (id: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiVendorContactsList', 'id', id)
            const localVarPath = `/coa/api/vendor/{id}/contacts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreAccountingApi - functional programming interface
 */
export const CoreAccountingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreAccountingApiAxiosParamCreator(configuration)
    return {
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Budget
         * @param {number} budgetPk 
         * @param {BudgetAccount} [budgetAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsAccountsCreate(budgetPk: number, budgetAccount?: BudgetAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsAccountsCreate(budgetPk, budgetAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsAccountsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsAccountsDestroy(budgetPk: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsAccountsDestroy(budgetPk, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsAccountsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of budget accounts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Budget Accounts
         * @param {number} budgetPk 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsAccountsList(budgetPk: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BudgetAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsAccountsList(budgetPk, includeDeleted, lastModifiedAtGte, lastModifiedAtLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsAccountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {PatchedBudgetAccount} [patchedBudgetAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsAccountsPartialUpdate(budgetPk: number, id: number, patchedBudgetAccount?: PatchedBudgetAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsAccountsPartialUpdate(budgetPk, id, patchedBudgetAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsAccountsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsAccountsRetrieve(budgetPk: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsAccountsRetrieve(budgetPk, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsAccountsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Budget Account
         * @param {number} budgetPk 
         * @param {number} id 
         * @param {BudgetAccount} [budgetAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsAccountsUpdate(budgetPk: number, id: number, budgetAccount?: BudgetAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsAccountsUpdate(budgetPk, id, budgetAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsAccountsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Budget
         * @param {Budget} budget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsCreate(budget: Budget, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsCreate(budget, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Budget
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of budgets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Budgets
         * @param {number} [entity] Filter by entity ID
         * @param {string} [entityName] Filter by entity name (partial match)
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [q] Search query - searches by budget name
         * @param {string} [sort] Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsList(entity?: number, entityName?: string, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, q?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBudgetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsList(entity, entityName, includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, q, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Budget
         * @param {number} id 
         * @param {PatchedBudget} [patchedBudget] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsPartialUpdate(id: number, patchedBudget?: PatchedBudget, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsPartialUpdate(id, patchedBudget, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Budget
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Budget
         * @param {number} id 
         * @param {Budget} budget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiBudgetsUpdate(id: number, budget: Budget, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Budget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiBudgetsUpdate(id, budget, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiBudgetsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for thousands of departments by exact name match in a single request. Optimized for performance. Supports upsert to create missing departments.
         * @summary Bulk Search Departments by Name
         * @param {BulkDepartmentSearch} bulkDepartmentSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiDepartmentBulkSearchCreate(bulkDepartmentSearch: BulkDepartmentSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Department>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiDepartmentBulkSearchCreate(bulkDepartmentSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiDepartmentBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Fixed Asset
         * @param {FixedAsset} fixedAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetCreate(fixedAsset: FixedAsset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetCreate(fixedAsset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiFixedAssetCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Fixed Asset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiFixedAssetDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of fixed assets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Fixed Assets
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetList(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFixedAssetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetList(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiFixedAssetList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Fixed Asset
         * @param {number} id 
         * @param {PatchedFixedAsset} [patchedFixedAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetPartialUpdate(id: number, patchedFixedAsset?: PatchedFixedAsset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetPartialUpdate(id, patchedFixedAsset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiFixedAssetPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Fixed Asset
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiFixedAssetRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Fixed Asset
         * @param {number} id 
         * @param {FixedAsset} fixedAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiFixedAssetUpdate(id: number, fixedAsset: FixedAsset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FixedAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiFixedAssetUpdate(id, fixedAsset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiFixedAssetUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Creates a new intercompany journal entry          This endpoint allows for complex multi-entity transactions where:         - Transactions are balanced across different entities         - Exchange rates are handled for multi-currency transactions          Key requirements:         - Total debits must equal total credits for each entity (debit_amount_native must equal credit_amount_native)         - Cannot create entries before closed book dates         - All referenced accounts must be active         
         * @summary Create Intercompany Journal Entry
         * @param {IntercompanyJournalEntry} [intercompanyJournalEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiIntercompanyJournalEntryCreate(intercompanyJournalEntry?: IntercompanyJournalEntry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntercompanyJournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiIntercompanyJournalEntryCreate(intercompanyJournalEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiIntercompanyJournalEntryCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Permanently deletes an intercompany journal entry and all related transactions.          This endpoint performs a comprehensive cleanup when deleting an intercompany journal entry:         - Validates that the entry can be deleted (not in closed period)         - Removes all associated journal entries across entities         - Updates summary tables and account balances         - Handles cascade deletion of related transactions         - Ensures data integrity across the accounting system          Deletion restrictions:         - Cannot delete entries in closed accounting periods          Error conditions:         - 400 Bad Request: Entry date is in a closed period         - 409 Conflict: Entry has protected relationships (e.g., close checklist tasks)         - 404 Not Found: Entry does not exist or user lacks access          On successful deletion, all related journal entries are removed and accounting summaries are recalculated.         
         * @summary Delete Intercompany Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiIntercompanyJournalEntryDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiIntercompanyJournalEntryDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiIntercompanyJournalEntryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieves a paginated list of intercompany journal entries for the authenticated user\'s customer.          This endpoint returns:         - Summary information for each intercompany journal entry         - Basic transaction details (simplified view for list performance)         - Entity and exchange rate information         - Pagination metadata (count, next, previous)         - Reversal relationships and attachment counts          The response includes:         - Intercompany journal entry metadata         - Associated transaction summaries         - Entity exchange rate information         - Links to related reversals         - Attachment information          Results can be sorted using the \'sort\' query parameter with field names like \'date\', \'id\', etc.         Prefix with \'-\' for descending order (e.g., \'-date\').         
         * @summary List Intercompany Journal Entries
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiIntercompanyJournalEntryList(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIntercompanyJournalEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiIntercompanyJournalEntryList(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiIntercompanyJournalEntryList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Performs a partial update of an intercompany journal entry, allowing modification of specific fields without replacing the entire entry.          This endpoint supports partial updates to:         - Journal entry metadata (memo, date, currency, reference number)         - Individual transaction modifications         - Entity exchange rate adjustments         - Vendor, department, and tag assignments         - Account categorizations and amounts          Key differences from PUT:         - Only specified fields are updated (vs. full replacement)         - Maintains existing data for unspecified fields         - Supports granular transaction modifications         - Preserves audit trail and timestamps         - Allows incremental changes without full transaction rebuilds          Validation requirements:         - Modified transactions must maintain entity balance (debits = credits)         - Cannot modify entries in closed accounting periods         - All referenced accounts, vendors, departments must be active         - Exchange rates must be valid for multi-currency transactions         - Account assignments must be appropriate for transaction types         
         * @summary Partial Update Intercompany Journal Entry
         * @param {number} id 
         * @param {PatchedIntercompanyJournalEntry} [patchedIntercompanyJournalEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiIntercompanyJournalEntryPartialUpdate(id: number, patchedIntercompanyJournalEntry?: PatchedIntercompanyJournalEntry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntercompanyJournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiIntercompanyJournalEntryPartialUpdate(id, patchedIntercompanyJournalEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiIntercompanyJournalEntryPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieves a single intercompany journal entry by its ID with complete details.          This endpoint returns:         - Complete intercompany journal entry information         - Full transaction details with all accounting fields         - Entity information and exchange rates         - Attachment and reversal information         - Comprehensive transaction metadata          The response includes:         - All transaction details with account information         - Entity exchange rate data         - Vendor, department, and tag information         - Balance calculations and transaction history         - File attachments and reversal relationships         - Complete audit trail information          This is the detailed view used for editing and complete transaction analysis.         
         * @summary Get Intercompany Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiIntercompanyJournalEntryRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntercompanyJournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiIntercompanyJournalEntryRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiIntercompanyJournalEntryRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Updates an existing intercompany journal entry with new transaction details.          This endpoint allows for:         - Modifying transaction amounts and details         - Updating entity assignments and exchange rates         - Changing account assignments and categorizations         - Updating vendor, department, and tag information         - Maintaining balance validation across all entities          Key requirements:         - Total debits must equal total credits for each entity         - All account balances must be valid in all currencies         - Cannot modify entries in closed periods         - All referenced accounts must be active         - Existing transactions are replaced with new transaction set          The update process atomically replaces all transactions while preserving the journal entry ID and audit trail.         
         * @summary Update Intercompany Journal Entry
         * @param {number} id 
         * @param {IntercompanyJournalEntry} [intercompanyJournalEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiIntercompanyJournalEntryUpdate(id: number, intercompanyJournalEntry?: IntercompanyJournalEntry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntercompanyJournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiIntercompanyJournalEntryUpdate(id, intercompanyJournalEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiIntercompanyJournalEntryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Create a new journal entry with transactions. Journal entries must balance - total debits must equal total credits.          **Key Features:**         - Automatic currency conversion using exchange rates         - Vendor, Department and Custom Dimension assignment         - Optional reversal date for automatic reversal entries         - Validation against closed book periods          **Validation Rules:**         - Debits must equal credits in transaction currency (debit_native and credit_native)         - Cannot create entries before closed book dates         - Accounts must be active         - Exchange rates are auto-calculated if not provided         
         * @summary Create Journal Entry
         * @param {JournalEntryPostResponse} [journalEntryPostResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiJournalEntryCreate(journalEntryPostResponse?: JournalEntryPostResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntryPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiJournalEntryCreate(journalEntryPostResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiJournalEntryCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Delete a journal entry and all its associated transactions.          **Restrictions:**         - Cannot delete entries before closed book dates          **Response Codes:**         - 204: Successfully deleted         - 400: Cannot delete (books closed for this date)         - 409: Cannot delete (associated with other objects)         
         * @summary Delete Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiJournalEntryDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiJournalEntryDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiJournalEntryDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a paginated list of journal entries with optional filtering and sorting.          **Query Parameters:**         - `start_date`, `end_date`: Filter by date range (defaults to last 6 months)         - `account`: Filter by account ID(s) - supports multiple values         - `source`: Filter by journal entry source         - `journal_id`: Filter by specific journal ID         - `all_time`: Include all entries regardless of date (true/false)         - `sort`: Sort field (default: \"date\")          **Response includes:**         - Complete journal entry details with all transactions         - Account information with names and numbers         - Vendor and department details         - Tag associations with groups         - Attachment information         - Exchange rate data for multi-currency entries         
         * @summary List Journal Entries
         * @param {string} [account] Filter by account ID(s). Can specify multiple values.
         * @param {boolean} [allTime] Include all entries regardless of date range
         * @param {string} [endDate] End date for filtering (YYYY-MM-DD format)
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [source] Filter by journal entry source (e.g., \&#39;manual\&#39;, \&#39;CSV Upload\&#39;)
         * @param {string} [startDate] Start date for filtering (YYYY-MM-DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiJournalEntryList(account?: string, allTime?: boolean, endDate?: string, limit?: number, offset?: number, source?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJournalEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiJournalEntryList(account, allTime, endDate, limit, offset, source, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiJournalEntryList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Partially update a journal entry. Only provided fields will be updated.          **Common Use Cases:**         - Update memo or reference number         - Change journal entry date         - Modify specific transaction amounts         - Add or remove tags from transactions          **Validation Rules:**         - Journal entry must still balance after updates         - Cannot modify entries in closed periods         - Account changes must maintain chart of accounts rules         
         * @summary Partial Update Journal Entry
         * @param {number} id 
         * @param {PatchedJournalEntryPostResponse} [patchedJournalEntryPostResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiJournalEntryPartialUpdate(id: number, patchedJournalEntryPostResponse?: PatchedJournalEntryPostResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntryPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiJournalEntryPartialUpdate(id, patchedJournalEntryPostResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiJournalEntryPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a specific journal entry by ID with all transaction details.          **Response includes:**         - Complete journal entry with all transactions         - Account names, numbers, and types         - Vendor and department information         - Tag associations with groups         - Exchange rate data for multi-currency entries         - Attachment information         - Reversal information if applicable         
         * @summary Retrieve Journal Entry
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiJournalEntryRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiJournalEntryRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiJournalEntryRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Update a journal entry completely. All transactions will be replaced with the new ones provided.          **Important Notes:**         - Cannot update entries before closed book dates         - Must maintain double-entry bookkeeping (debits = credits)         - All existing transactions will be replaced         - Exchange rates will be recalculated if not provided          **Validation Rules:**         - Journal entry must balance in all currencies         - Accounts must be active         - Cannot modify entries in closed periods         
         * @summary Update Journal Entry
         * @param {number} id 
         * @param {JournalEntryPostResponse} [journalEntryPostResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiJournalEntryUpdate(id: number, journalEntryPostResponse?: JournalEntryPostResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntryPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiJournalEntryUpdate(id, journalEntryPostResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiJournalEntryUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for tags by exact name match in a single request. Supports upsert to create missing tags.
         * @summary Bulk Search Custom Dimensions by Name
         * @param {BulkTagSearch} bulkTagSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTagBulkSearchCreate(bulkTagSearch: BulkTagSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTagBulkSearchCreate(bulkTagSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTagBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply bill payments to a bank transaction, linking the transaction to one or more bills.
         * @summary Apply Bill Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionBillPaymentsCreate(transactionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionBillPaymentsCreate(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionBillPaymentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply credit memo payments to a bank transaction.
         * @summary Apply Credit Memo Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionCreditMemoPaymentsCreate(transactionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionCreditMemoPaymentsCreate(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionCreditMemoPaymentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply debit memo payments to a bank transaction.
         * @summary Apply Debit Memo Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionDebitMemoPaymentsCreate(transactionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionDebitMemoPaymentsCreate(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionDebitMemoPaymentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a chart transaction. Cannot delete transactions in closed accounting periods.
         * @summary Delete Chart Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Apply invoice payments to a bank transaction, linking the transaction to one or more invoices.
         * @summary Apply Invoice Payments to Transaction
         * @param {number} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionInvoicePaymentsCreate(transactionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionInvoicePaymentsCreate(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionInvoicePaymentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Chart Transaction
         * @param {number} id 
         * @param {PatchedChartTransaction} [patchedChartTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionPartialUpdate(id: number, patchedChartTransaction?: PatchedChartTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionPartialUpdate(id, patchedChartTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve chart transactions with advanced filtering options
         * @summary List Chart Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Chart Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionRetrieve2(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionRetrieve2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionRetrieve2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Chart Transaction
         * @param {number} id 
         * @param {ChartTransaction} chartTransaction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiTransactionUpdate(id: number, chartTransaction: ChartTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiTransactionUpdate(id, chartTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiTransactionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for thousands of vendors by external_id (priority) or name in a single request. Optimized for performance. Supports upsert to create missing vendors.
         * @summary Bulk Search Vendors by External ID or Name
         * @param {BulkVendorSearch} bulkVendorSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorBulkSearchCreate(bulkVendorSearch: BulkVendorSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vendor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorBulkSearchCreate(bulkVendorSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiVendorBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Vendor Contact
         * @param {number} id 
         * @param {VendorContact} [vendorContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorContactsCreate(id: number, vendorContact?: VendorContact, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorContact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorContactsCreate(id, vendorContact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiVendorContactsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary List Vendor Contacts
         * @param {number} id 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiVendorContactsList(id: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVendorContactList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiVendorContactsList(id, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreAccountingApi.coaApiVendorContactsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreAccountingApi - factory interface
 */
export const CoreAccountingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreAccountingApiFp(configuration)
    return {
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Budget
         * @param {CoreAccountingApiCoaApiBudgetsAccountsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsCreate(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BudgetAccount> {
            return localVarFp.coaApiBudgetsAccountsCreate(requestParameters.budgetPk, requestParameters.budgetAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Budget Account
         * @param {CoreAccountingApiCoaApiBudgetsAccountsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsDestroy(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiBudgetsAccountsDestroy(requestParameters.budgetPk, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of budget accounts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Budget Accounts
         * @param {CoreAccountingApiCoaApiBudgetsAccountsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsList(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<BudgetAccount>> {
            return localVarFp.coaApiBudgetsAccountsList(requestParameters.budgetPk, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Budget Account
         * @param {CoreAccountingApiCoaApiBudgetsAccountsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsPartialUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BudgetAccount> {
            return localVarFp.coaApiBudgetsAccountsPartialUpdate(requestParameters.budgetPk, requestParameters.id, requestParameters.patchedBudgetAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Budget Account
         * @param {CoreAccountingApiCoaApiBudgetsAccountsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsRetrieve(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<BudgetAccount> {
            return localVarFp.coaApiBudgetsAccountsRetrieve(requestParameters.budgetPk, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Budget Account
         * @param {CoreAccountingApiCoaApiBudgetsAccountsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsAccountsUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BudgetAccount> {
            return localVarFp.coaApiBudgetsAccountsUpdate(requestParameters.budgetPk, requestParameters.id, requestParameters.budgetAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Budget
         * @param {CoreAccountingApiCoaApiBudgetsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsCreate(requestParameters: CoreAccountingApiCoaApiBudgetsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Budget> {
            return localVarFp.coaApiBudgetsCreate(requestParameters.budget, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Budget
         * @param {CoreAccountingApiCoaApiBudgetsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsDestroy(requestParameters: CoreAccountingApiCoaApiBudgetsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiBudgetsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of budgets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Budgets
         * @param {CoreAccountingApiCoaApiBudgetsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsList(requestParameters: CoreAccountingApiCoaApiBudgetsListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBudgetList> {
            return localVarFp.coaApiBudgetsList(requestParameters.entity, requestParameters.entityName, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Budget
         * @param {CoreAccountingApiCoaApiBudgetsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsPartialUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Budget> {
            return localVarFp.coaApiBudgetsPartialUpdate(requestParameters.id, requestParameters.patchedBudget, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Budget
         * @param {CoreAccountingApiCoaApiBudgetsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsRetrieve(requestParameters: CoreAccountingApiCoaApiBudgetsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Budget> {
            return localVarFp.coaApiBudgetsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Budget
         * @param {CoreAccountingApiCoaApiBudgetsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiBudgetsUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Budget> {
            return localVarFp.coaApiBudgetsUpdate(requestParameters.id, requestParameters.budget, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for thousands of departments by exact name match in a single request. Optimized for performance. Supports upsert to create missing departments.
         * @summary Bulk Search Departments by Name
         * @param {CoreAccountingApiCoaApiDepartmentBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiDepartmentBulkSearchCreate(requestParameters: CoreAccountingApiCoaApiDepartmentBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Department>> {
            return localVarFp.coaApiDepartmentBulkSearchCreate(requestParameters.bulkDepartmentSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Fixed Asset
         * @param {CoreAccountingApiCoaApiFixedAssetCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetCreate(requestParameters: CoreAccountingApiCoaApiFixedAssetCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAsset> {
            return localVarFp.coaApiFixedAssetCreate(requestParameters.fixedAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Fixed Asset
         * @param {CoreAccountingApiCoaApiFixedAssetDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetDestroy(requestParameters: CoreAccountingApiCoaApiFixedAssetDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiFixedAssetDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of fixed assets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Fixed Assets
         * @param {CoreAccountingApiCoaApiFixedAssetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetList(requestParameters: CoreAccountingApiCoaApiFixedAssetListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFixedAssetList> {
            return localVarFp.coaApiFixedAssetList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Fixed Asset
         * @param {CoreAccountingApiCoaApiFixedAssetPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetPartialUpdate(requestParameters: CoreAccountingApiCoaApiFixedAssetPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAsset> {
            return localVarFp.coaApiFixedAssetPartialUpdate(requestParameters.id, requestParameters.patchedFixedAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Fixed Asset
         * @param {CoreAccountingApiCoaApiFixedAssetRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetRetrieve(requestParameters: CoreAccountingApiCoaApiFixedAssetRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAsset> {
            return localVarFp.coaApiFixedAssetRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Fixed Asset
         * @param {CoreAccountingApiCoaApiFixedAssetUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiFixedAssetUpdate(requestParameters: CoreAccountingApiCoaApiFixedAssetUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FixedAsset> {
            return localVarFp.coaApiFixedAssetUpdate(requestParameters.id, requestParameters.fixedAsset, options).then((request) => request(axios, basePath));
        },
        /**
         *          Creates a new intercompany journal entry          This endpoint allows for complex multi-entity transactions where:         - Transactions are balanced across different entities         - Exchange rates are handled for multi-currency transactions          Key requirements:         - Total debits must equal total credits for each entity (debit_amount_native must equal credit_amount_native)         - Cannot create entries before closed book dates         - All referenced accounts must be active         
         * @summary Create Intercompany Journal Entry
         * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryCreate(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<IntercompanyJournalEntry> {
            return localVarFp.coaApiIntercompanyJournalEntryCreate(requestParameters.intercompanyJournalEntry, options).then((request) => request(axios, basePath));
        },
        /**
         *          Permanently deletes an intercompany journal entry and all related transactions.          This endpoint performs a comprehensive cleanup when deleting an intercompany journal entry:         - Validates that the entry can be deleted (not in closed period)         - Removes all associated journal entries across entities         - Updates summary tables and account balances         - Handles cascade deletion of related transactions         - Ensures data integrity across the accounting system          Deletion restrictions:         - Cannot delete entries in closed accounting periods          Error conditions:         - 400 Bad Request: Entry date is in a closed period         - 409 Conflict: Entry has protected relationships (e.g., close checklist tasks)         - 404 Not Found: Entry does not exist or user lacks access          On successful deletion, all related journal entries are removed and accounting summaries are recalculated.         
         * @summary Delete Intercompany Journal Entry
         * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryDestroy(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiIntercompanyJournalEntryDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieves a paginated list of intercompany journal entries for the authenticated user\'s customer.          This endpoint returns:         - Summary information for each intercompany journal entry         - Basic transaction details (simplified view for list performance)         - Entity and exchange rate information         - Pagination metadata (count, next, previous)         - Reversal relationships and attachment counts          The response includes:         - Intercompany journal entry metadata         - Associated transaction summaries         - Entity exchange rate information         - Links to related reversals         - Attachment information          Results can be sorted using the \'sort\' query parameter with field names like \'date\', \'id\', etc.         Prefix with \'-\' for descending order (e.g., \'-date\').         
         * @summary List Intercompany Journal Entries
         * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryList(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIntercompanyJournalEntryList> {
            return localVarFp.coaApiIntercompanyJournalEntryList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         *          Performs a partial update of an intercompany journal entry, allowing modification of specific fields without replacing the entire entry.          This endpoint supports partial updates to:         - Journal entry metadata (memo, date, currency, reference number)         - Individual transaction modifications         - Entity exchange rate adjustments         - Vendor, department, and tag assignments         - Account categorizations and amounts          Key differences from PUT:         - Only specified fields are updated (vs. full replacement)         - Maintains existing data for unspecified fields         - Supports granular transaction modifications         - Preserves audit trail and timestamps         - Allows incremental changes without full transaction rebuilds          Validation requirements:         - Modified transactions must maintain entity balance (debits = credits)         - Cannot modify entries in closed accounting periods         - All referenced accounts, vendors, departments must be active         - Exchange rates must be valid for multi-currency transactions         - Account assignments must be appropriate for transaction types         
         * @summary Partial Update Intercompany Journal Entry
         * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryPartialUpdate(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntercompanyJournalEntry> {
            return localVarFp.coaApiIntercompanyJournalEntryPartialUpdate(requestParameters.id, requestParameters.patchedIntercompanyJournalEntry, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieves a single intercompany journal entry by its ID with complete details.          This endpoint returns:         - Complete intercompany journal entry information         - Full transaction details with all accounting fields         - Entity information and exchange rates         - Attachment and reversal information         - Comprehensive transaction metadata          The response includes:         - All transaction details with account information         - Entity exchange rate data         - Vendor, department, and tag information         - Balance calculations and transaction history         - File attachments and reversal relationships         - Complete audit trail information          This is the detailed view used for editing and complete transaction analysis.         
         * @summary Get Intercompany Journal Entry
         * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryRetrieve(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntercompanyJournalEntry> {
            return localVarFp.coaApiIntercompanyJournalEntryRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Updates an existing intercompany journal entry with new transaction details.          This endpoint allows for:         - Modifying transaction amounts and details         - Updating entity assignments and exchange rates         - Changing account assignments and categorizations         - Updating vendor, department, and tag information         - Maintaining balance validation across all entities          Key requirements:         - Total debits must equal total credits for each entity         - All account balances must be valid in all currencies         - Cannot modify entries in closed periods         - All referenced accounts must be active         - Existing transactions are replaced with new transaction set          The update process atomically replaces all transactions while preserving the journal entry ID and audit trail.         
         * @summary Update Intercompany Journal Entry
         * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiIntercompanyJournalEntryUpdate(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntercompanyJournalEntry> {
            return localVarFp.coaApiIntercompanyJournalEntryUpdate(requestParameters.id, requestParameters.intercompanyJournalEntry, options).then((request) => request(axios, basePath));
        },
        /**
         *          Create a new journal entry with transactions. Journal entries must balance - total debits must equal total credits.          **Key Features:**         - Automatic currency conversion using exchange rates         - Vendor, Department and Custom Dimension assignment         - Optional reversal date for automatic reversal entries         - Validation against closed book periods          **Validation Rules:**         - Debits must equal credits in transaction currency (debit_native and credit_native)         - Cannot create entries before closed book dates         - Accounts must be active         - Exchange rates are auto-calculated if not provided         
         * @summary Create Journal Entry
         * @param {CoreAccountingApiCoaApiJournalEntryCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryCreate(requestParameters: CoreAccountingApiCoaApiJournalEntryCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntryPostResponse> {
            return localVarFp.coaApiJournalEntryCreate(requestParameters.journalEntryPostResponse, options).then((request) => request(axios, basePath));
        },
        /**
         *          Delete a journal entry and all its associated transactions.          **Restrictions:**         - Cannot delete entries before closed book dates          **Response Codes:**         - 204: Successfully deleted         - 400: Cannot delete (books closed for this date)         - 409: Cannot delete (associated with other objects)         
         * @summary Delete Journal Entry
         * @param {CoreAccountingApiCoaApiJournalEntryDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryDestroy(requestParameters: CoreAccountingApiCoaApiJournalEntryDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiJournalEntryDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a paginated list of journal entries with optional filtering and sorting.          **Query Parameters:**         - `start_date`, `end_date`: Filter by date range (defaults to last 6 months)         - `account`: Filter by account ID(s) - supports multiple values         - `source`: Filter by journal entry source         - `journal_id`: Filter by specific journal ID         - `all_time`: Include all entries regardless of date (true/false)         - `sort`: Sort field (default: \"date\")          **Response includes:**         - Complete journal entry details with all transactions         - Account information with names and numbers         - Vendor and department details         - Tag associations with groups         - Attachment information         - Exchange rate data for multi-currency entries         
         * @summary List Journal Entries
         * @param {CoreAccountingApiCoaApiJournalEntryListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryList(requestParameters: CoreAccountingApiCoaApiJournalEntryListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedJournalEntryList> {
            return localVarFp.coaApiJournalEntryList(requestParameters.account, requestParameters.allTime, requestParameters.endDate, requestParameters.limit, requestParameters.offset, requestParameters.source, requestParameters.startDate, options).then((request) => request(axios, basePath));
        },
        /**
         *          Partially update a journal entry. Only provided fields will be updated.          **Common Use Cases:**         - Update memo or reference number         - Change journal entry date         - Modify specific transaction amounts         - Add or remove tags from transactions          **Validation Rules:**         - Journal entry must still balance after updates         - Cannot modify entries in closed periods         - Account changes must maintain chart of accounts rules         
         * @summary Partial Update Journal Entry
         * @param {CoreAccountingApiCoaApiJournalEntryPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryPartialUpdate(requestParameters: CoreAccountingApiCoaApiJournalEntryPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntryPostResponse> {
            return localVarFp.coaApiJournalEntryPartialUpdate(requestParameters.id, requestParameters.patchedJournalEntryPostResponse, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a specific journal entry by ID with all transaction details.          **Response includes:**         - Complete journal entry with all transactions         - Account names, numbers, and types         - Vendor and department information         - Tag associations with groups         - Exchange rate data for multi-currency entries         - Attachment information         - Reversal information if applicable         
         * @summary Retrieve Journal Entry
         * @param {CoreAccountingApiCoaApiJournalEntryRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryRetrieve(requestParameters: CoreAccountingApiCoaApiJournalEntryRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntry> {
            return localVarFp.coaApiJournalEntryRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Update a journal entry completely. All transactions will be replaced with the new ones provided.          **Important Notes:**         - Cannot update entries before closed book dates         - Must maintain double-entry bookkeeping (debits = credits)         - All existing transactions will be replaced         - Exchange rates will be recalculated if not provided          **Validation Rules:**         - Journal entry must balance in all currencies         - Accounts must be active         - Cannot modify entries in closed periods         
         * @summary Update Journal Entry
         * @param {CoreAccountingApiCoaApiJournalEntryUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiJournalEntryUpdate(requestParameters: CoreAccountingApiCoaApiJournalEntryUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntryPostResponse> {
            return localVarFp.coaApiJournalEntryUpdate(requestParameters.id, requestParameters.journalEntryPostResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for tags by exact name match in a single request. Supports upsert to create missing tags.
         * @summary Bulk Search Custom Dimensions by Name
         * @param {CoreAccountingApiCoaApiTagBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTagBulkSearchCreate(requestParameters: CoreAccountingApiCoaApiTagBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionTag>> {
            return localVarFp.coaApiTagBulkSearchCreate(requestParameters.bulkTagSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply bill payments to a bank transaction, linking the transaction to one or more bills.
         * @summary Apply Bill Payments to Transaction
         * @param {CoreAccountingApiCoaApiTransactionBillPaymentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionBillPaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionBillPaymentsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionBillPaymentsCreate(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply credit memo payments to a bank transaction.
         * @summary Apply Credit Memo Payments to Transaction
         * @param {CoreAccountingApiCoaApiTransactionCreditMemoPaymentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionCreditMemoPaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionCreditMemoPaymentsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionCreditMemoPaymentsCreate(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply debit memo payments to a bank transaction.
         * @summary Apply Debit Memo Payments to Transaction
         * @param {CoreAccountingApiCoaApiTransactionDebitMemoPaymentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionDebitMemoPaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionDebitMemoPaymentsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionDebitMemoPaymentsCreate(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a chart transaction. Cannot delete transactions in closed accounting periods.
         * @summary Delete Chart Transaction
         * @param {CoreAccountingApiCoaApiTransactionDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionDestroy(requestParameters: CoreAccountingApiCoaApiTransactionDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply invoice payments to a bank transaction, linking the transaction to one or more invoices.
         * @summary Apply Invoice Payments to Transaction
         * @param {CoreAccountingApiCoaApiTransactionInvoicePaymentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionInvoicePaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionInvoicePaymentsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionInvoicePaymentsCreate(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Chart Transaction
         * @param {CoreAccountingApiCoaApiTransactionPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionPartialUpdate(requestParameters: CoreAccountingApiCoaApiTransactionPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartTransaction> {
            return localVarFp.coaApiTransactionPartialUpdate(requestParameters.id, requestParameters.patchedChartTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve chart transactions with advanced filtering options
         * @summary List Chart Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiTransactionRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Chart Transaction
         * @param {CoreAccountingApiCoaApiTransactionRetrieve2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionRetrieve2(requestParameters: CoreAccountingApiCoaApiTransactionRetrieve2Request, options?: RawAxiosRequestConfig): AxiosPromise<ChartTransaction> {
            return localVarFp.coaApiTransactionRetrieve2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Chart Transaction
         * @param {CoreAccountingApiCoaApiTransactionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiTransactionUpdate(requestParameters: CoreAccountingApiCoaApiTransactionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartTransaction> {
            return localVarFp.coaApiTransactionUpdate(requestParameters.id, requestParameters.chartTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for thousands of vendors by external_id (priority) or name in a single request. Optimized for performance. Supports upsert to create missing vendors.
         * @summary Bulk Search Vendors by External ID or Name
         * @param {CoreAccountingApiCoaApiVendorBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorBulkSearchCreate(requestParameters: CoreAccountingApiCoaApiVendorBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Vendor>> {
            return localVarFp.coaApiVendorBulkSearchCreate(requestParameters.bulkVendorSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Vendor Contact
         * @param {CoreAccountingApiCoaApiVendorContactsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorContactsCreate(requestParameters: CoreAccountingApiCoaApiVendorContactsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VendorContact> {
            return localVarFp.coaApiVendorContactsCreate(requestParameters.id, requestParameters.vendorContact, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary List Vendor Contacts
         * @param {CoreAccountingApiCoaApiVendorContactsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiVendorContactsList(requestParameters: CoreAccountingApiCoaApiVendorContactsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedVendorContactList> {
            return localVarFp.coaApiVendorContactsList(requestParameters.id, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for coaApiBudgetsAccountsCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsAccountsCreateRequest {
    readonly budgetPk: number

    readonly budgetAccount?: BudgetAccount
}

/**
 * Request parameters for coaApiBudgetsAccountsDestroy operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsAccountsDestroyRequest {
    readonly budgetPk: number

    readonly id: number
}

/**
 * Request parameters for coaApiBudgetsAccountsList operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsAccountsListRequest {
    readonly budgetPk: number

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string
}

/**
 * Request parameters for coaApiBudgetsAccountsPartialUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsAccountsPartialUpdateRequest {
    readonly budgetPk: number

    readonly id: number

    readonly patchedBudgetAccount?: PatchedBudgetAccount
}

/**
 * Request parameters for coaApiBudgetsAccountsRetrieve operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsAccountsRetrieveRequest {
    readonly budgetPk: number

    readonly id: number
}

/**
 * Request parameters for coaApiBudgetsAccountsUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsAccountsUpdateRequest {
    readonly budgetPk: number

    readonly id: number

    readonly budgetAccount?: BudgetAccount
}

/**
 * Request parameters for coaApiBudgetsCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsCreateRequest {
    readonly budget: Budget
}

/**
 * Request parameters for coaApiBudgetsDestroy operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiBudgetsList operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsListRequest {
    /**
     * Filter by entity ID
     */
    readonly entity?: number

    /**
     * Filter by entity name (partial match)
     */
    readonly entityName?: string

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Search query - searches by budget name
     */
    readonly q?: string

    /**
     * Sort order. Use field name for ascending, -field for descending. Supports multiple fields separated by comma. Default: name
     */
    readonly sort?: string
}

/**
 * Request parameters for coaApiBudgetsPartialUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsPartialUpdateRequest {
    readonly id: number

    readonly patchedBudget?: PatchedBudget
}

/**
 * Request parameters for coaApiBudgetsRetrieve operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiBudgetsUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiBudgetsUpdateRequest {
    readonly id: number

    readonly budget: Budget
}

/**
 * Request parameters for coaApiDepartmentBulkSearchCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiDepartmentBulkSearchCreateRequest {
    readonly bulkDepartmentSearch: BulkDepartmentSearch
}

/**
 * Request parameters for coaApiFixedAssetCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiFixedAssetCreateRequest {
    readonly fixedAsset: FixedAsset
}

/**
 * Request parameters for coaApiFixedAssetDestroy operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiFixedAssetDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiFixedAssetList operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiFixedAssetListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiFixedAssetPartialUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiFixedAssetPartialUpdateRequest {
    readonly id: number

    readonly patchedFixedAsset?: PatchedFixedAsset
}

/**
 * Request parameters for coaApiFixedAssetRetrieve operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiFixedAssetRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiFixedAssetUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiFixedAssetUpdateRequest {
    readonly id: number

    readonly fixedAsset: FixedAsset
}

/**
 * Request parameters for coaApiIntercompanyJournalEntryCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiIntercompanyJournalEntryCreateRequest {
    readonly intercompanyJournalEntry?: IntercompanyJournalEntry
}

/**
 * Request parameters for coaApiIntercompanyJournalEntryDestroy operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiIntercompanyJournalEntryDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiIntercompanyJournalEntryList operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiIntercompanyJournalEntryListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for coaApiIntercompanyJournalEntryPartialUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiIntercompanyJournalEntryPartialUpdateRequest {
    readonly id: number

    readonly patchedIntercompanyJournalEntry?: PatchedIntercompanyJournalEntry
}

/**
 * Request parameters for coaApiIntercompanyJournalEntryRetrieve operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiIntercompanyJournalEntryRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiIntercompanyJournalEntryUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiIntercompanyJournalEntryUpdateRequest {
    readonly id: number

    readonly intercompanyJournalEntry?: IntercompanyJournalEntry
}

/**
 * Request parameters for coaApiJournalEntryCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiJournalEntryCreateRequest {
    readonly journalEntryPostResponse?: JournalEntryPostResponse
}

/**
 * Request parameters for coaApiJournalEntryDestroy operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiJournalEntryDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiJournalEntryList operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiJournalEntryListRequest {
    /**
     * Filter by account ID(s). Can specify multiple values.
     */
    readonly account?: string

    /**
     * Include all entries regardless of date range
     */
    readonly allTime?: boolean

    /**
     * End date for filtering (YYYY-MM-DD format)
     */
    readonly endDate?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Filter by journal entry source (e.g., \&#39;manual\&#39;, \&#39;CSV Upload\&#39;)
     */
    readonly source?: string

    /**
     * Start date for filtering (YYYY-MM-DD format)
     */
    readonly startDate?: string
}

/**
 * Request parameters for coaApiJournalEntryPartialUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiJournalEntryPartialUpdateRequest {
    readonly id: number

    readonly patchedJournalEntryPostResponse?: PatchedJournalEntryPostResponse
}

/**
 * Request parameters for coaApiJournalEntryRetrieve operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiJournalEntryRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiJournalEntryUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiJournalEntryUpdateRequest {
    readonly id: number

    readonly journalEntryPostResponse?: JournalEntryPostResponse
}

/**
 * Request parameters for coaApiTagBulkSearchCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTagBulkSearchCreateRequest {
    readonly bulkTagSearch: BulkTagSearch
}

/**
 * Request parameters for coaApiTransactionBillPaymentsCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionBillPaymentsCreateRequest {
    readonly transactionId: number
}

/**
 * Request parameters for coaApiTransactionCreditMemoPaymentsCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionCreditMemoPaymentsCreateRequest {
    readonly transactionId: number
}

/**
 * Request parameters for coaApiTransactionDebitMemoPaymentsCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionDebitMemoPaymentsCreateRequest {
    readonly transactionId: number
}

/**
 * Request parameters for coaApiTransactionDestroy operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiTransactionInvoicePaymentsCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionInvoicePaymentsCreateRequest {
    readonly transactionId: number
}

/**
 * Request parameters for coaApiTransactionPartialUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionPartialUpdateRequest {
    readonly id: number

    readonly patchedChartTransaction?: PatchedChartTransaction
}

/**
 * Request parameters for coaApiTransactionRetrieve2 operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionRetrieve2Request {
    readonly id: number
}

/**
 * Request parameters for coaApiTransactionUpdate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiTransactionUpdateRequest {
    readonly id: number

    readonly chartTransaction: ChartTransaction
}

/**
 * Request parameters for coaApiVendorBulkSearchCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiVendorBulkSearchCreateRequest {
    readonly bulkVendorSearch: BulkVendorSearch
}

/**
 * Request parameters for coaApiVendorContactsCreate operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiVendorContactsCreateRequest {
    readonly id: number

    readonly vendorContact?: VendorContact
}

/**
 * Request parameters for coaApiVendorContactsList operation in CoreAccountingApi.
 */
export interface CoreAccountingApiCoaApiVendorContactsListRequest {
    readonly id: number

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * CoreAccountingApi - object-oriented interface
 */
export class CoreAccountingApi extends BaseAPI {
    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Budget
     * @param {CoreAccountingApiCoaApiBudgetsAccountsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsAccountsCreate(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsAccountsCreate(requestParameters.budgetPk, requestParameters.budgetAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Budget Account
     * @param {CoreAccountingApiCoaApiBudgetsAccountsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsAccountsDestroy(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsAccountsDestroy(requestParameters.budgetPk, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of budget accounts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Budget Accounts
     * @param {CoreAccountingApiCoaApiBudgetsAccountsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsAccountsList(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsListRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsAccountsList(requestParameters.budgetPk, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Budget Account
     * @param {CoreAccountingApiCoaApiBudgetsAccountsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsAccountsPartialUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsAccountsPartialUpdate(requestParameters.budgetPk, requestParameters.id, requestParameters.patchedBudgetAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Budget Account
     * @param {CoreAccountingApiCoaApiBudgetsAccountsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsAccountsRetrieve(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsAccountsRetrieve(requestParameters.budgetPk, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Budget Account
     * @param {CoreAccountingApiCoaApiBudgetsAccountsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsAccountsUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsAccountsUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsAccountsUpdate(requestParameters.budgetPk, requestParameters.id, requestParameters.budgetAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Budget
     * @param {CoreAccountingApiCoaApiBudgetsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsCreate(requestParameters: CoreAccountingApiCoaApiBudgetsCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsCreate(requestParameters.budget, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Budget
     * @param {CoreAccountingApiCoaApiBudgetsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsDestroy(requestParameters: CoreAccountingApiCoaApiBudgetsDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of budgets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Budgets
     * @param {CoreAccountingApiCoaApiBudgetsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsList(requestParameters: CoreAccountingApiCoaApiBudgetsListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsList(requestParameters.entity, requestParameters.entityName, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, requestParameters.q, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Budget
     * @param {CoreAccountingApiCoaApiBudgetsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsPartialUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsPartialUpdate(requestParameters.id, requestParameters.patchedBudget, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Budget
     * @param {CoreAccountingApiCoaApiBudgetsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsRetrieve(requestParameters: CoreAccountingApiCoaApiBudgetsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Budget
     * @param {CoreAccountingApiCoaApiBudgetsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiBudgetsUpdate(requestParameters: CoreAccountingApiCoaApiBudgetsUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiBudgetsUpdate(requestParameters.id, requestParameters.budget, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for thousands of departments by exact name match in a single request. Optimized for performance. Supports upsert to create missing departments.
     * @summary Bulk Search Departments by Name
     * @param {CoreAccountingApiCoaApiDepartmentBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiDepartmentBulkSearchCreate(requestParameters: CoreAccountingApiCoaApiDepartmentBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiDepartmentBulkSearchCreate(requestParameters.bulkDepartmentSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Fixed Asset
     * @param {CoreAccountingApiCoaApiFixedAssetCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetCreate(requestParameters: CoreAccountingApiCoaApiFixedAssetCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiFixedAssetCreate(requestParameters.fixedAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Fixed Asset
     * @param {CoreAccountingApiCoaApiFixedAssetDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetDestroy(requestParameters: CoreAccountingApiCoaApiFixedAssetDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiFixedAssetDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of fixed assets with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Fixed Assets
     * @param {CoreAccountingApiCoaApiFixedAssetListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetList(requestParameters: CoreAccountingApiCoaApiFixedAssetListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiFixedAssetList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Fixed Asset
     * @param {CoreAccountingApiCoaApiFixedAssetPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetPartialUpdate(requestParameters: CoreAccountingApiCoaApiFixedAssetPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiFixedAssetPartialUpdate(requestParameters.id, requestParameters.patchedFixedAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Fixed Asset
     * @param {CoreAccountingApiCoaApiFixedAssetRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetRetrieve(requestParameters: CoreAccountingApiCoaApiFixedAssetRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiFixedAssetRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Fixed Asset
     * @param {CoreAccountingApiCoaApiFixedAssetUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiFixedAssetUpdate(requestParameters: CoreAccountingApiCoaApiFixedAssetUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiFixedAssetUpdate(requestParameters.id, requestParameters.fixedAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Creates a new intercompany journal entry          This endpoint allows for complex multi-entity transactions where:         - Transactions are balanced across different entities         - Exchange rates are handled for multi-currency transactions          Key requirements:         - Total debits must equal total credits for each entity (debit_amount_native must equal credit_amount_native)         - Cannot create entries before closed book dates         - All referenced accounts must be active         
     * @summary Create Intercompany Journal Entry
     * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiIntercompanyJournalEntryCreate(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiIntercompanyJournalEntryCreate(requestParameters.intercompanyJournalEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Permanently deletes an intercompany journal entry and all related transactions.          This endpoint performs a comprehensive cleanup when deleting an intercompany journal entry:         - Validates that the entry can be deleted (not in closed period)         - Removes all associated journal entries across entities         - Updates summary tables and account balances         - Handles cascade deletion of related transactions         - Ensures data integrity across the accounting system          Deletion restrictions:         - Cannot delete entries in closed accounting periods          Error conditions:         - 400 Bad Request: Entry date is in a closed period         - 409 Conflict: Entry has protected relationships (e.g., close checklist tasks)         - 404 Not Found: Entry does not exist or user lacks access          On successful deletion, all related journal entries are removed and accounting summaries are recalculated.         
     * @summary Delete Intercompany Journal Entry
     * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiIntercompanyJournalEntryDestroy(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiIntercompanyJournalEntryDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieves a paginated list of intercompany journal entries for the authenticated user\'s customer.          This endpoint returns:         - Summary information for each intercompany journal entry         - Basic transaction details (simplified view for list performance)         - Entity and exchange rate information         - Pagination metadata (count, next, previous)         - Reversal relationships and attachment counts          The response includes:         - Intercompany journal entry metadata         - Associated transaction summaries         - Entity exchange rate information         - Links to related reversals         - Attachment information          Results can be sorted using the \'sort\' query parameter with field names like \'date\', \'id\', etc.         Prefix with \'-\' for descending order (e.g., \'-date\').         
     * @summary List Intercompany Journal Entries
     * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiIntercompanyJournalEntryList(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiIntercompanyJournalEntryList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Performs a partial update of an intercompany journal entry, allowing modification of specific fields without replacing the entire entry.          This endpoint supports partial updates to:         - Journal entry metadata (memo, date, currency, reference number)         - Individual transaction modifications         - Entity exchange rate adjustments         - Vendor, department, and tag assignments         - Account categorizations and amounts          Key differences from PUT:         - Only specified fields are updated (vs. full replacement)         - Maintains existing data for unspecified fields         - Supports granular transaction modifications         - Preserves audit trail and timestamps         - Allows incremental changes without full transaction rebuilds          Validation requirements:         - Modified transactions must maintain entity balance (debits = credits)         - Cannot modify entries in closed accounting periods         - All referenced accounts, vendors, departments must be active         - Exchange rates must be valid for multi-currency transactions         - Account assignments must be appropriate for transaction types         
     * @summary Partial Update Intercompany Journal Entry
     * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiIntercompanyJournalEntryPartialUpdate(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiIntercompanyJournalEntryPartialUpdate(requestParameters.id, requestParameters.patchedIntercompanyJournalEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieves a single intercompany journal entry by its ID with complete details.          This endpoint returns:         - Complete intercompany journal entry information         - Full transaction details with all accounting fields         - Entity information and exchange rates         - Attachment and reversal information         - Comprehensive transaction metadata          The response includes:         - All transaction details with account information         - Entity exchange rate data         - Vendor, department, and tag information         - Balance calculations and transaction history         - File attachments and reversal relationships         - Complete audit trail information          This is the detailed view used for editing and complete transaction analysis.         
     * @summary Get Intercompany Journal Entry
     * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiIntercompanyJournalEntryRetrieve(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiIntercompanyJournalEntryRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Updates an existing intercompany journal entry with new transaction details.          This endpoint allows for:         - Modifying transaction amounts and details         - Updating entity assignments and exchange rates         - Changing account assignments and categorizations         - Updating vendor, department, and tag information         - Maintaining balance validation across all entities          Key requirements:         - Total debits must equal total credits for each entity         - All account balances must be valid in all currencies         - Cannot modify entries in closed periods         - All referenced accounts must be active         - Existing transactions are replaced with new transaction set          The update process atomically replaces all transactions while preserving the journal entry ID and audit trail.         
     * @summary Update Intercompany Journal Entry
     * @param {CoreAccountingApiCoaApiIntercompanyJournalEntryUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiIntercompanyJournalEntryUpdate(requestParameters: CoreAccountingApiCoaApiIntercompanyJournalEntryUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiIntercompanyJournalEntryUpdate(requestParameters.id, requestParameters.intercompanyJournalEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Create a new journal entry with transactions. Journal entries must balance - total debits must equal total credits.          **Key Features:**         - Automatic currency conversion using exchange rates         - Vendor, Department and Custom Dimension assignment         - Optional reversal date for automatic reversal entries         - Validation against closed book periods          **Validation Rules:**         - Debits must equal credits in transaction currency (debit_native and credit_native)         - Cannot create entries before closed book dates         - Accounts must be active         - Exchange rates are auto-calculated if not provided         
     * @summary Create Journal Entry
     * @param {CoreAccountingApiCoaApiJournalEntryCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiJournalEntryCreate(requestParameters: CoreAccountingApiCoaApiJournalEntryCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiJournalEntryCreate(requestParameters.journalEntryPostResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Delete a journal entry and all its associated transactions.          **Restrictions:**         - Cannot delete entries before closed book dates          **Response Codes:**         - 204: Successfully deleted         - 400: Cannot delete (books closed for this date)         - 409: Cannot delete (associated with other objects)         
     * @summary Delete Journal Entry
     * @param {CoreAccountingApiCoaApiJournalEntryDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiJournalEntryDestroy(requestParameters: CoreAccountingApiCoaApiJournalEntryDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiJournalEntryDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a paginated list of journal entries with optional filtering and sorting.          **Query Parameters:**         - `start_date`, `end_date`: Filter by date range (defaults to last 6 months)         - `account`: Filter by account ID(s) - supports multiple values         - `source`: Filter by journal entry source         - `journal_id`: Filter by specific journal ID         - `all_time`: Include all entries regardless of date (true/false)         - `sort`: Sort field (default: \"date\")          **Response includes:**         - Complete journal entry details with all transactions         - Account information with names and numbers         - Vendor and department details         - Tag associations with groups         - Attachment information         - Exchange rate data for multi-currency entries         
     * @summary List Journal Entries
     * @param {CoreAccountingApiCoaApiJournalEntryListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiJournalEntryList(requestParameters: CoreAccountingApiCoaApiJournalEntryListRequest = {}, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiJournalEntryList(requestParameters.account, requestParameters.allTime, requestParameters.endDate, requestParameters.limit, requestParameters.offset, requestParameters.source, requestParameters.startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Partially update a journal entry. Only provided fields will be updated.          **Common Use Cases:**         - Update memo or reference number         - Change journal entry date         - Modify specific transaction amounts         - Add or remove tags from transactions          **Validation Rules:**         - Journal entry must still balance after updates         - Cannot modify entries in closed periods         - Account changes must maintain chart of accounts rules         
     * @summary Partial Update Journal Entry
     * @param {CoreAccountingApiCoaApiJournalEntryPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiJournalEntryPartialUpdate(requestParameters: CoreAccountingApiCoaApiJournalEntryPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiJournalEntryPartialUpdate(requestParameters.id, requestParameters.patchedJournalEntryPostResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a specific journal entry by ID with all transaction details.          **Response includes:**         - Complete journal entry with all transactions         - Account names, numbers, and types         - Vendor and department information         - Tag associations with groups         - Exchange rate data for multi-currency entries         - Attachment information         - Reversal information if applicable         
     * @summary Retrieve Journal Entry
     * @param {CoreAccountingApiCoaApiJournalEntryRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiJournalEntryRetrieve(requestParameters: CoreAccountingApiCoaApiJournalEntryRetrieveRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiJournalEntryRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Update a journal entry completely. All transactions will be replaced with the new ones provided.          **Important Notes:**         - Cannot update entries before closed book dates         - Must maintain double-entry bookkeeping (debits = credits)         - All existing transactions will be replaced         - Exchange rates will be recalculated if not provided          **Validation Rules:**         - Journal entry must balance in all currencies         - Accounts must be active         - Cannot modify entries in closed periods         
     * @summary Update Journal Entry
     * @param {CoreAccountingApiCoaApiJournalEntryUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiJournalEntryUpdate(requestParameters: CoreAccountingApiCoaApiJournalEntryUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiJournalEntryUpdate(requestParameters.id, requestParameters.journalEntryPostResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for tags by exact name match in a single request. Supports upsert to create missing tags.
     * @summary Bulk Search Custom Dimensions by Name
     * @param {CoreAccountingApiCoaApiTagBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTagBulkSearchCreate(requestParameters: CoreAccountingApiCoaApiTagBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTagBulkSearchCreate(requestParameters.bulkTagSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply bill payments to a bank transaction, linking the transaction to one or more bills.
     * @summary Apply Bill Payments to Transaction
     * @param {CoreAccountingApiCoaApiTransactionBillPaymentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionBillPaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionBillPaymentsCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionBillPaymentsCreate(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply credit memo payments to a bank transaction.
     * @summary Apply Credit Memo Payments to Transaction
     * @param {CoreAccountingApiCoaApiTransactionCreditMemoPaymentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionCreditMemoPaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionCreditMemoPaymentsCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionCreditMemoPaymentsCreate(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply debit memo payments to a bank transaction.
     * @summary Apply Debit Memo Payments to Transaction
     * @param {CoreAccountingApiCoaApiTransactionDebitMemoPaymentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionDebitMemoPaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionDebitMemoPaymentsCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionDebitMemoPaymentsCreate(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a chart transaction. Cannot delete transactions in closed accounting periods.
     * @summary Delete Chart Transaction
     * @param {CoreAccountingApiCoaApiTransactionDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionDestroy(requestParameters: CoreAccountingApiCoaApiTransactionDestroyRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Apply invoice payments to a bank transaction, linking the transaction to one or more invoices.
     * @summary Apply Invoice Payments to Transaction
     * @param {CoreAccountingApiCoaApiTransactionInvoicePaymentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionInvoicePaymentsCreate(requestParameters: CoreAccountingApiCoaApiTransactionInvoicePaymentsCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionInvoicePaymentsCreate(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Chart Transaction
     * @param {CoreAccountingApiCoaApiTransactionPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionPartialUpdate(requestParameters: CoreAccountingApiCoaApiTransactionPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionPartialUpdate(requestParameters.id, requestParameters.patchedChartTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve chart transactions with advanced filtering options
     * @summary List Chart Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionRetrieve(options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Chart Transaction
     * @param {CoreAccountingApiCoaApiTransactionRetrieve2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionRetrieve2(requestParameters: CoreAccountingApiCoaApiTransactionRetrieve2Request, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionRetrieve2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Chart Transaction
     * @param {CoreAccountingApiCoaApiTransactionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiTransactionUpdate(requestParameters: CoreAccountingApiCoaApiTransactionUpdateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiTransactionUpdate(requestParameters.id, requestParameters.chartTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for thousands of vendors by external_id (priority) or name in a single request. Optimized for performance. Supports upsert to create missing vendors.
     * @summary Bulk Search Vendors by External ID or Name
     * @param {CoreAccountingApiCoaApiVendorBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorBulkSearchCreate(requestParameters: CoreAccountingApiCoaApiVendorBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiVendorBulkSearchCreate(requestParameters.bulkVendorSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Vendor Contact
     * @param {CoreAccountingApiCoaApiVendorContactsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorContactsCreate(requestParameters: CoreAccountingApiCoaApiVendorContactsCreateRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiVendorContactsCreate(requestParameters.id, requestParameters.vendorContact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary List Vendor Contacts
     * @param {CoreAccountingApiCoaApiVendorContactsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiVendorContactsList(requestParameters: CoreAccountingApiCoaApiVendorContactsListRequest, options?: RawAxiosRequestConfig) {
        return CoreAccountingApiFp(this.configuration).coaApiVendorContactsList(requestParameters.id, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomFieldsApi - axios parameter creator
 */
export const CustomFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reorder custom fields
         * @summary Reorder Custom Fields
         * @param {CaApiV1CustomFieldsReorderCreateRequest} [caApiV1CustomFieldsReorderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsReorderCreate: async (caApiV1CustomFieldsReorderCreateRequest?: CaApiV1CustomFieldsReorderCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/v1/custom-fields/reorder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caApiV1CustomFieldsReorderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomFieldsApi - functional programming interface
 */
export const CustomFieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Reorder custom fields
         * @summary Reorder Custom Fields
         * @param {CaApiV1CustomFieldsReorderCreateRequest} [caApiV1CustomFieldsReorderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiV1CustomFieldsReorderCreate(caApiV1CustomFieldsReorderCreateRequest?: CaApiV1CustomFieldsReorderCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiV1CustomFieldsReorderCreate(caApiV1CustomFieldsReorderCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomFieldsApi.caApiV1CustomFieldsReorderCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomFieldsApi - factory interface
 */
export const CustomFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomFieldsApiFp(configuration)
    return {
        /**
         * Reorder custom fields
         * @summary Reorder Custom Fields
         * @param {CustomFieldsApiCaApiV1CustomFieldsReorderCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiV1CustomFieldsReorderCreate(requestParameters: CustomFieldsApiCaApiV1CustomFieldsReorderCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiV1CustomFieldsReorderCreate(requestParameters.caApiV1CustomFieldsReorderCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for caApiV1CustomFieldsReorderCreate operation in CustomFieldsApi.
 */
export interface CustomFieldsApiCaApiV1CustomFieldsReorderCreateRequest {
    readonly caApiV1CustomFieldsReorderCreateRequest?: CaApiV1CustomFieldsReorderCreateRequest
}

/**
 * CustomFieldsApi - object-oriented interface
 */
export class CustomFieldsApi extends BaseAPI {
    /**
     * Reorder custom fields
     * @summary Reorder Custom Fields
     * @param {CustomFieldsApiCaApiV1CustomFieldsReorderCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiV1CustomFieldsReorderCreate(requestParameters: CustomFieldsApiCaApiV1CustomFieldsReorderCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return CustomFieldsApiFp(this.configuration).caApiV1CustomFieldsReorderCreate(requestParameters.caApiV1CustomFieldsReorderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FinancialStatementsApi - axios parameter creator
 */
export const FinancialStatementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Cash Basis Operating Statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiCashBasisOperatingStatementRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/cash-basis-operating-statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cash Basis Income Statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiCashBasisRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/cash-basis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Balance Sheet
         * @param {CaApiGetBalanceSheetRetrieveCadenceEnum} [cadence] 
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetBalanceSheetRetrieve: async (cadence?: CaApiGetBalanceSheetRetrieveCadenceEnum, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/get_balance_sheet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cadence !== undefined) {
                localVarQueryParameter['cadence'] = cadence;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (entityRollup !== undefined) {
                localVarQueryParameter['entity_rollup'] = entityRollup;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cash Flow
         * @param {CaApiGetCashFlowRetrieveCadenceEnum} [cadence] 
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetCashFlowRetrieve: async (cadence?: CaApiGetCashFlowRetrieveCadenceEnum, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/get_cash_flow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cadence !== undefined) {
                localVarQueryParameter['cadence'] = cadence;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (entityRollup !== undefined) {
                localVarQueryParameter['entity_rollup'] = entityRollup;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Income Statement
         * @param {CaApiGetIncomeStatementRetrieveCadenceEnum} [cadence] 
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetIncomeStatementRetrieve: async (cadence?: CaApiGetIncomeStatementRetrieveCadenceEnum, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/get_income_statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cadence !== undefined) {
                localVarQueryParameter['cadence'] = cadence;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (entityRollup !== undefined) {
                localVarQueryParameter['entity_rollup'] = entityRollup;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Trial Balance
         * @param {number} [department] Filter by department ID. Can be specified multiple times for multiple departments
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetTrialBalanceRetrieve: async (department?: number, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/get_trial_balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (department !== undefined) {
                localVarQueryParameter['department'] = department;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }

            if (entityRollup !== undefined) {
                localVarQueryParameter['entity_rollup'] = entityRollup;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get General Ledger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiGeneralLedgerRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/general-ledger`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinancialStatementsApi - functional programming interface
 */
export const FinancialStatementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinancialStatementsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Cash Basis Operating Statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiCashBasisOperatingStatementRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiCashBasisOperatingStatementRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialStatementsApi.caApiCashBasisOperatingStatementRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cash Basis Income Statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiCashBasisRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiCashBasisRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialStatementsApi.caApiCashBasisRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Balance Sheet
         * @param {CaApiGetBalanceSheetRetrieveCadenceEnum} [cadence] 
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiGetBalanceSheetRetrieve(cadence?: CaApiGetBalanceSheetRetrieveCadenceEnum, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaApiGetBalanceSheetRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiGetBalanceSheetRetrieve(cadence, endDate, entity, entityRollup, groupBy, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialStatementsApi.caApiGetBalanceSheetRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cash Flow
         * @param {CaApiGetCashFlowRetrieveCadenceEnum} [cadence] 
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiGetCashFlowRetrieve(cadence?: CaApiGetCashFlowRetrieveCadenceEnum, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaApiGetCashFlowRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiGetCashFlowRetrieve(cadence, endDate, entity, entityRollup, groupBy, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialStatementsApi.caApiGetCashFlowRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Income Statement
         * @param {CaApiGetIncomeStatementRetrieveCadenceEnum} [cadence] 
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiGetIncomeStatementRetrieve(cadence?: CaApiGetIncomeStatementRetrieveCadenceEnum, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaApiGetIncomeStatementRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiGetIncomeStatementRetrieve(cadence, endDate, entity, entityRollup, groupBy, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialStatementsApi.caApiGetIncomeStatementRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Trial Balance
         * @param {number} [department] Filter by department ID. Can be specified multiple times for multiple departments
         * @param {string} [endDate] Latest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {number} [entity] 
         * @param {boolean} [entityRollup] If true, includes all data of children entities in consolidation
         * @param {string} [groupBy] 
         * @param {string} [startDate] Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiGetTrialBalanceRetrieve(department?: number, endDate?: string, entity?: number, entityRollup?: boolean, groupBy?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrialBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiGetTrialBalanceRetrieve(department, endDate, entity, entityRollup, groupBy, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialStatementsApi.caApiGetTrialBalanceRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get General Ledger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiGeneralLedgerRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiGeneralLedgerRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinancialStatementsApi.coaApiGeneralLedgerRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FinancialStatementsApi - factory interface
 */
export const FinancialStatementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinancialStatementsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Cash Basis Operating Statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiCashBasisOperatingStatementRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiCashBasisOperatingStatementRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cash Basis Income Statement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiCashBasisRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiCashBasisRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Balance Sheet
         * @param {FinancialStatementsApiCaApiGetBalanceSheetRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetBalanceSheetRetrieve(requestParameters: FinancialStatementsApiCaApiGetBalanceSheetRetrieveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CaApiGetBalanceSheetRetrieve200Response> {
            return localVarFp.caApiGetBalanceSheetRetrieve(requestParameters.cadence, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cash Flow
         * @param {FinancialStatementsApiCaApiGetCashFlowRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetCashFlowRetrieve(requestParameters: FinancialStatementsApiCaApiGetCashFlowRetrieveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CaApiGetCashFlowRetrieve200Response> {
            return localVarFp.caApiGetCashFlowRetrieve(requestParameters.cadence, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Income Statement
         * @param {FinancialStatementsApiCaApiGetIncomeStatementRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetIncomeStatementRetrieve(requestParameters: FinancialStatementsApiCaApiGetIncomeStatementRetrieveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CaApiGetIncomeStatementRetrieve200Response> {
            return localVarFp.caApiGetIncomeStatementRetrieve(requestParameters.cadence, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Trial Balance
         * @param {FinancialStatementsApiCaApiGetTrialBalanceRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiGetTrialBalanceRetrieve(requestParameters: FinancialStatementsApiCaApiGetTrialBalanceRetrieveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TrialBalanceResponse> {
            return localVarFp.caApiGetTrialBalanceRetrieve(requestParameters.department, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get General Ledger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiGeneralLedgerRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiGeneralLedgerRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for caApiGetBalanceSheetRetrieve operation in FinancialStatementsApi.
 */
export interface FinancialStatementsApiCaApiGetBalanceSheetRetrieveRequest {
    readonly cadence?: CaApiGetBalanceSheetRetrieveCadenceEnum

    /**
     * Latest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly endDate?: string

    readonly entity?: number

    /**
     * If true, includes all data of children entities in consolidation
     */
    readonly entityRollup?: boolean

    readonly groupBy?: string

    /**
     * Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly startDate?: string
}

/**
 * Request parameters for caApiGetCashFlowRetrieve operation in FinancialStatementsApi.
 */
export interface FinancialStatementsApiCaApiGetCashFlowRetrieveRequest {
    readonly cadence?: CaApiGetCashFlowRetrieveCadenceEnum

    /**
     * Latest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly endDate?: string

    readonly entity?: number

    /**
     * If true, includes all data of children entities in consolidation
     */
    readonly entityRollup?: boolean

    readonly groupBy?: string

    /**
     * Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly startDate?: string
}

/**
 * Request parameters for caApiGetIncomeStatementRetrieve operation in FinancialStatementsApi.
 */
export interface FinancialStatementsApiCaApiGetIncomeStatementRetrieveRequest {
    readonly cadence?: CaApiGetIncomeStatementRetrieveCadenceEnum

    /**
     * Latest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly endDate?: string

    readonly entity?: number

    /**
     * If true, includes all data of children entities in consolidation
     */
    readonly entityRollup?: boolean

    readonly groupBy?: string

    /**
     * Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly startDate?: string
}

/**
 * Request parameters for caApiGetTrialBalanceRetrieve operation in FinancialStatementsApi.
 */
export interface FinancialStatementsApiCaApiGetTrialBalanceRetrieveRequest {
    /**
     * Filter by department ID. Can be specified multiple times for multiple departments
     */
    readonly department?: number

    /**
     * Latest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly endDate?: string

    readonly entity?: number

    /**
     * If true, includes all data of children entities in consolidation
     */
    readonly entityRollup?: boolean

    readonly groupBy?: string

    /**
     * Earliest date (inclusive) for which to retrieve data. Defaults to six months ago
     */
    readonly startDate?: string
}

/**
 * FinancialStatementsApi - object-oriented interface
 */
export class FinancialStatementsApi extends BaseAPI {
    /**
     * 
     * @summary Get Cash Basis Operating Statement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiCashBasisOperatingStatementRetrieve(options?: RawAxiosRequestConfig) {
        return FinancialStatementsApiFp(this.configuration).caApiCashBasisOperatingStatementRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cash Basis Income Statement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiCashBasisRetrieve(options?: RawAxiosRequestConfig) {
        return FinancialStatementsApiFp(this.configuration).caApiCashBasisRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Balance Sheet
     * @param {FinancialStatementsApiCaApiGetBalanceSheetRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiGetBalanceSheetRetrieve(requestParameters: FinancialStatementsApiCaApiGetBalanceSheetRetrieveRequest = {}, options?: RawAxiosRequestConfig) {
        return FinancialStatementsApiFp(this.configuration).caApiGetBalanceSheetRetrieve(requestParameters.cadence, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cash Flow
     * @param {FinancialStatementsApiCaApiGetCashFlowRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiGetCashFlowRetrieve(requestParameters: FinancialStatementsApiCaApiGetCashFlowRetrieveRequest = {}, options?: RawAxiosRequestConfig) {
        return FinancialStatementsApiFp(this.configuration).caApiGetCashFlowRetrieve(requestParameters.cadence, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Income Statement
     * @param {FinancialStatementsApiCaApiGetIncomeStatementRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiGetIncomeStatementRetrieve(requestParameters: FinancialStatementsApiCaApiGetIncomeStatementRetrieveRequest = {}, options?: RawAxiosRequestConfig) {
        return FinancialStatementsApiFp(this.configuration).caApiGetIncomeStatementRetrieve(requestParameters.cadence, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Trial Balance
     * @param {FinancialStatementsApiCaApiGetTrialBalanceRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiGetTrialBalanceRetrieve(requestParameters: FinancialStatementsApiCaApiGetTrialBalanceRetrieveRequest = {}, options?: RawAxiosRequestConfig) {
        return FinancialStatementsApiFp(this.configuration).caApiGetTrialBalanceRetrieve(requestParameters.department, requestParameters.endDate, requestParameters.entity, requestParameters.entityRollup, requestParameters.groupBy, requestParameters.startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get General Ledger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiGeneralLedgerRetrieve(options?: RawAxiosRequestConfig) {
        return FinancialStatementsApiFp(this.configuration).coaApiGeneralLedgerRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}

export const CaApiGetBalanceSheetRetrieveCadenceEnum = {
    Daily: 'daily',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    Weekly: 'weekly',
    Yearly: 'yearly'
} as const;
export type CaApiGetBalanceSheetRetrieveCadenceEnum = typeof CaApiGetBalanceSheetRetrieveCadenceEnum[keyof typeof CaApiGetBalanceSheetRetrieveCadenceEnum];
export const CaApiGetCashFlowRetrieveCadenceEnum = {
    Daily: 'daily',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    Weekly: 'weekly',
    Yearly: 'yearly'
} as const;
export type CaApiGetCashFlowRetrieveCadenceEnum = typeof CaApiGetCashFlowRetrieveCadenceEnum[keyof typeof CaApiGetCashFlowRetrieveCadenceEnum];
export const CaApiGetIncomeStatementRetrieveCadenceEnum = {
    Daily: 'daily',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    Weekly: 'weekly',
    Yearly: 'yearly'
} as const;
export type CaApiGetIncomeStatementRetrieveCadenceEnum = typeof CaApiGetIncomeStatementRetrieveCadenceEnum[keyof typeof CaApiGetIncomeStatementRetrieveCadenceEnum];


/**
 * IntegrationsApi - axios parameter creator
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Webhook
         * @param {Webhook} webhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookCreate: async (webhook: Webhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhook' is not null or undefined
            assertParamExists('integrationsApiV1WebhookCreate', 'webhook', webhook)
            const localVarPath = `/integrations/api/v1/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Webhook
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('integrationsApiV1WebhookDestroy', 'id', id)
            const localVarPath = `/integrations/api/v1/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhook Events
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookEventsList: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('integrationsApiV1WebhookEventsList', 'id', id)
            const localVarPath = `/integrations/api/v1/webhook/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/api/v1/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Webhook
         * @param {number} id 
         * @param {PatchedWebhook} [patchedWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookPartialUpdate: async (id: number, patchedWebhook?: PatchedWebhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('integrationsApiV1WebhookPartialUpdate', 'id', id)
            const localVarPath = `/integrations/api/v1/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Webhook
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('integrationsApiV1WebhookRetrieve', 'id', id)
            const localVarPath = `/integrations/api/v1/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Webhook
         * @param {number} id 
         * @param {Webhook} webhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookUpdate: async (id: number, webhook: Webhook, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('integrationsApiV1WebhookUpdate', 'id', id)
            // verify required parameter 'webhook' is not null or undefined
            assertParamExists('integrationsApiV1WebhookUpdate', 'webhook', webhook)
            const localVarPath = `/integrations/api/v1/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Webhook
         * @param {Webhook} webhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsApiV1WebhookCreate(webhook: Webhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsApiV1WebhookCreate(webhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsApiV1WebhookCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Webhook
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsApiV1WebhookDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsApiV1WebhookDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsApiV1WebhookDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Webhook Events
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsApiV1WebhookEventsList(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsApiV1WebhookEventsList(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsApiV1WebhookEventsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsApiV1WebhookList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Webhook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsApiV1WebhookList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsApiV1WebhookList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Webhook
         * @param {number} id 
         * @param {PatchedWebhook} [patchedWebhook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsApiV1WebhookPartialUpdate(id: number, patchedWebhook?: PatchedWebhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsApiV1WebhookPartialUpdate(id, patchedWebhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsApiV1WebhookPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Webhook
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsApiV1WebhookRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsApiV1WebhookRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsApiV1WebhookRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Webhook
         * @param {number} id 
         * @param {Webhook} webhook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsApiV1WebhookUpdate(id: number, webhook: Webhook, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsApiV1WebhookUpdate(id, webhook, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsApiV1WebhookUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Webhook
         * @param {IntegrationsApiIntegrationsApiV1WebhookCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookCreate(requestParameters: IntegrationsApiIntegrationsApiV1WebhookCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.integrationsApiV1WebhookCreate(requestParameters.webhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Webhook
         * @param {IntegrationsApiIntegrationsApiV1WebhookDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookDestroy(requestParameters: IntegrationsApiIntegrationsApiV1WebhookDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.integrationsApiV1WebhookDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhook Events
         * @param {IntegrationsApiIntegrationsApiV1WebhookEventsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookEventsList(requestParameters: IntegrationsApiIntegrationsApiV1WebhookEventsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookEvent>> {
            return localVarFp.integrationsApiV1WebhookEventsList(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Webhook>> {
            return localVarFp.integrationsApiV1WebhookList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Webhook
         * @param {IntegrationsApiIntegrationsApiV1WebhookPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookPartialUpdate(requestParameters: IntegrationsApiIntegrationsApiV1WebhookPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.integrationsApiV1WebhookPartialUpdate(requestParameters.id, requestParameters.patchedWebhook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Webhook
         * @param {IntegrationsApiIntegrationsApiV1WebhookRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookRetrieve(requestParameters: IntegrationsApiIntegrationsApiV1WebhookRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.integrationsApiV1WebhookRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Webhook
         * @param {IntegrationsApiIntegrationsApiV1WebhookUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsApiV1WebhookUpdate(requestParameters: IntegrationsApiIntegrationsApiV1WebhookUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.integrationsApiV1WebhookUpdate(requestParameters.id, requestParameters.webhook, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for integrationsApiV1WebhookCreate operation in IntegrationsApi.
 */
export interface IntegrationsApiIntegrationsApiV1WebhookCreateRequest {
    readonly webhook: Webhook
}

/**
 * Request parameters for integrationsApiV1WebhookDestroy operation in IntegrationsApi.
 */
export interface IntegrationsApiIntegrationsApiV1WebhookDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for integrationsApiV1WebhookEventsList operation in IntegrationsApi.
 */
export interface IntegrationsApiIntegrationsApiV1WebhookEventsListRequest {
    readonly id: number
}

/**
 * Request parameters for integrationsApiV1WebhookPartialUpdate operation in IntegrationsApi.
 */
export interface IntegrationsApiIntegrationsApiV1WebhookPartialUpdateRequest {
    readonly id: number

    readonly patchedWebhook?: PatchedWebhook
}

/**
 * Request parameters for integrationsApiV1WebhookRetrieve operation in IntegrationsApi.
 */
export interface IntegrationsApiIntegrationsApiV1WebhookRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for integrationsApiV1WebhookUpdate operation in IntegrationsApi.
 */
export interface IntegrationsApiIntegrationsApiV1WebhookUpdateRequest {
    readonly id: number

    readonly webhook: Webhook
}

/**
 * IntegrationsApi - object-oriented interface
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * 
     * @summary Create Webhook
     * @param {IntegrationsApiIntegrationsApiV1WebhookCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public integrationsApiV1WebhookCreate(requestParameters: IntegrationsApiIntegrationsApiV1WebhookCreateRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsApiV1WebhookCreate(requestParameters.webhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Webhook
     * @param {IntegrationsApiIntegrationsApiV1WebhookDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public integrationsApiV1WebhookDestroy(requestParameters: IntegrationsApiIntegrationsApiV1WebhookDestroyRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsApiV1WebhookDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhook Events
     * @param {IntegrationsApiIntegrationsApiV1WebhookEventsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public integrationsApiV1WebhookEventsList(requestParameters: IntegrationsApiIntegrationsApiV1WebhookEventsListRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsApiV1WebhookEventsList(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public integrationsApiV1WebhookList(options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsApiV1WebhookList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Webhook
     * @param {IntegrationsApiIntegrationsApiV1WebhookPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public integrationsApiV1WebhookPartialUpdate(requestParameters: IntegrationsApiIntegrationsApiV1WebhookPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsApiV1WebhookPartialUpdate(requestParameters.id, requestParameters.patchedWebhook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Webhook
     * @param {IntegrationsApiIntegrationsApiV1WebhookRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public integrationsApiV1WebhookRetrieve(requestParameters: IntegrationsApiIntegrationsApiV1WebhookRetrieveRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsApiV1WebhookRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Webhook
     * @param {IntegrationsApiIntegrationsApiV1WebhookUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public integrationsApiV1WebhookUpdate(requestParameters: IntegrationsApiIntegrationsApiV1WebhookUpdateRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsApiV1WebhookUpdate(requestParameters.id, requestParameters.webhook, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RevenueRecognitionApi - axios parameter creator
 */
export const RevenueRecognitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new contract
         * @summary Create Contract
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (contract?: Contract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new contract bundle
         * @summary Create Contract Bundle
         * @param {number} contractId 
         * @param {ContractBundle} contractBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractBundle: async (contractId: number, contractBundle: ContractBundle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('createContractBundle', 'contractId', contractId)
            // verify required parameter 'contractBundle' is not null or undefined
            assertParamExists('createContractBundle', 'contractBundle', contractBundle)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/bundles`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new milestone for a contract. This will automatically create an associated revenue transaction.
         * @summary Create Contract Milestone
         * @param {number} contractId 
         * @param {ContractMilestone} contractMilestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractMilestone: async (contractId: number, contractMilestone: ContractMilestone, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('createContractMilestone', 'contractId', contractId)
            // verify required parameter 'contractMilestone' is not null or undefined
            assertParamExists('createContractMilestone', 'contractMilestone', contractMilestone)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractMilestone, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new contract subscription
         * @summary Create Contract Subscription
         * @param {number} contractId 
         * @param {ContractSubscription} contractSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractSubscription: async (contractId: number, contractSubscription: ContractSubscription, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('createContractSubscription', 'contractId', contractId)
            // verify required parameter 'contractSubscription' is not null or undefined
            assertParamExists('createContractSubscription', 'contractSubscription', contractSubscription)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new product
         * @summary Create Contract Product
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (product?: Product, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new product bundle with products and percentage allocations. Total percentage must equal 100.
         * @summary Create Product Bundle
         * @param {ProductBundle} productBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductBundle: async (productBundle: ProductBundle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productBundle' is not null or undefined
            assertParamExists('createProductBundle', 'productBundle', productBundle)
            const localVarPath = `/rr/api/v1/product-bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new revenue transaction
         * @summary Create Revenue Transaction
         * @param {RevenueTransaction} [revenueTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRevenueTransaction: async (revenueTransaction?: RevenueTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revenueTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of contract bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Bundles
         * @param {number} contractId 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractBundles: async (contractId: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('listContractBundles', 'contractId', contractId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/bundles`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of milestones for a specific contract with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Milestones
         * @param {number} contractId 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractMilestones: async (contractId: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('listContractMilestones', 'contractId', contractId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of contract subscriptions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Subscriptions
         * @param {number} contractId 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractSubscriptions: async (contractId: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('listContractSubscriptions', 'contractId', contractId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of contracts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.          When download=true, triggers an async workflow that generates a ZIP file with         contracts_summary.csv and contracts_detail.csv, uploads to S3, and sends an email         with the download link.         
         * @summary List Contracts
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContracts: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of product bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Product Bundles
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductBundles: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/product-bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Products
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of revenue transactions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Revenue Transactions
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRevenueTransactions: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for contracts by deal_name in a single request.
         * @summary Bulk Search Contracts
         * @param {BulkContractSearch} bulkContractSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBulkSearchCreate: async (bulkContractSearch: BulkContractSearch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkContractSearch' is not null or undefined
            assertParamExists('rrApiV1ContractsBulkSearchCreate', 'bulkContractSearch', bulkContractSearch)
            const localVarPath = `/rr/api/v1/contracts/bulk-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkContractSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesDestroy: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesDestroy', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/bundles/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractBundle} [patchedContractBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesPartialUpdate: async (contractId: number, id: number, patchedContractBundle?: PatchedContractBundle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesPartialUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/bundles/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesRetrieve: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesRetrieve', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/bundles/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractBundle} contractBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesUpdate: async (contractId: number, id: number, contractBundle: ContractBundle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesUpdate', 'id', id)
            // verify required parameter 'contractBundle' is not null or undefined
            assertParamExists('rrApiV1ContractsBundlesUpdate', 'contractBundle', contractBundle)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/bundles/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Contract
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Duplicate Contract
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsDuplicateCreate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsDuplicateCreate', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} milestoneId 
         * @param {PatchedContractProductBundleUpdate} [patchedContractProductBundleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesAllocationsPartialUpdate: async (contractId: number, milestoneId: number, patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesAllocationsPartialUpdate', 'contractId', contractId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesAllocationsPartialUpdate', 'milestoneId', milestoneId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones/{milestone_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"milestone_id"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractProductBundleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {number} contractId 
         * @param {number} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesAllocationsRetrieve: async (contractId: number, milestoneId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesAllocationsRetrieve', 'contractId', contractId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesAllocationsRetrieve', 'milestoneId', milestoneId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones/{milestone_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"milestone_id"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} milestoneId 
         * @param {ContractProductBundleUpdate} contractProductBundleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesAllocationsUpdate: async (contractId: number, milestoneId: number, contractProductBundleUpdate: ContractProductBundleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesAllocationsUpdate', 'contractId', contractId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesAllocationsUpdate', 'milestoneId', milestoneId)
            // verify required parameter 'contractProductBundleUpdate' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesAllocationsUpdate', 'contractProductBundleUpdate', contractProductBundleUpdate)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones/{milestone_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"milestone_id"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractProductBundleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesDestroy: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesDestroy', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractMilestone} [patchedContractMilestone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesPartialUpdate: async (contractId: number, id: number, patchedContractMilestone?: PatchedContractMilestone, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesPartialUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractMilestone, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesRetrieve: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesRetrieve', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractMilestone} contractMilestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesUpdate: async (contractId: number, id: number, contractMilestone: ContractMilestone, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesUpdate', 'id', id)
            // verify required parameter 'contractMilestone' is not null or undefined
            assertParamExists('rrApiV1ContractsMilestonesUpdate', 'contractMilestone', contractMilestone)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/milestones/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractMilestone, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Contract
         * @param {number} id 
         * @param {PatchedContract} [patchedContract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsPartialUpdate: async (id: number, patchedContract?: PatchedContract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Contract
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} subscriptionId 
         * @param {PatchedContractProductBundleUpdate} [patchedContractProductBundleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsAllocationsPartialUpdate: async (contractId: number, subscriptionId: number, patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsAllocationsPartialUpdate', 'contractId', contractId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsAllocationsPartialUpdate', 'subscriptionId', subscriptionId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions/{subscription_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractProductBundleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {number} contractId 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsAllocationsRetrieve: async (contractId: number, subscriptionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsAllocationsRetrieve', 'contractId', contractId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsAllocationsRetrieve', 'subscriptionId', subscriptionId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions/{subscription_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} subscriptionId 
         * @param {ContractProductBundleUpdate} contractProductBundleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsAllocationsUpdate: async (contractId: number, subscriptionId: number, contractProductBundleUpdate: ContractProductBundleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsAllocationsUpdate', 'contractId', contractId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsAllocationsUpdate', 'subscriptionId', subscriptionId)
            // verify required parameter 'contractProductBundleUpdate' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsAllocationsUpdate', 'contractProductBundleUpdate', contractProductBundleUpdate)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions/{subscription_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractProductBundleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsDestroy: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsDestroy', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractSubscription} [patchedContractSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsPartialUpdate: async (contractId: number, id: number, patchedContractSubscription?: PatchedContractSubscription, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsPartialUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsRetrieve: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsRetrieve', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractSubscription} contractSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsUpdate: async (contractId: number, id: number, contractSubscription: ContractSubscription, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsUpdate', 'id', id)
            // verify required parameter 'contractSubscription' is not null or undefined
            assertParamExists('rrApiV1ContractsSubscriptionsUpdate', 'contractSubscription', contractSubscription)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/subscriptions/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminate a contract and optionally void associated invoices.          If the user has permission to terminate contracts and void invoices, both operations         are performed atomically. If the user lacks permission for either operation, a draft         is created instead, and the response indicates which operations were drafted.          Returns 400 if any of the provided void_invoice_ids are invalid (not found, already voided,         has payments, void date is before the invoice date, or in a closed period).
         * @summary Terminate Contract
         * @param {number} id 
         * @param {TerminateContract} terminateContract 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsTerminateCreate: async (id: number, terminateContract: TerminateContract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsTerminateCreate', 'id', id)
            // verify required parameter 'terminateContract' is not null or undefined
            assertParamExists('rrApiV1ContractsTerminateCreate', 'terminateContract', terminateContract)
            const localVarPath = `/rr/api/v1/contracts/{id}/terminate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(terminateContract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Contract
         * @param {number} id 
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUpdate: async (id: number, contract?: Contract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} usageId 
         * @param {PatchedContractProductBundleUpdate} [patchedContractProductBundleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageAllocationsPartialUpdate: async (contractId: number, usageId: number, patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageAllocationsPartialUpdate', 'contractId', contractId)
            // verify required parameter 'usageId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageAllocationsPartialUpdate', 'usageId', usageId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage/{usage_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"usage_id"}}`, encodeURIComponent(String(usageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractProductBundleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {number} contractId 
         * @param {number} usageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageAllocationsRetrieve: async (contractId: number, usageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageAllocationsRetrieve', 'contractId', contractId)
            // verify required parameter 'usageId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageAllocationsRetrieve', 'usageId', usageId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage/{usage_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"usage_id"}}`, encodeURIComponent(String(usageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} usageId 
         * @param {ContractProductBundleUpdate} contractProductBundleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageAllocationsUpdate: async (contractId: number, usageId: number, contractProductBundleUpdate: ContractProductBundleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageAllocationsUpdate', 'contractId', contractId)
            // verify required parameter 'usageId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageAllocationsUpdate', 'usageId', usageId)
            // verify required parameter 'contractProductBundleUpdate' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageAllocationsUpdate', 'contractProductBundleUpdate', contractProductBundleUpdate)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage/{usage_id}/allocations`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"usage_id"}}`, encodeURIComponent(String(usageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractProductBundleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List usage revenue records
         * @summary Create Contract Usage Revenue
         * @param {number} contractId 
         * @param {ContractUsage} contractUsage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageCreate: async (contractId: number, contractUsage: ContractUsage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageCreate', 'contractId', contractId)
            // verify required parameter 'contractUsage' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageCreate', 'contractUsage', contractUsage)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractUsage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Delete Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageDestroy: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageDestroy', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List usage revenue records
         * @summary List Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageList: async (contractId: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageList', 'contractId', contractId)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Partially Update Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractUsage} [patchedContractUsage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsagePartialUpdate: async (contractId: number, id: number, patchedContractUsage?: PatchedContractUsage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsagePartialUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsUsagePartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractUsage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Retrieve Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageRetrieve: async (contractId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageRetrieve', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Update Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractUsage} contractUsage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageUpdate: async (contractId: number, id: number, contractUsage: ContractUsage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageUpdate', 'contractId', contractId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageUpdate', 'id', id)
            // verify required parameter 'contractUsage' is not null or undefined
            assertParamExists('rrApiV1ContractsUsageUpdate', 'contractUsage', contractUsage)
            const localVarPath = `/rr/api/v1/contracts/{contract_id}/usage/{id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractUsage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Contract Customer
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1CustomersDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of contract customers with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Customers
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersList: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Contract Customer
         * @param {number} id 
         * @param {PatchedContractCustomer} [patchedContractCustomer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersPartialUpdate: async (id: number, patchedContractCustomer?: PatchedContractCustomer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1CustomersPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedContractCustomer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Contract Customer
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1CustomersRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Contract Customer
         * @param {number} id 
         * @param {ContractCustomer} contractCustomer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersUpdate: async (id: number, contractCustomer: ContractCustomer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1CustomersUpdate', 'id', id)
            // verify required parameter 'contractCustomer' is not null or undefined
            assertParamExists('rrApiV1CustomersUpdate', 'contractCustomer', contractCustomer)
            const localVarPath = `/rr/api/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractCustomer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Product Bundle
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductBundlesDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/product-bundles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Product Bundle
         * @param {number} id 
         * @param {PatchedProductBundle} [patchedProductBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesPartialUpdate: async (id: number, patchedProductBundle?: PatchedProductBundle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductBundlesPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/product-bundles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProductBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Product Bundle
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductBundlesRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/product-bundles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Product Bundle
         * @param {number} id 
         * @param {ProductBundle} productBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesUpdate: async (id: number, productBundle: ProductBundle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductBundlesUpdate', 'id', id)
            // verify required parameter 'productBundle' is not null or undefined
            assertParamExists('rrApiV1ProductBundlesUpdate', 'productBundle', productBundle)
            const localVarPath = `/rr/api/v1/product-bundles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Product
         * @param {number} id 
         * @param {PatchedProduct} [patchedProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductPartialUpdate: async (id: number, patchedProduct?: PatchedProduct, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Product
         * @param {number} id 
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductUpdate: async (id: number, product?: Product, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1ProductUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Revenue Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1TransactionsDestroy', 'id', id)
            const localVarPath = `/rr/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Revenue Transaction
         * @param {number} id 
         * @param {PatchedRevenueTransaction} [patchedRevenueTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsPartialUpdate: async (id: number, patchedRevenueTransaction?: PatchedRevenueTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1TransactionsPartialUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRevenueTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Revenue Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1TransactionsRetrieve', 'id', id)
            const localVarPath = `/rr/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Revenue Transaction
         * @param {number} id 
         * @param {RevenueTransaction} [revenueTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsUpdate: async (id: number, revenueTransaction?: RevenueTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rrApiV1TransactionsUpdate', 'id', id)
            const localVarPath = `/rr/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revenueTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevenueRecognitionApi - functional programming interface
 */
export const RevenueRecognitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RevenueRecognitionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new contract
         * @summary Create Contract
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(contract?: Contract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(contract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.createContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new contract bundle
         * @summary Create Contract Bundle
         * @param {number} contractId 
         * @param {ContractBundle} contractBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractBundle(contractId: number, contractBundle: ContractBundle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractBundle(contractId, contractBundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.createContractBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new milestone for a contract. This will automatically create an associated revenue transaction.
         * @summary Create Contract Milestone
         * @param {number} contractId 
         * @param {ContractMilestone} contractMilestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractMilestone(contractId: number, contractMilestone: ContractMilestone, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractMilestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractMilestone(contractId, contractMilestone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.createContractMilestone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new contract subscription
         * @summary Create Contract Subscription
         * @param {number} contractId 
         * @param {ContractSubscription} contractSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractSubscription(contractId: number, contractSubscription: ContractSubscription, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractSubscription(contractId, contractSubscription, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.createContractSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new product
         * @summary Create Contract Product
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(product?: Product, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new product bundle with products and percentage allocations. Total percentage must equal 100.
         * @summary Create Product Bundle
         * @param {ProductBundle} productBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductBundle(productBundle: ProductBundle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductBundle(productBundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.createProductBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new revenue transaction
         * @summary Create Revenue Transaction
         * @param {RevenueTransaction} [revenueTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRevenueTransaction(revenueTransaction?: RevenueTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevenueTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRevenueTransaction(revenueTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.createRevenueTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of contract bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Bundles
         * @param {number} contractId 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractBundles(contractId: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractBundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractBundles(contractId, includeDeleted, lastModifiedAtGte, lastModifiedAtLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.listContractBundles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of milestones for a specific contract with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Milestones
         * @param {number} contractId 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractMilestones(contractId: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContractMilestoneList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractMilestones(contractId, includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.listContractMilestones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of contract subscriptions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Subscriptions
         * @param {number} contractId 
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractSubscriptions(contractId: number, includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractSubscription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractSubscriptions(contractId, includeDeleted, lastModifiedAtGte, lastModifiedAtLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.listContractSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of contracts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.          When download=true, triggers an async workflow that generates a ZIP file with         contracts_summary.csv and contracts_detail.csv, uploads to S3, and sends an email         with the download link.         
         * @summary List Contracts
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContracts(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContractList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContracts(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.listContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of product bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Product Bundles
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductBundles(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductBundleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductBundles(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.listProductBundles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Products
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.listProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of revenue transactions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Revenue Transactions
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRevenueTransactions(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRevenueTransactionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRevenueTransactions(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.listRevenueTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for contracts by deal_name in a single request.
         * @summary Bulk Search Contracts
         * @param {BulkContractSearch} bulkContractSearch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsBulkSearchCreate(bulkContractSearch: BulkContractSearch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsBulkSearchCreate(bulkContractSearch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsBulkSearchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsBundlesDestroy(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsBundlesDestroy(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsBundlesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractBundle} [patchedContractBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsBundlesPartialUpdate(contractId: number, id: number, patchedContractBundle?: PatchedContractBundle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsBundlesPartialUpdate(contractId, id, patchedContractBundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsBundlesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsBundlesRetrieve(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsBundlesRetrieve(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsBundlesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Contract Bundle
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractBundle} contractBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsBundlesUpdate(contractId: number, id: number, contractBundle: ContractBundle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsBundlesUpdate(contractId, id, contractBundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsBundlesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Contract
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Duplicate Contract
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsDuplicateCreate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDuplicateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsDuplicateCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsDuplicateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} milestoneId 
         * @param {PatchedContractProductBundleUpdate} [patchedContractProductBundleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsMilestonesAllocationsPartialUpdate(contractId: number, milestoneId: number, patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsMilestonesAllocationsPartialUpdate(contractId, milestoneId, patchedContractProductBundleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsMilestonesAllocationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {number} contractId 
         * @param {number} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsMilestonesAllocationsRetrieve(contractId: number, milestoneId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsMilestonesAllocationsRetrieve(contractId, milestoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsMilestonesAllocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} milestoneId 
         * @param {ContractProductBundleUpdate} contractProductBundleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsMilestonesAllocationsUpdate(contractId: number, milestoneId: number, contractProductBundleUpdate: ContractProductBundleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsMilestonesAllocationsUpdate(contractId, milestoneId, contractProductBundleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsMilestonesAllocationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsMilestonesDestroy(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsMilestonesDestroy(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsMilestonesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractMilestone} [patchedContractMilestone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsMilestonesPartialUpdate(contractId: number, id: number, patchedContractMilestone?: PatchedContractMilestone, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractMilestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsMilestonesPartialUpdate(contractId, id, patchedContractMilestone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsMilestonesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsMilestonesRetrieve(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractMilestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsMilestonesRetrieve(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsMilestonesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Contract Milestone
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractMilestone} contractMilestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsMilestonesUpdate(contractId: number, id: number, contractMilestone: ContractMilestone, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractMilestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsMilestonesUpdate(contractId, id, contractMilestone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsMilestonesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Contract
         * @param {number} id 
         * @param {PatchedContract} [patchedContract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsPartialUpdate(id: number, patchedContract?: PatchedContract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsPartialUpdate(id, patchedContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Contract
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} subscriptionId 
         * @param {PatchedContractProductBundleUpdate} [patchedContractProductBundleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsSubscriptionsAllocationsPartialUpdate(contractId: number, subscriptionId: number, patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsSubscriptionsAllocationsPartialUpdate(contractId, subscriptionId, patchedContractProductBundleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsSubscriptionsAllocationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {number} contractId 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsSubscriptionsAllocationsRetrieve(contractId: number, subscriptionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsSubscriptionsAllocationsRetrieve(contractId, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsSubscriptionsAllocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} subscriptionId 
         * @param {ContractProductBundleUpdate} contractProductBundleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsSubscriptionsAllocationsUpdate(contractId: number, subscriptionId: number, contractProductBundleUpdate: ContractProductBundleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsSubscriptionsAllocationsUpdate(contractId, subscriptionId, contractProductBundleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsSubscriptionsAllocationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsSubscriptionsDestroy(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsSubscriptionsDestroy(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsSubscriptionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractSubscription} [patchedContractSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsSubscriptionsPartialUpdate(contractId: number, id: number, patchedContractSubscription?: PatchedContractSubscription, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsSubscriptionsPartialUpdate(contractId, id, patchedContractSubscription, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsSubscriptionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsSubscriptionsRetrieve(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsSubscriptionsRetrieve(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsSubscriptionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Contract Subscription
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractSubscription} contractSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsSubscriptionsUpdate(contractId: number, id: number, contractSubscription: ContractSubscription, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsSubscriptionsUpdate(contractId, id, contractSubscription, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsSubscriptionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminate a contract and optionally void associated invoices.          If the user has permission to terminate contracts and void invoices, both operations         are performed atomically. If the user lacks permission for either operation, a draft         is created instead, and the response indicates which operations were drafted.          Returns 400 if any of the provided void_invoice_ids are invalid (not found, already voided,         has payments, void date is before the invoice date, or in a closed period).
         * @summary Terminate Contract
         * @param {number} id 
         * @param {TerminateContract} terminateContract 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsTerminateCreate(id: number, terminateContract: TerminateContract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminateContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsTerminateCreate(id, terminateContract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsTerminateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Contract
         * @param {number} id 
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUpdate(id: number, contract?: Contract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUpdate(id, contract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} usageId 
         * @param {PatchedContractProductBundleUpdate} [patchedContractProductBundleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageAllocationsPartialUpdate(contractId: number, usageId: number, patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageAllocationsPartialUpdate(contractId, usageId, patchedContractProductBundleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageAllocationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {number} contractId 
         * @param {number} usageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageAllocationsRetrieve(contractId: number, usageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageAllocationsRetrieve(contractId, usageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageAllocationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {number} contractId 
         * @param {number} usageId 
         * @param {ContractProductBundleUpdate} contractProductBundleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageAllocationsUpdate(contractId: number, usageId: number, contractProductBundleUpdate: ContractProductBundleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageAllocationsUpdate(contractId, usageId, contractProductBundleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageAllocationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List usage revenue records
         * @summary Create Contract Usage Revenue
         * @param {number} contractId 
         * @param {ContractUsage} contractUsage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageCreate(contractId: number, contractUsage: ContractUsage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageCreate(contractId, contractUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Delete Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageDestroy(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageDestroy(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List usage revenue records
         * @summary List Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageList(contractId: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContractUsageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageList(contractId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Partially Update Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {PatchedContractUsage} [patchedContractUsage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsagePartialUpdate(contractId: number, id: number, patchedContractUsage?: PatchedContractUsage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsagePartialUpdate(contractId, id, patchedContractUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsagePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Retrieve Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageRetrieve(contractId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageRetrieve(contractId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Update Contract Usage Revenue
         * @param {number} contractId 
         * @param {number} id 
         * @param {ContractUsage} contractUsage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ContractsUsageUpdate(contractId: number, id: number, contractUsage: ContractUsage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ContractsUsageUpdate(contractId, id, contractUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ContractsUsageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Contract Customer
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1CustomersDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1CustomersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1CustomersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of contract customers with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Customers
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1CustomersList(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedContractCustomerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1CustomersList(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1CustomersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Contract Customer
         * @param {number} id 
         * @param {PatchedContractCustomer} [patchedContractCustomer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1CustomersPartialUpdate(id: number, patchedContractCustomer?: PatchedContractCustomer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1CustomersPartialUpdate(id, patchedContractCustomer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1CustomersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Contract Customer
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1CustomersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1CustomersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1CustomersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Contract Customer
         * @param {number} id 
         * @param {ContractCustomer} contractCustomer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1CustomersUpdate(id: number, contractCustomer: ContractCustomer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1CustomersUpdate(id, contractCustomer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1CustomersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Product Bundle
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductBundlesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductBundlesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductBundlesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Product Bundle
         * @param {number} id 
         * @param {PatchedProductBundle} [patchedProductBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductBundlesPartialUpdate(id: number, patchedProductBundle?: PatchedProductBundle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductBundlesPartialUpdate(id, patchedProductBundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductBundlesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Product Bundle
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductBundlesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductBundlesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductBundlesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Product Bundle
         * @param {number} id 
         * @param {ProductBundle} productBundle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductBundlesUpdate(id: number, productBundle: ProductBundle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductBundlesUpdate(id, productBundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductBundlesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Product
         * @param {number} id 
         * @param {PatchedProduct} [patchedProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductPartialUpdate(id: number, patchedProduct?: PatchedProduct, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductPartialUpdate(id, patchedProduct, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Product
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Product
         * @param {number} id 
         * @param {Product} [product] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1ProductUpdate(id: number, product?: Product, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1ProductUpdate(id, product, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1ProductUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Revenue Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1TransactionsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1TransactionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1TransactionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Revenue Transaction
         * @param {number} id 
         * @param {PatchedRevenueTransaction} [patchedRevenueTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1TransactionsPartialUpdate(id: number, patchedRevenueTransaction?: PatchedRevenueTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevenueTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1TransactionsPartialUpdate(id, patchedRevenueTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1TransactionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Revenue Transaction
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1TransactionsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevenueTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1TransactionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1TransactionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Revenue Transaction
         * @param {number} id 
         * @param {RevenueTransaction} [revenueTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrApiV1TransactionsUpdate(id: number, revenueTransaction?: RevenueTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevenueTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrApiV1TransactionsUpdate(id, revenueTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueRecognitionApi.rrApiV1TransactionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RevenueRecognitionApi - factory interface
 */
export const RevenueRecognitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RevenueRecognitionApiFp(configuration)
    return {
        /**
         * Create a new contract
         * @summary Create Contract
         * @param {RevenueRecognitionApiCreateContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract(requestParameters: RevenueRecognitionApiCreateContractRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.createContract(requestParameters.contract, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new contract bundle
         * @summary Create Contract Bundle
         * @param {RevenueRecognitionApiCreateContractBundleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractBundle(requestParameters: RevenueRecognitionApiCreateContractBundleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractBundle> {
            return localVarFp.createContractBundle(requestParameters.contractId, requestParameters.contractBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new milestone for a contract. This will automatically create an associated revenue transaction.
         * @summary Create Contract Milestone
         * @param {RevenueRecognitionApiCreateContractMilestoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractMilestone(requestParameters: RevenueRecognitionApiCreateContractMilestoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractMilestone> {
            return localVarFp.createContractMilestone(requestParameters.contractId, requestParameters.contractMilestone, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new contract subscription
         * @summary Create Contract Subscription
         * @param {RevenueRecognitionApiCreateContractSubscriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractSubscription(requestParameters: RevenueRecognitionApiCreateContractSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractSubscription> {
            return localVarFp.createContractSubscription(requestParameters.contractId, requestParameters.contractSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new product
         * @summary Create Contract Product
         * @param {RevenueRecognitionApiCreateProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(requestParameters: RevenueRecognitionApiCreateProductRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.createProduct(requestParameters.product, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new product bundle with products and percentage allocations. Total percentage must equal 100.
         * @summary Create Product Bundle
         * @param {RevenueRecognitionApiCreateProductBundleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductBundle(requestParameters: RevenueRecognitionApiCreateProductBundleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductBundle> {
            return localVarFp.createProductBundle(requestParameters.productBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new revenue transaction
         * @summary Create Revenue Transaction
         * @param {RevenueRecognitionApiCreateRevenueTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRevenueTransaction(requestParameters: RevenueRecognitionApiCreateRevenueTransactionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RevenueTransaction> {
            return localVarFp.createRevenueTransaction(requestParameters.revenueTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of contract bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Bundles
         * @param {RevenueRecognitionApiListContractBundlesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractBundles(requestParameters: RevenueRecognitionApiListContractBundlesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ContractBundle>> {
            return localVarFp.listContractBundles(requestParameters.contractId, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of milestones for a specific contract with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Milestones
         * @param {RevenueRecognitionApiListContractMilestonesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractMilestones(requestParameters: RevenueRecognitionApiListContractMilestonesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedContractMilestoneList> {
            return localVarFp.listContractMilestones(requestParameters.contractId, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of contract subscriptions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Subscriptions
         * @param {RevenueRecognitionApiListContractSubscriptionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractSubscriptions(requestParameters: RevenueRecognitionApiListContractSubscriptionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ContractSubscription>> {
            return localVarFp.listContractSubscriptions(requestParameters.contractId, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of contracts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.          When download=true, triggers an async workflow that generates a ZIP file with         contracts_summary.csv and contracts_detail.csv, uploads to S3, and sends an email         with the download link.         
         * @summary List Contracts
         * @param {RevenueRecognitionApiListContractsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContracts(requestParameters: RevenueRecognitionApiListContractsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedContractList> {
            return localVarFp.listContracts(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of product bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Product Bundles
         * @param {RevenueRecognitionApiListProductBundlesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductBundles(requestParameters: RevenueRecognitionApiListProductBundlesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProductBundleList> {
            return localVarFp.listProductBundles(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Products
         * @param {RevenueRecognitionApiListProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(requestParameters: RevenueRecognitionApiListProductsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedProductList> {
            return localVarFp.listProducts(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of revenue transactions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Revenue Transactions
         * @param {RevenueRecognitionApiListRevenueTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRevenueTransactions(requestParameters: RevenueRecognitionApiListRevenueTransactionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedRevenueTransactionList> {
            return localVarFp.listRevenueTransactions(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for contracts by deal_name in a single request.
         * @summary Bulk Search Contracts
         * @param {RevenueRecognitionApiRrApiV1ContractsBulkSearchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBulkSearchCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsBulkSearchCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Contract>> {
            return localVarFp.rrApiV1ContractsBulkSearchCreate(requestParameters.bulkContractSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Contract Bundle
         * @param {RevenueRecognitionApiRrApiV1ContractsBundlesDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ContractsBundlesDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Contract Bundle
         * @param {RevenueRecognitionApiRrApiV1ContractsBundlesPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractBundle> {
            return localVarFp.rrApiV1ContractsBundlesPartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Contract Bundle
         * @param {RevenueRecognitionApiRrApiV1ContractsBundlesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractBundle> {
            return localVarFp.rrApiV1ContractsBundlesRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Contract Bundle
         * @param {RevenueRecognitionApiRrApiV1ContractsBundlesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsBundlesUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractBundle> {
            return localVarFp.rrApiV1ContractsBundlesUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Contract
         * @param {RevenueRecognitionApiRrApiV1ContractsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ContractsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Duplicate Contract
         * @param {RevenueRecognitionApiRrApiV1ContractsDuplicateCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsDuplicateCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsDuplicateCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractDuplicateResponse> {
            return localVarFp.rrApiV1ContractsDuplicateCreate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesAllocationsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsMilestonesAllocationsPartialUpdate(requestParameters.contractId, requestParameters.milestoneId, requestParameters.patchedContractProductBundleUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesAllocationsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsMilestonesAllocationsRetrieve(requestParameters.contractId, requestParameters.milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesAllocationsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsMilestonesAllocationsUpdate(requestParameters.contractId, requestParameters.milestoneId, requestParameters.contractProductBundleUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Contract Milestone
         * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ContractsMilestonesDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Contract Milestone
         * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractMilestone> {
            return localVarFp.rrApiV1ContractsMilestonesPartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractMilestone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Contract Milestone
         * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractMilestone> {
            return localVarFp.rrApiV1ContractsMilestonesRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Contract Milestone
         * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsMilestonesUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractMilestone> {
            return localVarFp.rrApiV1ContractsMilestonesUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractMilestone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Contract
         * @param {RevenueRecognitionApiRrApiV1ContractsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.rrApiV1ContractsPartialUpdate(requestParameters.id, requestParameters.patchedContract, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Contract
         * @param {RevenueRecognitionApiRrApiV1ContractsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.rrApiV1ContractsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsAllocationsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsSubscriptionsAllocationsPartialUpdate(requestParameters.contractId, requestParameters.subscriptionId, requestParameters.patchedContractProductBundleUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsAllocationsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsSubscriptionsAllocationsRetrieve(requestParameters.contractId, requestParameters.subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsAllocationsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsSubscriptionsAllocationsUpdate(requestParameters.contractId, requestParameters.subscriptionId, requestParameters.contractProductBundleUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Contract Subscription
         * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ContractsSubscriptionsDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Contract Subscription
         * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractSubscription> {
            return localVarFp.rrApiV1ContractsSubscriptionsPartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Contract Subscription
         * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractSubscription> {
            return localVarFp.rrApiV1ContractsSubscriptionsRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Contract Subscription
         * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsSubscriptionsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractSubscription> {
            return localVarFp.rrApiV1ContractsSubscriptionsUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminate a contract and optionally void associated invoices.          If the user has permission to terminate contracts and void invoices, both operations         are performed atomically. If the user lacks permission for either operation, a draft         is created instead, and the response indicates which operations were drafted.          Returns 400 if any of the provided void_invoice_ids are invalid (not found, already voided,         has payments, void date is before the invoice date, or in a closed period).
         * @summary Terminate Contract
         * @param {RevenueRecognitionApiRrApiV1ContractsTerminateCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsTerminateCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsTerminateCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TerminateContractResponse> {
            return localVarFp.rrApiV1ContractsTerminateCreate(requestParameters.id, requestParameters.terminateContract, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Contract
         * @param {RevenueRecognitionApiRrApiV1ContractsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.rrApiV1ContractsUpdate(requestParameters.id, requestParameters.contract, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update bundle allocations. Same behavior as PUT.
         * @summary Partial Update Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageAllocationsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageAllocationsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsUsageAllocationsPartialUpdate(requestParameters.contractId, requestParameters.usageId, requestParameters.patchedContractProductBundleUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
         * @summary Get Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageAllocationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageAllocationsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageAllocationsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsUsageAllocationsRetrieve(requestParameters.contractId, requestParameters.usageId, options).then((request) => request(axios, basePath));
        },
        /**
         *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
         * @summary Update Bundle Allocations
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageAllocationsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageAllocationsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageAllocationsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractProductBundle> {
            return localVarFp.rrApiV1ContractsUsageAllocationsUpdate(requestParameters.contractId, requestParameters.usageId, requestParameters.contractProductBundleUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * List usage revenue records
         * @summary Create Contract Usage Revenue
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractUsage> {
            return localVarFp.rrApiV1ContractsUsageCreate(requestParameters.contractId, requestParameters.contractUsage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Delete Contract Usage Revenue
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ContractsUsageDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List usage revenue records
         * @summary List Contract Usage Revenue
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageList(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedContractUsageList> {
            return localVarFp.rrApiV1ContractsUsageList(requestParameters.contractId, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Partially Update Contract Usage Revenue
         * @param {RevenueRecognitionApiRrApiV1ContractsUsagePartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsagePartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsagePartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractUsage> {
            return localVarFp.rrApiV1ContractsUsagePartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractUsage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Retrieve Contract Usage Revenue
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractUsage> {
            return localVarFp.rrApiV1ContractsUsageRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete contract usage revenue records
         * @summary Update Contract Usage Revenue
         * @param {RevenueRecognitionApiRrApiV1ContractsUsageUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ContractsUsageUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractUsage> {
            return localVarFp.rrApiV1ContractsUsageUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractUsage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Contract Customer
         * @param {RevenueRecognitionApiRrApiV1CustomersDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersDestroy(requestParameters: RevenueRecognitionApiRrApiV1CustomersDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1CustomersDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of contract customers with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Contract Customers
         * @param {RevenueRecognitionApiRrApiV1CustomersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersList(requestParameters: RevenueRecognitionApiRrApiV1CustomersListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedContractCustomerList> {
            return localVarFp.rrApiV1CustomersList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Contract Customer
         * @param {RevenueRecognitionApiRrApiV1CustomersPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1CustomersPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractCustomer> {
            return localVarFp.rrApiV1CustomersPartialUpdate(requestParameters.id, requestParameters.patchedContractCustomer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Contract Customer
         * @param {RevenueRecognitionApiRrApiV1CustomersRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersRetrieve(requestParameters: RevenueRecognitionApiRrApiV1CustomersRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractCustomer> {
            return localVarFp.rrApiV1CustomersRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Contract Customer
         * @param {RevenueRecognitionApiRrApiV1CustomersUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1CustomersUpdate(requestParameters: RevenueRecognitionApiRrApiV1CustomersUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractCustomer> {
            return localVarFp.rrApiV1CustomersUpdate(requestParameters.id, requestParameters.contractCustomer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Product Bundle
         * @param {RevenueRecognitionApiRrApiV1ProductBundlesDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesDestroy(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ProductBundlesDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Product Bundle
         * @param {RevenueRecognitionApiRrApiV1ProductBundlesPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductBundle> {
            return localVarFp.rrApiV1ProductBundlesPartialUpdate(requestParameters.id, requestParameters.patchedProductBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Product Bundle
         * @param {RevenueRecognitionApiRrApiV1ProductBundlesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductBundle> {
            return localVarFp.rrApiV1ProductBundlesRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Product Bundle
         * @param {RevenueRecognitionApiRrApiV1ProductBundlesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductBundlesUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductBundle> {
            return localVarFp.rrApiV1ProductBundlesUpdate(requestParameters.id, requestParameters.productBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Product
         * @param {RevenueRecognitionApiRrApiV1ProductDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductDestroy(requestParameters: RevenueRecognitionApiRrApiV1ProductDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1ProductDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Product
         * @param {RevenueRecognitionApiRrApiV1ProductPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.rrApiV1ProductPartialUpdate(requestParameters.id, requestParameters.patchedProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Product
         * @param {RevenueRecognitionApiRrApiV1ProductRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ProductRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.rrApiV1ProductRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Product
         * @param {RevenueRecognitionApiRrApiV1ProductUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1ProductUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.rrApiV1ProductUpdate(requestParameters.id, requestParameters.product, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Revenue Transaction
         * @param {RevenueRecognitionApiRrApiV1TransactionsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsDestroy(requestParameters: RevenueRecognitionApiRrApiV1TransactionsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rrApiV1TransactionsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Revenue Transaction
         * @param {RevenueRecognitionApiRrApiV1TransactionsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1TransactionsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RevenueTransaction> {
            return localVarFp.rrApiV1TransactionsPartialUpdate(requestParameters.id, requestParameters.patchedRevenueTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Revenue Transaction
         * @param {RevenueRecognitionApiRrApiV1TransactionsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1TransactionsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<RevenueTransaction> {
            return localVarFp.rrApiV1TransactionsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Revenue Transaction
         * @param {RevenueRecognitionApiRrApiV1TransactionsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrApiV1TransactionsUpdate(requestParameters: RevenueRecognitionApiRrApiV1TransactionsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RevenueTransaction> {
            return localVarFp.rrApiV1TransactionsUpdate(requestParameters.id, requestParameters.revenueTransaction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createContract operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiCreateContractRequest {
    readonly contract?: Contract
}

/**
 * Request parameters for createContractBundle operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiCreateContractBundleRequest {
    readonly contractId: number

    readonly contractBundle: ContractBundle
}

/**
 * Request parameters for createContractMilestone operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiCreateContractMilestoneRequest {
    readonly contractId: number

    readonly contractMilestone: ContractMilestone
}

/**
 * Request parameters for createContractSubscription operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiCreateContractSubscriptionRequest {
    readonly contractId: number

    readonly contractSubscription: ContractSubscription
}

/**
 * Request parameters for createProduct operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiCreateProductRequest {
    readonly product?: Product
}

/**
 * Request parameters for createProductBundle operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiCreateProductBundleRequest {
    readonly productBundle: ProductBundle
}

/**
 * Request parameters for createRevenueTransaction operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiCreateRevenueTransactionRequest {
    readonly revenueTransaction?: RevenueTransaction
}

/**
 * Request parameters for listContractBundles operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiListContractBundlesRequest {
    readonly contractId: number

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string
}

/**
 * Request parameters for listContractMilestones operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiListContractMilestonesRequest {
    readonly contractId: number

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for listContractSubscriptions operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiListContractSubscriptionsRequest {
    readonly contractId: number

    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string
}

/**
 * Request parameters for listContracts operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiListContractsRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for listProductBundles operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiListProductBundlesRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for listProducts operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiListProductsRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for listRevenueTransactions operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiListRevenueTransactionsRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for rrApiV1ContractsBulkSearchCreate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsBulkSearchCreateRequest {
    readonly bulkContractSearch: BulkContractSearch
}

/**
 * Request parameters for rrApiV1ContractsBundlesDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsBundlesDestroyRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsBundlesPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsBundlesPartialUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly patchedContractBundle?: PatchedContractBundle
}

/**
 * Request parameters for rrApiV1ContractsBundlesRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsBundlesRetrieveRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsBundlesUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsBundlesUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly contractBundle: ContractBundle
}

/**
 * Request parameters for rrApiV1ContractsDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsDuplicateCreate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsDuplicateCreateRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsMilestonesAllocationsPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsPartialUpdateRequest {
    readonly contractId: number

    readonly milestoneId: number

    readonly patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate
}

/**
 * Request parameters for rrApiV1ContractsMilestonesAllocationsRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsRetrieveRequest {
    readonly contractId: number

    readonly milestoneId: number
}

/**
 * Request parameters for rrApiV1ContractsMilestonesAllocationsUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsUpdateRequest {
    readonly contractId: number

    readonly milestoneId: number

    readonly contractProductBundleUpdate: ContractProductBundleUpdate
}

/**
 * Request parameters for rrApiV1ContractsMilestonesDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsMilestonesDestroyRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsMilestonesPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsMilestonesPartialUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly patchedContractMilestone?: PatchedContractMilestone
}

/**
 * Request parameters for rrApiV1ContractsMilestonesRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsMilestonesRetrieveRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsMilestonesUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsMilestonesUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly contractMilestone: ContractMilestone
}

/**
 * Request parameters for rrApiV1ContractsPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsPartialUpdateRequest {
    readonly id: number

    readonly patchedContract?: PatchedContract
}

/**
 * Request parameters for rrApiV1ContractsRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsSubscriptionsAllocationsPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsPartialUpdateRequest {
    readonly contractId: number

    readonly subscriptionId: number

    readonly patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate
}

/**
 * Request parameters for rrApiV1ContractsSubscriptionsAllocationsRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsRetrieveRequest {
    readonly contractId: number

    readonly subscriptionId: number
}

/**
 * Request parameters for rrApiV1ContractsSubscriptionsAllocationsUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsUpdateRequest {
    readonly contractId: number

    readonly subscriptionId: number

    readonly contractProductBundleUpdate: ContractProductBundleUpdate
}

/**
 * Request parameters for rrApiV1ContractsSubscriptionsDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsSubscriptionsDestroyRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsSubscriptionsPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsSubscriptionsPartialUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly patchedContractSubscription?: PatchedContractSubscription
}

/**
 * Request parameters for rrApiV1ContractsSubscriptionsRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsSubscriptionsRetrieveRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsSubscriptionsUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsSubscriptionsUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly contractSubscription: ContractSubscription
}

/**
 * Request parameters for rrApiV1ContractsTerminateCreate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsTerminateCreateRequest {
    readonly id: number

    readonly terminateContract: TerminateContract
}

/**
 * Request parameters for rrApiV1ContractsUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUpdateRequest {
    readonly id: number

    readonly contract?: Contract
}

/**
 * Request parameters for rrApiV1ContractsUsageAllocationsPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageAllocationsPartialUpdateRequest {
    readonly contractId: number

    readonly usageId: number

    readonly patchedContractProductBundleUpdate?: PatchedContractProductBundleUpdate
}

/**
 * Request parameters for rrApiV1ContractsUsageAllocationsRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageAllocationsRetrieveRequest {
    readonly contractId: number

    readonly usageId: number
}

/**
 * Request parameters for rrApiV1ContractsUsageAllocationsUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageAllocationsUpdateRequest {
    readonly contractId: number

    readonly usageId: number

    readonly contractProductBundleUpdate: ContractProductBundleUpdate
}

/**
 * Request parameters for rrApiV1ContractsUsageCreate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageCreateRequest {
    readonly contractId: number

    readonly contractUsage: ContractUsage
}

/**
 * Request parameters for rrApiV1ContractsUsageDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageDestroyRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsUsageList operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageListRequest {
    readonly contractId: number

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for rrApiV1ContractsUsagePartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsagePartialUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly patchedContractUsage?: PatchedContractUsage
}

/**
 * Request parameters for rrApiV1ContractsUsageRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageRetrieveRequest {
    readonly contractId: number

    readonly id: number
}

/**
 * Request parameters for rrApiV1ContractsUsageUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ContractsUsageUpdateRequest {
    readonly contractId: number

    readonly id: number

    readonly contractUsage: ContractUsage
}

/**
 * Request parameters for rrApiV1CustomersDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1CustomersDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1CustomersList operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1CustomersListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for rrApiV1CustomersPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1CustomersPartialUpdateRequest {
    readonly id: number

    readonly patchedContractCustomer?: PatchedContractCustomer
}

/**
 * Request parameters for rrApiV1CustomersRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1CustomersRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1CustomersUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1CustomersUpdateRequest {
    readonly id: number

    readonly contractCustomer: ContractCustomer
}

/**
 * Request parameters for rrApiV1ProductBundlesDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductBundlesDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ProductBundlesPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductBundlesPartialUpdateRequest {
    readonly id: number

    readonly patchedProductBundle?: PatchedProductBundle
}

/**
 * Request parameters for rrApiV1ProductBundlesRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductBundlesRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ProductBundlesUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductBundlesUpdateRequest {
    readonly id: number

    readonly productBundle: ProductBundle
}

/**
 * Request parameters for rrApiV1ProductDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ProductPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductPartialUpdateRequest {
    readonly id: number

    readonly patchedProduct?: PatchedProduct
}

/**
 * Request parameters for rrApiV1ProductRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1ProductUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1ProductUpdateRequest {
    readonly id: number

    readonly product?: Product
}

/**
 * Request parameters for rrApiV1TransactionsDestroy operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1TransactionsDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1TransactionsPartialUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1TransactionsPartialUpdateRequest {
    readonly id: number

    readonly patchedRevenueTransaction?: PatchedRevenueTransaction
}

/**
 * Request parameters for rrApiV1TransactionsRetrieve operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1TransactionsRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for rrApiV1TransactionsUpdate operation in RevenueRecognitionApi.
 */
export interface RevenueRecognitionApiRrApiV1TransactionsUpdateRequest {
    readonly id: number

    readonly revenueTransaction?: RevenueTransaction
}

/**
 * RevenueRecognitionApi - object-oriented interface
 */
export class RevenueRecognitionApi extends BaseAPI {
    /**
     * Create a new contract
     * @summary Create Contract
     * @param {RevenueRecognitionApiCreateContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createContract(requestParameters: RevenueRecognitionApiCreateContractRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).createContract(requestParameters.contract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new contract bundle
     * @summary Create Contract Bundle
     * @param {RevenueRecognitionApiCreateContractBundleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createContractBundle(requestParameters: RevenueRecognitionApiCreateContractBundleRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).createContractBundle(requestParameters.contractId, requestParameters.contractBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new milestone for a contract. This will automatically create an associated revenue transaction.
     * @summary Create Contract Milestone
     * @param {RevenueRecognitionApiCreateContractMilestoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createContractMilestone(requestParameters: RevenueRecognitionApiCreateContractMilestoneRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).createContractMilestone(requestParameters.contractId, requestParameters.contractMilestone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new contract subscription
     * @summary Create Contract Subscription
     * @param {RevenueRecognitionApiCreateContractSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createContractSubscription(requestParameters: RevenueRecognitionApiCreateContractSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).createContractSubscription(requestParameters.contractId, requestParameters.contractSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new product
     * @summary Create Contract Product
     * @param {RevenueRecognitionApiCreateProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProduct(requestParameters: RevenueRecognitionApiCreateProductRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).createProduct(requestParameters.product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new product bundle with products and percentage allocations. Total percentage must equal 100.
     * @summary Create Product Bundle
     * @param {RevenueRecognitionApiCreateProductBundleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProductBundle(requestParameters: RevenueRecognitionApiCreateProductBundleRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).createProductBundle(requestParameters.productBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new revenue transaction
     * @summary Create Revenue Transaction
     * @param {RevenueRecognitionApiCreateRevenueTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRevenueTransaction(requestParameters: RevenueRecognitionApiCreateRevenueTransactionRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).createRevenueTransaction(requestParameters.revenueTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of contract bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Contract Bundles
     * @param {RevenueRecognitionApiListContractBundlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listContractBundles(requestParameters: RevenueRecognitionApiListContractBundlesRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).listContractBundles(requestParameters.contractId, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of milestones for a specific contract with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Contract Milestones
     * @param {RevenueRecognitionApiListContractMilestonesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listContractMilestones(requestParameters: RevenueRecognitionApiListContractMilestonesRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).listContractMilestones(requestParameters.contractId, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of contract subscriptions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Contract Subscriptions
     * @param {RevenueRecognitionApiListContractSubscriptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listContractSubscriptions(requestParameters: RevenueRecognitionApiListContractSubscriptionsRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).listContractSubscriptions(requestParameters.contractId, requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of contracts with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.          When download=true, triggers an async workflow that generates a ZIP file with         contracts_summary.csv and contracts_detail.csv, uploads to S3, and sends an email         with the download link.         
     * @summary List Contracts
     * @param {RevenueRecognitionApiListContractsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listContracts(requestParameters: RevenueRecognitionApiListContractsRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).listContracts(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of product bundles with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Product Bundles
     * @param {RevenueRecognitionApiListProductBundlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProductBundles(requestParameters: RevenueRecognitionApiListProductBundlesRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).listProductBundles(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of contract products with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Contract Products
     * @param {RevenueRecognitionApiListProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProducts(requestParameters: RevenueRecognitionApiListProductsRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).listProducts(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of revenue transactions with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Revenue Transactions
     * @param {RevenueRecognitionApiListRevenueTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRevenueTransactions(requestParameters: RevenueRecognitionApiListRevenueTransactionsRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).listRevenueTransactions(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for contracts by deal_name in a single request.
     * @summary Bulk Search Contracts
     * @param {RevenueRecognitionApiRrApiV1ContractsBulkSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsBulkSearchCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsBulkSearchCreateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsBulkSearchCreate(requestParameters.bulkContractSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Contract Bundle
     * @param {RevenueRecognitionApiRrApiV1ContractsBundlesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsBundlesDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsBundlesDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Contract Bundle
     * @param {RevenueRecognitionApiRrApiV1ContractsBundlesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsBundlesPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsBundlesPartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Contract Bundle
     * @param {RevenueRecognitionApiRrApiV1ContractsBundlesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsBundlesRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsBundlesRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Contract Bundle
     * @param {RevenueRecognitionApiRrApiV1ContractsBundlesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsBundlesUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsBundlesUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsBundlesUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Contract
     * @param {RevenueRecognitionApiRrApiV1ContractsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Duplicate Contract
     * @param {RevenueRecognitionApiRrApiV1ContractsDuplicateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsDuplicateCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsDuplicateCreateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsDuplicateCreate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update bundle allocations. Same behavior as PUT.
     * @summary Partial Update Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsMilestonesAllocationsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsMilestonesAllocationsPartialUpdate(requestParameters.contractId, requestParameters.milestoneId, requestParameters.patchedContractProductBundleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
     * @summary Get Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsMilestonesAllocationsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsMilestonesAllocationsRetrieve(requestParameters.contractId, requestParameters.milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
     * @summary Update Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsMilestonesAllocationsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesAllocationsUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsMilestonesAllocationsUpdate(requestParameters.contractId, requestParameters.milestoneId, requestParameters.contractProductBundleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Contract Milestone
     * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsMilestonesDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsMilestonesDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Contract Milestone
     * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsMilestonesPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsMilestonesPartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractMilestone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Contract Milestone
     * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsMilestonesRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsMilestonesRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Contract Milestone
     * @param {RevenueRecognitionApiRrApiV1ContractsMilestonesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsMilestonesUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsMilestonesUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsMilestonesUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractMilestone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Contract
     * @param {RevenueRecognitionApiRrApiV1ContractsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsPartialUpdate(requestParameters.id, requestParameters.patchedContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Contract
     * @param {RevenueRecognitionApiRrApiV1ContractsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update bundle allocations. Same behavior as PUT.
     * @summary Partial Update Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsSubscriptionsAllocationsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsSubscriptionsAllocationsPartialUpdate(requestParameters.contractId, requestParameters.subscriptionId, requestParameters.patchedContractProductBundleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
     * @summary Get Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsSubscriptionsAllocationsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsSubscriptionsAllocationsRetrieve(requestParameters.contractId, requestParameters.subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
     * @summary Update Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsSubscriptionsAllocationsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsAllocationsUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsSubscriptionsAllocationsUpdate(requestParameters.contractId, requestParameters.subscriptionId, requestParameters.contractProductBundleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Contract Subscription
     * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsSubscriptionsDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsSubscriptionsDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Contract Subscription
     * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsSubscriptionsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsSubscriptionsPartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Contract Subscription
     * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsSubscriptionsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsSubscriptionsRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Contract Subscription
     * @param {RevenueRecognitionApiRrApiV1ContractsSubscriptionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsSubscriptionsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsSubscriptionsUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsSubscriptionsUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminate a contract and optionally void associated invoices.          If the user has permission to terminate contracts and void invoices, both operations         are performed atomically. If the user lacks permission for either operation, a draft         is created instead, and the response indicates which operations were drafted.          Returns 400 if any of the provided void_invoice_ids are invalid (not found, already voided,         has payments, void date is before the invoice date, or in a closed period).
     * @summary Terminate Contract
     * @param {RevenueRecognitionApiRrApiV1ContractsTerminateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsTerminateCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsTerminateCreateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsTerminateCreate(requestParameters.id, requestParameters.terminateContract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Contract
     * @param {RevenueRecognitionApiRrApiV1ContractsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUpdate(requestParameters.id, requestParameters.contract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update bundle allocations. Same behavior as PUT.
     * @summary Partial Update Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageAllocationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageAllocationsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageAllocationsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageAllocationsPartialUpdate(requestParameters.contractId, requestParameters.usageId, requestParameters.patchedContractProductBundleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current bundle allocation details for a contract subscription, milestone, or usage.
     * @summary Get Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageAllocationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageAllocationsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageAllocationsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageAllocationsRetrieve(requestParameters.contractId, requestParameters.usageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Update the bundle allocations for a contract item.          The sum of all line amounts must equal the bundle\'s total_amount.         Changes will cascade to related RevenueTransactions and JournalEntries.         
     * @summary Update Bundle Allocations
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageAllocationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageAllocationsUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageAllocationsUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageAllocationsUpdate(requestParameters.contractId, requestParameters.usageId, requestParameters.contractProductBundleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List usage revenue records
     * @summary Create Contract Usage Revenue
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageCreate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageCreateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageCreate(requestParameters.contractId, requestParameters.contractUsage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete contract usage revenue records
     * @summary Delete Contract Usage Revenue
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageDestroy(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageDestroy(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List usage revenue records
     * @summary List Contract Usage Revenue
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageList(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageListRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageList(requestParameters.contractId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete contract usage revenue records
     * @summary Partially Update Contract Usage Revenue
     * @param {RevenueRecognitionApiRrApiV1ContractsUsagePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsagePartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsagePartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsagePartialUpdate(requestParameters.contractId, requestParameters.id, requestParameters.patchedContractUsage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete contract usage revenue records
     * @summary Retrieve Contract Usage Revenue
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageRetrieve(requestParameters.contractId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete contract usage revenue records
     * @summary Update Contract Usage Revenue
     * @param {RevenueRecognitionApiRrApiV1ContractsUsageUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ContractsUsageUpdate(requestParameters: RevenueRecognitionApiRrApiV1ContractsUsageUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ContractsUsageUpdate(requestParameters.contractId, requestParameters.id, requestParameters.contractUsage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Contract Customer
     * @param {RevenueRecognitionApiRrApiV1CustomersDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1CustomersDestroy(requestParameters: RevenueRecognitionApiRrApiV1CustomersDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1CustomersDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of contract customers with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Contract Customers
     * @param {RevenueRecognitionApiRrApiV1CustomersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1CustomersList(requestParameters: RevenueRecognitionApiRrApiV1CustomersListRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1CustomersList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Contract Customer
     * @param {RevenueRecognitionApiRrApiV1CustomersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1CustomersPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1CustomersPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1CustomersPartialUpdate(requestParameters.id, requestParameters.patchedContractCustomer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Contract Customer
     * @param {RevenueRecognitionApiRrApiV1CustomersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1CustomersRetrieve(requestParameters: RevenueRecognitionApiRrApiV1CustomersRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1CustomersRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Contract Customer
     * @param {RevenueRecognitionApiRrApiV1CustomersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1CustomersUpdate(requestParameters: RevenueRecognitionApiRrApiV1CustomersUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1CustomersUpdate(requestParameters.id, requestParameters.contractCustomer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Product Bundle
     * @param {RevenueRecognitionApiRrApiV1ProductBundlesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductBundlesDestroy(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductBundlesDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Product Bundle
     * @param {RevenueRecognitionApiRrApiV1ProductBundlesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductBundlesPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductBundlesPartialUpdate(requestParameters.id, requestParameters.patchedProductBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Product Bundle
     * @param {RevenueRecognitionApiRrApiV1ProductBundlesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductBundlesRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductBundlesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Product Bundle
     * @param {RevenueRecognitionApiRrApiV1ProductBundlesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductBundlesUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductBundlesUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductBundlesUpdate(requestParameters.id, requestParameters.productBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Product
     * @param {RevenueRecognitionApiRrApiV1ProductDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductDestroy(requestParameters: RevenueRecognitionApiRrApiV1ProductDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Product
     * @param {RevenueRecognitionApiRrApiV1ProductPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductPartialUpdate(requestParameters.id, requestParameters.patchedProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Product
     * @param {RevenueRecognitionApiRrApiV1ProductRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductRetrieve(requestParameters: RevenueRecognitionApiRrApiV1ProductRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Product
     * @param {RevenueRecognitionApiRrApiV1ProductUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1ProductUpdate(requestParameters: RevenueRecognitionApiRrApiV1ProductUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1ProductUpdate(requestParameters.id, requestParameters.product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Revenue Transaction
     * @param {RevenueRecognitionApiRrApiV1TransactionsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1TransactionsDestroy(requestParameters: RevenueRecognitionApiRrApiV1TransactionsDestroyRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1TransactionsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Revenue Transaction
     * @param {RevenueRecognitionApiRrApiV1TransactionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1TransactionsPartialUpdate(requestParameters: RevenueRecognitionApiRrApiV1TransactionsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1TransactionsPartialUpdate(requestParameters.id, requestParameters.patchedRevenueTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Revenue Transaction
     * @param {RevenueRecognitionApiRrApiV1TransactionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1TransactionsRetrieve(requestParameters: RevenueRecognitionApiRrApiV1TransactionsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1TransactionsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Revenue Transaction
     * @param {RevenueRecognitionApiRrApiV1TransactionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rrApiV1TransactionsUpdate(requestParameters: RevenueRecognitionApiRrApiV1TransactionsUpdateRequest, options?: RawAxiosRequestConfig) {
        return RevenueRecognitionApiFp(this.configuration).rrApiV1TransactionsUpdate(requestParameters.id, requestParameters.revenueTransaction, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsApi - axios parameter creator
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete File
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiFileDestroy', 'id', id)
            const localVarPath = `/ca/api/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of files with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Files
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileList: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch File
         * @param {number} id 
         * @param {PatchedFile} [patchedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFilePartialUpdate: async (id: number, patchedFile?: PatchedFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiFilePartialUpdate', 'id', id)
            const localVarPath = `/ca/api/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get File
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiFileRetrieve', 'id', id)
            const localVarPath = `/ca/api/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update File
         * @param {number} id 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileUpdate: async (id: number, modelFile: ModelFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiFileUpdate', 'id', id)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('caApiFileUpdate', 'modelFile', modelFile)
            const localVarPath = `/ca/api/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Upload a file directly to Campfire. This is the primary way to upload files.          **Supported Models:**         bill, chat, close_task, closecheckitem, contract, credit_memo, customer, debit_memo, draft_queue, fixed_asset, intercompany_journal, invoice, journal_entry, journalentry, reconciliation, reconciliation_report          **Supported Content Types:**         application/msword, application/pdf, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.wordprocessingml.document, image/gif, image/jpeg, image/jpg, image/png, image/webp, text/csv, text/plain          **Maximum File Size:** 100MB          **Example:**         ```bash         curl -X POST \"https://api.meetcampfire.com/ca/api/file/upload?model=bill&object_id=12345\" \\           -H \"Authorization: Token YOUR_TOKEN\" \\           -F \"file=@receipt.pdf\"         ```          **Query Parameters:**         - `model` (required): Model type (e.g., \"bill\", \"invoice\", \"contract\")         - `object_id` (optional): ID of the object to attach the file to          **Request Body:**         - `file` (required): The file to upload (multipart/form-data)         
         * @summary Upload File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileUploadCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/file/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Customer Currencies
         * @param {CustomerCurrency} [customerCurrency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyCreate: async (customerCurrency?: CustomerCurrency, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/user_currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCurrency, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Customer Currencies
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiUserCurrencyDestroy', 'id', id)
            const localVarPath = `/ca/api/user_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          Retrieve a list of customer currencies with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Customer Currencies
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyList: async (includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/user_currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (lastModifiedAtGte !== undefined) {
                localVarQueryParameter['last_modified_at__gte'] = lastModifiedAtGte;
            }

            if (lastModifiedAtLte !== undefined) {
                localVarQueryParameter['last_modified_at__lte'] = lastModifiedAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Customer Currencies
         * @param {number} id 
         * @param {PatchedCustomerCurrency} [patchedCustomerCurrency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyPartialUpdate: async (id: number, patchedCustomerCurrency?: PatchedCustomerCurrency, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiUserCurrencyPartialUpdate', 'id', id)
            const localVarPath = `/ca/api/user_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomerCurrency, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Customer Currencies
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiUserCurrencyRetrieve', 'id', id)
            const localVarPath = `/ca/api/user_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Customer Currencies
         * @param {number} id 
         * @param {CustomerCurrency} [customerCurrency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyUpdate: async (id: number, customerCurrency?: CustomerCurrency, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('caApiUserCurrencyUpdate', 'id', id)
            const localVarPath = `/ca/api/user_currency/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCurrency, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Currencies Exchange Rates for Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyWithRateRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ca/api/user_currency/with_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Chart Entity
         * @param {ChartEntity} [chartEntity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityCreate: async (chartEntity?: ChartEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/entity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Chart Entity
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiEntityDestroy', 'id', id)
            const localVarPath = `/coa/api/entity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns ALL entities for intercompany journal entry creation.  This endpoint bypasses entity-scoped filtering because users need to select entities they don\'t normally have access to when creating intercompany journal entries (per the entity-scoped-user-access spec).  Uses minimal serializer to only expose id, name, and currency - preventing data leakage of sensitive entity details to users who may not have full access to all entities.
         * @summary List All Entities for Intercompany JE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityForIntercompanyList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/entity/for-intercompany`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of chart entities with optional filtering
         * @summary List Chart Entities
         * @param {boolean} [includeInactive] Include inactive entities in results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityList: async (includeInactive?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/entity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = includeInactive;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Chart Entity Logo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityLogoCreate: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiEntityLogoCreate', 'id', id)
            const localVarPath = `/coa/api/entity/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial Update Chart Entity
         * @param {number} id 
         * @param {PatchedChartEntity} [patchedChartEntity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityPartialUpdate: async (id: number, patchedChartEntity?: PatchedChartEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiEntityPartialUpdate', 'id', id)
            const localVarPath = `/coa/api/entity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedChartEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Chart Entity
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiEntityRetrieve', 'id', id)
            const localVarPath = `/coa/api/entity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Chart Entity
         * @param {number} id 
         * @param {ChartEntity} [chartEntity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityUpdate: async (id: number, chartEntity?: ChartEntity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coaApiEntityUpdate', 'id', id)
            const localVarPath = `/coa/api/entity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update the default chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Partially Update Chart Account Settings
         * @param {PatchedChartAccountSettings} [patchedChartAccountSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPartialUpdateChartAccountSettings: async (patchedChartAccountSettings?: PatchedChartAccountSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/chart-account-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedChartAccountSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Retrieve Chart Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsRetrieveChartAccountSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/chart-account-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Update Chart Account Settings
         * @param {ChartAccountSettings} [chartAccountSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdateChartAccountSettings: async (chartAccountSettings?: ChartAccountSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coa/api/chart-account-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartAccountSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete File
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiFileDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiFileDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiFileDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of files with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Files
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiFileList(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiFileList(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiFileList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch File
         * @param {number} id 
         * @param {PatchedFile} [patchedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiFilePartialUpdate(id: number, patchedFile?: PatchedFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiFilePartialUpdate(id, patchedFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiFilePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get File
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiFileRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiFileRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiFileRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update File
         * @param {number} id 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiFileUpdate(id: number, modelFile: ModelFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiFileUpdate(id, modelFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiFileUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Upload a file directly to Campfire. This is the primary way to upload files.          **Supported Models:**         bill, chat, close_task, closecheckitem, contract, credit_memo, customer, debit_memo, draft_queue, fixed_asset, intercompany_journal, invoice, journal_entry, journalentry, reconciliation, reconciliation_report          **Supported Content Types:**         application/msword, application/pdf, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.wordprocessingml.document, image/gif, image/jpeg, image/jpg, image/png, image/webp, text/csv, text/plain          **Maximum File Size:** 100MB          **Example:**         ```bash         curl -X POST \"https://api.meetcampfire.com/ca/api/file/upload?model=bill&object_id=12345\" \\           -H \"Authorization: Token YOUR_TOKEN\" \\           -F \"file=@receipt.pdf\"         ```          **Query Parameters:**         - `model` (required): Model type (e.g., \"bill\", \"invoice\", \"contract\")         - `object_id` (optional): ID of the object to attach the file to          **Request Body:**         - `file` (required): The file to upload (multipart/form-data)         
         * @summary Upload File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiFileUploadCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiFileUploadCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiFileUploadCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Customer Currencies
         * @param {CustomerCurrency} [customerCurrency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiUserCurrencyCreate(customerCurrency?: CustomerCurrency, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiUserCurrencyCreate(customerCurrency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiUserCurrencyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Customer Currencies
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiUserCurrencyDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiUserCurrencyDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiUserCurrencyDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          Retrieve a list of customer currencies with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Customer Currencies
         * @param {boolean} [includeDeleted] When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
         * @param {string} [lastModifiedAtGte] Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {string} [lastModifiedAtLte] Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiUserCurrencyList(includeDeleted?: boolean, lastModifiedAtGte?: string, lastModifiedAtLte?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCustomerCurrencyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiUserCurrencyList(includeDeleted, lastModifiedAtGte, lastModifiedAtLte, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiUserCurrencyList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Customer Currencies
         * @param {number} id 
         * @param {PatchedCustomerCurrency} [patchedCustomerCurrency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiUserCurrencyPartialUpdate(id: number, patchedCustomerCurrency?: PatchedCustomerCurrency, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiUserCurrencyPartialUpdate(id, patchedCustomerCurrency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiUserCurrencyPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Customer Currencies
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiUserCurrencyRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiUserCurrencyRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiUserCurrencyRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Customer Currencies
         * @param {number} id 
         * @param {CustomerCurrency} [customerCurrency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiUserCurrencyUpdate(id: number, customerCurrency?: CustomerCurrency, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCurrency>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiUserCurrencyUpdate(id, customerCurrency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiUserCurrencyUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Currencies Exchange Rates for Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caApiUserCurrencyWithRateRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caApiUserCurrencyWithRateRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.caApiUserCurrencyWithRateRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Chart Entity
         * @param {ChartEntity} [chartEntity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityCreate(chartEntity?: ChartEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityCreate(chartEntity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Chart Entity
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns ALL entities for intercompany journal entry creation.  This endpoint bypasses entity-scoped filtering because users need to select entities they don\'t normally have access to when creating intercompany journal entries (per the entity-scoped-user-access spec).  Uses minimal serializer to only expose id, name, and currency - preventing data leakage of sensitive entity details to users who may not have full access to all entities.
         * @summary List All Entities for Intercompany JE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityForIntercompanyList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChartEntityMinimal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityForIntercompanyList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityForIntercompanyList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of chart entities with optional filtering
         * @summary List Chart Entities
         * @param {boolean} [includeInactive] Include inactive entities in results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityList(includeInactive?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChartEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityList(includeInactive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Chart Entity Logo
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityLogoCreate(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityLogoCreate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityLogoCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partial Update Chart Entity
         * @param {number} id 
         * @param {PatchedChartEntity} [patchedChartEntity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityPartialUpdate(id: number, patchedChartEntity?: PatchedChartEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityPartialUpdate(id, patchedChartEntity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Chart Entity
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Chart Entity
         * @param {number} id 
         * @param {ChartEntity} [chartEntity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coaApiEntityUpdate(id: number, chartEntity?: ChartEntity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coaApiEntityUpdate(id, chartEntity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.coaApiEntityUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update the default chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Partially Update Chart Account Settings
         * @param {PatchedChartAccountSettings} [patchedChartAccountSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsPartialUpdateChartAccountSettings(patchedChartAccountSettings?: PatchedChartAccountSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccountSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsPartialUpdateChartAccountSettings(patchedChartAccountSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsPartialUpdateChartAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Retrieve Chart Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsRetrieveChartAccountSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccountSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsRetrieveChartAccountSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsRetrieveChartAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Update Chart Account Settings
         * @param {ChartAccountSettings} [chartAccountSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsUpdateChartAccountSettings(chartAccountSettings?: ChartAccountSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartAccountSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsUpdateChartAccountSettings(chartAccountSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsUpdateChartAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsApi - factory interface
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete File
         * @param {SettingsApiCaApiFileDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileDestroy(requestParameters: SettingsApiCaApiFileDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiFileDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of files with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Files
         * @param {SettingsApiCaApiFileListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileList(requestParameters: SettingsApiCaApiFileListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedFileList> {
            return localVarFp.caApiFileList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch File
         * @param {SettingsApiCaApiFilePartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFilePartialUpdate(requestParameters: SettingsApiCaApiFilePartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.caApiFilePartialUpdate(requestParameters.id, requestParameters.patchedFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get File
         * @param {SettingsApiCaApiFileRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileRetrieve(requestParameters: SettingsApiCaApiFileRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.caApiFileRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update File
         * @param {SettingsApiCaApiFileUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileUpdate(requestParameters: SettingsApiCaApiFileUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.caApiFileUpdate(requestParameters.id, requestParameters.modelFile, options).then((request) => request(axios, basePath));
        },
        /**
         *          Upload a file directly to Campfire. This is the primary way to upload files.          **Supported Models:**         bill, chat, close_task, closecheckitem, contract, credit_memo, customer, debit_memo, draft_queue, fixed_asset, intercompany_journal, invoice, journal_entry, journalentry, reconciliation, reconciliation_report          **Supported Content Types:**         application/msword, application/pdf, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.wordprocessingml.document, image/gif, image/jpeg, image/jpg, image/png, image/webp, text/csv, text/plain          **Maximum File Size:** 100MB          **Example:**         ```bash         curl -X POST \"https://api.meetcampfire.com/ca/api/file/upload?model=bill&object_id=12345\" \\           -H \"Authorization: Token YOUR_TOKEN\" \\           -F \"file=@receipt.pdf\"         ```          **Query Parameters:**         - `model` (required): Model type (e.g., \"bill\", \"invoice\", \"contract\")         - `object_id` (optional): ID of the object to attach the file to          **Request Body:**         - `file` (required): The file to upload (multipart/form-data)         
         * @summary Upload File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiFileUploadCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiFileUploadCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Customer Currencies
         * @param {SettingsApiCaApiUserCurrencyCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyCreate(requestParameters: SettingsApiCaApiUserCurrencyCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CustomerCurrency> {
            return localVarFp.caApiUserCurrencyCreate(requestParameters.customerCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Customer Currencies
         * @param {SettingsApiCaApiUserCurrencyDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyDestroy(requestParameters: SettingsApiCaApiUserCurrencyDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiUserCurrencyDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *          Retrieve a list of customer currencies with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
         * @summary List Customer Currencies
         * @param {SettingsApiCaApiUserCurrencyListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyList(requestParameters: SettingsApiCaApiUserCurrencyListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCustomerCurrencyList> {
            return localVarFp.caApiUserCurrencyList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Customer Currencies
         * @param {SettingsApiCaApiUserCurrencyPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyPartialUpdate(requestParameters: SettingsApiCaApiUserCurrencyPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerCurrency> {
            return localVarFp.caApiUserCurrencyPartialUpdate(requestParameters.id, requestParameters.patchedCustomerCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Customer Currencies
         * @param {SettingsApiCaApiUserCurrencyRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyRetrieve(requestParameters: SettingsApiCaApiUserCurrencyRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerCurrency> {
            return localVarFp.caApiUserCurrencyRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Customer Currencies
         * @param {SettingsApiCaApiUserCurrencyUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyUpdate(requestParameters: SettingsApiCaApiUserCurrencyUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerCurrency> {
            return localVarFp.caApiUserCurrencyUpdate(requestParameters.id, requestParameters.customerCurrency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Currencies Exchange Rates for Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caApiUserCurrencyWithRateRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.caApiUserCurrencyWithRateRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
         * @summary Create Chart Entity
         * @param {SettingsApiCoaApiEntityCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityCreate(requestParameters: SettingsApiCoaApiEntityCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ChartEntity> {
            return localVarFp.coaApiEntityCreate(requestParameters.chartEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Chart Entity
         * @param {SettingsApiCoaApiEntityDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityDestroy(requestParameters: SettingsApiCoaApiEntityDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiEntityDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns ALL entities for intercompany journal entry creation.  This endpoint bypasses entity-scoped filtering because users need to select entities they don\'t normally have access to when creating intercompany journal entries (per the entity-scoped-user-access spec).  Uses minimal serializer to only expose id, name, and currency - preventing data leakage of sensitive entity details to users who may not have full access to all entities.
         * @summary List All Entities for Intercompany JE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityForIntercompanyList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ChartEntityMinimal>> {
            return localVarFp.coaApiEntityForIntercompanyList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of chart entities with optional filtering
         * @summary List Chart Entities
         * @param {SettingsApiCoaApiEntityListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityList(requestParameters: SettingsApiCoaApiEntityListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ChartEntity>> {
            return localVarFp.coaApiEntityList(requestParameters.includeInactive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Chart Entity Logo
         * @param {SettingsApiCoaApiEntityLogoCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityLogoCreate(requestParameters: SettingsApiCoaApiEntityLogoCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coaApiEntityLogoCreate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partial Update Chart Entity
         * @param {SettingsApiCoaApiEntityPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityPartialUpdate(requestParameters: SettingsApiCoaApiEntityPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartEntity> {
            return localVarFp.coaApiEntityPartialUpdate(requestParameters.id, requestParameters.patchedChartEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Chart Entity
         * @param {SettingsApiCoaApiEntityRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityRetrieve(requestParameters: SettingsApiCoaApiEntityRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartEntity> {
            return localVarFp.coaApiEntityRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Chart Entity
         * @param {SettingsApiCoaApiEntityUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coaApiEntityUpdate(requestParameters: SettingsApiCoaApiEntityUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartEntity> {
            return localVarFp.coaApiEntityUpdate(requestParameters.id, requestParameters.chartEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update the default chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Partially Update Chart Account Settings
         * @param {SettingsApiSettingsPartialUpdateChartAccountSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPartialUpdateChartAccountSettings(requestParameters: SettingsApiSettingsPartialUpdateChartAccountSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccountSettings> {
            return localVarFp.settingsPartialUpdateChartAccountSettings(requestParameters.patchedChartAccountSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Retrieve Chart Account Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsRetrieveChartAccountSettings(options?: RawAxiosRequestConfig): AxiosPromise<ChartAccountSettings> {
            return localVarFp.settingsRetrieveChartAccountSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
         * @summary Update Chart Account Settings
         * @param {SettingsApiSettingsUpdateChartAccountSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdateChartAccountSettings(requestParameters: SettingsApiSettingsUpdateChartAccountSettingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ChartAccountSettings> {
            return localVarFp.settingsUpdateChartAccountSettings(requestParameters.chartAccountSettings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for caApiFileDestroy operation in SettingsApi.
 */
export interface SettingsApiCaApiFileDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for caApiFileList operation in SettingsApi.
 */
export interface SettingsApiCaApiFileListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for caApiFilePartialUpdate operation in SettingsApi.
 */
export interface SettingsApiCaApiFilePartialUpdateRequest {
    readonly id: number

    readonly patchedFile?: PatchedFile
}

/**
 * Request parameters for caApiFileRetrieve operation in SettingsApi.
 */
export interface SettingsApiCaApiFileRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for caApiFileUpdate operation in SettingsApi.
 */
export interface SettingsApiCaApiFileUpdateRequest {
    readonly id: number

    readonly modelFile: ModelFile
}

/**
 * Request parameters for caApiUserCurrencyCreate operation in SettingsApi.
 */
export interface SettingsApiCaApiUserCurrencyCreateRequest {
    readonly customerCurrency?: CustomerCurrency
}

/**
 * Request parameters for caApiUserCurrencyDestroy operation in SettingsApi.
 */
export interface SettingsApiCaApiUserCurrencyDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for caApiUserCurrencyList operation in SettingsApi.
 */
export interface SettingsApiCaApiUserCurrencyListRequest {
    /**
     * When set to \&#39;true\&#39;, returns ONLY deleted records instead of active records. Deleted records contain minimal data: \&#39;id\&#39;, \&#39;is_deleted&#x3D;true\&#39;, \&#39;deleted_at\&#39; timestamp, and \&#39;last_modified_at\&#39;. When \&#39;false\&#39; or omitted, returns ONLY active records. This provides clean separation between active and deleted data.
     */
    readonly includeDeleted?: boolean

    /**
     * Filter for records modified on or after this timestamp. Format: ISO 8601 (e.g., \&#39;2024-01-01T00:00:00Z\&#39; or \&#39;2024-01-01\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtGte?: string

    /**
     * Filter for records modified on or before this timestamp. Format: ISO 8601 (e.g., \&#39;2024-12-31T23:59:59Z\&#39; or \&#39;2024-12-31\&#39;). Works with both active records and deleted records (filters by deletion time for deleted records).
     */
    readonly lastModifiedAtLte?: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number
}

/**
 * Request parameters for caApiUserCurrencyPartialUpdate operation in SettingsApi.
 */
export interface SettingsApiCaApiUserCurrencyPartialUpdateRequest {
    readonly id: number

    readonly patchedCustomerCurrency?: PatchedCustomerCurrency
}

/**
 * Request parameters for caApiUserCurrencyRetrieve operation in SettingsApi.
 */
export interface SettingsApiCaApiUserCurrencyRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for caApiUserCurrencyUpdate operation in SettingsApi.
 */
export interface SettingsApiCaApiUserCurrencyUpdateRequest {
    readonly id: number

    readonly customerCurrency?: CustomerCurrency
}

/**
 * Request parameters for coaApiEntityCreate operation in SettingsApi.
 */
export interface SettingsApiCoaApiEntityCreateRequest {
    readonly chartEntity?: ChartEntity
}

/**
 * Request parameters for coaApiEntityDestroy operation in SettingsApi.
 */
export interface SettingsApiCoaApiEntityDestroyRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiEntityList operation in SettingsApi.
 */
export interface SettingsApiCoaApiEntityListRequest {
    /**
     * Include inactive entities in results
     */
    readonly includeInactive?: boolean
}

/**
 * Request parameters for coaApiEntityLogoCreate operation in SettingsApi.
 */
export interface SettingsApiCoaApiEntityLogoCreateRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiEntityPartialUpdate operation in SettingsApi.
 */
export interface SettingsApiCoaApiEntityPartialUpdateRequest {
    readonly id: number

    readonly patchedChartEntity?: PatchedChartEntity
}

/**
 * Request parameters for coaApiEntityRetrieve operation in SettingsApi.
 */
export interface SettingsApiCoaApiEntityRetrieveRequest {
    readonly id: number
}

/**
 * Request parameters for coaApiEntityUpdate operation in SettingsApi.
 */
export interface SettingsApiCoaApiEntityUpdateRequest {
    readonly id: number

    readonly chartEntity?: ChartEntity
}

/**
 * Request parameters for settingsPartialUpdateChartAccountSettings operation in SettingsApi.
 */
export interface SettingsApiSettingsPartialUpdateChartAccountSettingsRequest {
    readonly patchedChartAccountSettings?: PatchedChartAccountSettings
}

/**
 * Request parameters for settingsUpdateChartAccountSettings operation in SettingsApi.
 */
export interface SettingsApiSettingsUpdateChartAccountSettingsRequest {
    readonly chartAccountSettings?: ChartAccountSettings
}

/**
 * SettingsApi - object-oriented interface
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @summary Delete File
     * @param {SettingsApiCaApiFileDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiFileDestroy(requestParameters: SettingsApiCaApiFileDestroyRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiFileDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of files with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Files
     * @param {SettingsApiCaApiFileListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiFileList(requestParameters: SettingsApiCaApiFileListRequest = {}, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiFileList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch File
     * @param {SettingsApiCaApiFilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiFilePartialUpdate(requestParameters: SettingsApiCaApiFilePartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiFilePartialUpdate(requestParameters.id, requestParameters.patchedFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get File
     * @param {SettingsApiCaApiFileRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiFileRetrieve(requestParameters: SettingsApiCaApiFileRetrieveRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiFileRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update File
     * @param {SettingsApiCaApiFileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiFileUpdate(requestParameters: SettingsApiCaApiFileUpdateRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiFileUpdate(requestParameters.id, requestParameters.modelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Upload a file directly to Campfire. This is the primary way to upload files.          **Supported Models:**         bill, chat, close_task, closecheckitem, contract, credit_memo, customer, debit_memo, draft_queue, fixed_asset, intercompany_journal, invoice, journal_entry, journalentry, reconciliation, reconciliation_report          **Supported Content Types:**         application/msword, application/pdf, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.wordprocessingml.document, image/gif, image/jpeg, image/jpg, image/png, image/webp, text/csv, text/plain          **Maximum File Size:** 100MB          **Example:**         ```bash         curl -X POST \"https://api.meetcampfire.com/ca/api/file/upload?model=bill&object_id=12345\" \\           -H \"Authorization: Token YOUR_TOKEN\" \\           -F \"file=@receipt.pdf\"         ```          **Query Parameters:**         - `model` (required): Model type (e.g., \"bill\", \"invoice\", \"contract\")         - `object_id` (optional): ID of the object to attach the file to          **Request Body:**         - `file` (required): The file to upload (multipart/form-data)         
     * @summary Upload File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiFileUploadCreate(options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiFileUploadCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Customer Currencies
     * @param {SettingsApiCaApiUserCurrencyCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiUserCurrencyCreate(requestParameters: SettingsApiCaApiUserCurrencyCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiUserCurrencyCreate(requestParameters.customerCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Customer Currencies
     * @param {SettingsApiCaApiUserCurrencyDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiUserCurrencyDestroy(requestParameters: SettingsApiCaApiUserCurrencyDestroyRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiUserCurrencyDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          Retrieve a list of customer currencies with optional filtering and sorting.          Supports including soft-deleted records for audit and recovery purposes.         When include_deleted=true, returns ONLY deleted records instead of active records.         Deleted records contain minimal data: \'id\', \'is_deleted=true\', \'deleted_at\' timestamp,         and \'last_modified_at\'. When \'false\' or omitted, returns ONLY active records.         This provides clean separation between active and deleted data.         
     * @summary List Customer Currencies
     * @param {SettingsApiCaApiUserCurrencyListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiUserCurrencyList(requestParameters: SettingsApiCaApiUserCurrencyListRequest = {}, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiUserCurrencyList(requestParameters.includeDeleted, requestParameters.lastModifiedAtGte, requestParameters.lastModifiedAtLte, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Customer Currencies
     * @param {SettingsApiCaApiUserCurrencyPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiUserCurrencyPartialUpdate(requestParameters: SettingsApiCaApiUserCurrencyPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiUserCurrencyPartialUpdate(requestParameters.id, requestParameters.patchedCustomerCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Customer Currencies
     * @param {SettingsApiCaApiUserCurrencyRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiUserCurrencyRetrieve(requestParameters: SettingsApiCaApiUserCurrencyRetrieveRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiUserCurrencyRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Customer Currencies
     * @param {SettingsApiCaApiUserCurrencyUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiUserCurrencyUpdate(requestParameters: SettingsApiCaApiUserCurrencyUpdateRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiUserCurrencyUpdate(requestParameters.id, requestParameters.customerCurrency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Currencies Exchange Rates for Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public caApiUserCurrencyWithRateRetrieve(options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).caApiUserCurrencyWithRateRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete mixin for history filtering with pagination support. Returns either active OR deleted records based on include_deleted parameter.
     * @summary Create Chart Entity
     * @param {SettingsApiCoaApiEntityCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityCreate(requestParameters: SettingsApiCoaApiEntityCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityCreate(requestParameters.chartEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Chart Entity
     * @param {SettingsApiCoaApiEntityDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityDestroy(requestParameters: SettingsApiCoaApiEntityDestroyRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns ALL entities for intercompany journal entry creation.  This endpoint bypasses entity-scoped filtering because users need to select entities they don\'t normally have access to when creating intercompany journal entries (per the entity-scoped-user-access spec).  Uses minimal serializer to only expose id, name, and currency - preventing data leakage of sensitive entity details to users who may not have full access to all entities.
     * @summary List All Entities for Intercompany JE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityForIntercompanyList(options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityForIntercompanyList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of chart entities with optional filtering
     * @summary List Chart Entities
     * @param {SettingsApiCoaApiEntityListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityList(requestParameters: SettingsApiCoaApiEntityListRequest = {}, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityList(requestParameters.includeInactive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Chart Entity Logo
     * @param {SettingsApiCoaApiEntityLogoCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityLogoCreate(requestParameters: SettingsApiCoaApiEntityLogoCreateRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityLogoCreate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partial Update Chart Entity
     * @param {SettingsApiCoaApiEntityPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityPartialUpdate(requestParameters: SettingsApiCoaApiEntityPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityPartialUpdate(requestParameters.id, requestParameters.patchedChartEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Chart Entity
     * @param {SettingsApiCoaApiEntityRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityRetrieve(requestParameters: SettingsApiCoaApiEntityRetrieveRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Chart Entity
     * @param {SettingsApiCoaApiEntityUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public coaApiEntityUpdate(requestParameters: SettingsApiCoaApiEntityUpdateRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).coaApiEntityUpdate(requestParameters.id, requestParameters.chartEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update the default chart accounts to be used across the platform. Each input is the id to an existing chart account.
     * @summary Partially Update Chart Account Settings
     * @param {SettingsApiSettingsPartialUpdateChartAccountSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settingsPartialUpdateChartAccountSettings(requestParameters: SettingsApiSettingsPartialUpdateChartAccountSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsPartialUpdateChartAccountSettings(requestParameters.patchedChartAccountSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
     * @summary Retrieve Chart Account Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settingsRetrieveChartAccountSettings(options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsRetrieveChartAccountSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * These are the defaults chart accounts to be used across the platform. Each input is the id to an existing chart account.
     * @summary Update Chart Account Settings
     * @param {SettingsApiSettingsUpdateChartAccountSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public settingsUpdateChartAccountSettings(requestParameters: SettingsApiSettingsUpdateChartAccountSettingsRequest = {}, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsUpdateChartAccountSettings(requestParameters.chartAccountSettings, options).then((request) => request(this.axios, this.basePath));
    }
}



